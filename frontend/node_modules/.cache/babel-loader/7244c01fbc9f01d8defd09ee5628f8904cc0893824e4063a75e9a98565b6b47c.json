{"ast":null,"code":"import { createElement, isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { DataUtil } from '@syncfusion/ej2-data';\nimport { subtractThickness, valueToCoefficient, sum, redrawElement, isBreakLabel, ChartLocation } from '../../common/utils/helper';\nimport { subArray, inside, appendChildElement, stringToNumber } from '../../common/utils/helper';\nimport { Thickness, logBase, createZoomingLabels, getElement } from '../../common/utils/helper';\nimport { Size, Rect, measureText, TextOption, PathOption } from '@syncfusion/ej2-svg-base';\nimport { textElement, textTrim, getRotatedRectangleCoordinates, isRotatedRectIntersect, isZoomSet } from '../../common/utils/helper';\n/**\n * Specifies the Cartesian Axis Layout.\n */\nvar axisPadding = 10;\nvar CartesianAxisLayoutPanel = /** @class */function () {\n  /** @private */\n  function CartesianAxisLayoutPanel(chartModule) {\n    this.chart = chartModule;\n    this.padding = 5;\n  }\n  /**\n   * Measure the axis size.\n   *\n   * @returns {void}\n   * @private\n   */\n  CartesianAxisLayoutPanel.prototype.measureAxis = function (rect) {\n    var chart = this.chart;\n    var chartAreaWidth = chart.chartArea.width ? stringToNumber(chart.chartArea.width, chart.availableSize.width) : null;\n    this.crossAt(chart);\n    this.seriesClipRect = new Rect(rect.x, rect.y, rect.width, rect.height);\n    this.initialClipRect = rect;\n    this.leftSize = 0;\n    this.rightSize = 0;\n    this.topSize = 0;\n    this.bottomSize = 0;\n    //Measure Axis size with initial Rect\n    this.measureRowAxis(chart, this.initialClipRect);\n    this.initialClipRect = subtractThickness(this.initialClipRect, new Thickness(this.leftSize, this.rightSize, 0, 0));\n    this.measureColumnAxis(chart, this.initialClipRect);\n    this.initialClipRect = subtractThickness(this.initialClipRect, new Thickness(0, 0, this.topSize, this.bottomSize));\n    if (!this.chart.delayRedraw) {\n      this.calculateAxisSize(this.initialClipRect);\n    }\n    this.leftSize = 0;\n    this.rightSize = 0;\n    this.topSize = 0;\n    this.bottomSize = 0;\n    //Measure Axis size with series Rect\n    this.measureRowAxis(chart, this.initialClipRect);\n    this.seriesClipRect = subtractThickness(this.seriesClipRect, new Thickness(this.leftSize, this.rightSize, 0, 0));\n    this.measureColumnAxis(chart, this.initialClipRect);\n    this.seriesClipRect = subtractThickness(this.seriesClipRect, new Thickness(0, 0, this.topSize, this.bottomSize));\n    if (chartAreaWidth) {\n      this.calculateFixedChartArea(chart, chartAreaWidth);\n    }\n    if (!this.chart.delayRedraw) {\n      chart.refreshAxis();\n      this.calculateAxisSize(this.seriesClipRect);\n    }\n  };\n  CartesianAxisLayoutPanel.prototype.calculateFixedChartArea = function (chart, chartAreaWidth) {\n    this.seriesClipRect.width = chartAreaWidth;\n    this.seriesClipRect.x = chart.availableSize.width - chart.margin.right - chartAreaWidth - (chart.legendSettings.position === \"Right\" ? chart.legendModule.legendBounds.width : 0);\n    for (var _i = 0, _a = chart.rows; _i < _a.length; _i++) {\n      var item = _a[_i];\n      this.seriesClipRect.x -= sum(item.farSizes);\n    }\n  };\n  CartesianAxisLayoutPanel.prototype.measureRowAxis = function (chart, rect) {\n    var row;\n    this.calculateRowSize(rect);\n    for (var _i = 0, _a = chart.rows; _i < _a.length; _i++) {\n      var item = _a[_i];\n      row = item;\n      row.nearSizes = [];\n      row.farSizes = [];\n      this.arrangeAxis(row);\n      this.measureDefinition(row, chart, new Size(chart.availableSize.width, row.computedHeight));\n      if (this.leftSize < sum(row.nearSizes)) {\n        this.leftSize = sum(row.nearSizes);\n      }\n      if (this.rightSize < sum(row.farSizes)) {\n        this.rightSize = sum(row.farSizes);\n      }\n    }\n  };\n  CartesianAxisLayoutPanel.prototype.measureColumnAxis = function (chart, rect) {\n    var column;\n    this.calculateColumnSize(rect);\n    for (var _i = 0, _a = chart.columns; _i < _a.length; _i++) {\n      var item = _a[_i];\n      column = item;\n      column.farSizes = [];\n      column.nearSizes = [];\n      this.arrangeAxis(column);\n      this.measureDefinition(column, chart, new Size(column.computedWidth, chart.availableSize.height));\n      if (this.bottomSize < sum(column.nearSizes)) {\n        this.bottomSize = sum(column.nearSizes);\n      }\n      if (this.topSize < sum(column.farSizes)) {\n        this.topSize = sum(column.farSizes);\n      }\n    }\n  };\n  /**\n   * Measure the column and row in chart.\n   *\n   * @returns {void}\n   * @private\n   */\n  CartesianAxisLayoutPanel.prototype.measureDefinition = function (definition, chart, size) {\n    var ele = 16; // scrollbar element height is 16.\n    for (var _i = 0, _a = definition.axes; _i < _a.length; _i++) {\n      var axis = _a[_i];\n      axis.scrollBarHeight = chart.scrollBarModule && chart.zoomModule && chart.zoomSettings.enableScrollbar && axis.enableScrollbarOnZooming && chart.zoomModule.isZoomed && (axis.zoomFactor < 1 || axis.zoomPosition > 0) ? ele : 0;\n      axis.scrollBarHeight = chart.scrollBarModule && (chart.zoomModule && chart.zoomSettings.enableScrollbar && axis.enableScrollbarOnZooming && chart.zoomModule.isZoomed && (axis.zoomFactor < 1 || axis.zoomPosition > 0) || axis.scrollbarSettings.enable) ? ele : 0;\n      axis.getModule(chart);\n      axis.baseModule.calculateRangeAndInterval(size, axis);\n      definition.computeSize(axis, axis.scrollBarHeight);\n    }\n    if (definition.farSizes.length > 0) {\n      definition.farSizes[definition.farSizes.length - 1] -= axisPadding;\n    }\n    if (definition.nearSizes.length > 0) {\n      definition.nearSizes[definition.nearSizes.length - 1] -= axisPadding;\n    }\n  };\n  /**\n   * Measure the axis.\n   *\n   * @returns {void}\n   * @private\n   */\n  CartesianAxisLayoutPanel.prototype.calculateAxisSize = function (rect) {\n    var chart = this.chart;\n    var row;\n    var column;\n    var definition;\n    var axis;\n    var nearCount = 0;\n    var farCount = 0;\n    var size = 0;\n    var x;\n    var y;\n    var axisOffset;\n    this.calculateRowSize(rect);\n    for (var i = 0, len = chart.rows.length; i < len; i++) {\n      row = chart.rows[i];\n      nearCount = 0;\n      farCount = 0;\n      for (var j = 0, len_1 = row.axes.length; j < len_1; j++) {\n        axis = row.axes[j];\n        axisOffset = axis.plotOffset;\n        if (axis.rect.height === 0) {\n          axis.rect.height = row.computedHeight;\n          size = 0;\n          for (var k = i + 1, len_2 = i + axis.span; k < len_2; k++) {\n            definition = chart.rows[k];\n            size += definition.computedHeight;\n          }\n          axis.rect.y = row.computedTop - size + (axis.plotOffsetTop ? axis.plotOffsetTop : axisOffset);\n          axis.rect.height = axis.rect.height + size - this.getAxisOffsetValue(axis.plotOffsetTop, axis.plotOffsetBottom, axis.plotOffset);\n          axis.rect.width = 0;\n        }\n        if (axis.isAxisOpposedPosition) {\n          x = rect.x + rect.width + sum(subArray(row.farSizes, farCount));\n          axis.rect.x = axis.rect.x >= x ? axis.rect.x : x;\n          farCount++;\n        } else {\n          x = rect.x - sum(subArray(row.nearSizes, nearCount));\n          axis.rect.x = axis.rect.x <= x ? axis.rect.x : x;\n          nearCount++;\n        }\n      }\n    }\n    this.calculateColumnSize(rect);\n    for (var i = 0, len = chart.columns.length; i < len; i++) {\n      column = chart.columns[i];\n      nearCount = 0;\n      farCount = 0;\n      for (var j = 0, len_3 = column.axes.length; j < len_3; j++) {\n        axis = column.axes[j];\n        axisOffset = axis.plotOffset;\n        if (axis.rect.width === 0) {\n          for (var k = i, len_4 = i + axis.span; k < len_4; k++) {\n            definition = chart.columns[k];\n            axis.rect.width += definition.computedWidth;\n          }\n          axis.rect.x = column.computedLeft + (axis.plotOffsetLeft ? axis.plotOffsetLeft : axisOffset);\n          axis.rect.width -= this.getAxisOffsetValue(axis.plotOffsetLeft, axis.plotOffsetRight, axis.plotOffset);\n          axis.rect.height = 0;\n        }\n        if (axis.isAxisOpposedPosition) {\n          y = rect.y - sum(subArray(column.farSizes, farCount));\n          axis.rect.y = axis.rect.y <= y ? axis.rect.y : y;\n          farCount++;\n        } else {\n          y = rect.y + rect.height + sum(subArray(column.nearSizes, nearCount));\n          axis.rect.y = axis.rect.y >= y ? axis.rect.y : y;\n          nearCount++;\n        }\n      }\n    }\n  };\n  /**\n   * Measure the axis.\n   *\n   * @returns {void}\n   * @private\n   */\n  CartesianAxisLayoutPanel.prototype.measure = function () {\n    var chart = this.chart;\n    var row;\n    var column;\n    var definition;\n    var actualIndex;\n    var span;\n    for (var _i = 0, _a = chart.axisCollections; _i < _a.length; _i++) {\n      var axis = _a[_i];\n      //definition.Axes = axis;\n      if (axis.orientation === 'Vertical') {\n        chart.verticalAxes.push(axis);\n        actualIndex = this.getActualRow(axis);\n        row = chart.rows[actualIndex];\n        this.pushAxis(row, axis);\n        span = actualIndex + axis.span > chart.rows.length ? chart.rows.length : actualIndex + axis.span;\n        for (var j = actualIndex + 1; j < span; j++) {\n          definition = chart.rows[j];\n          definition.axes[row.axes.length - 1] = axis;\n          chart.rows[j] = definition;\n        }\n        chart.rows[actualIndex] = row;\n      } else {\n        chart.horizontalAxes.push(axis);\n        actualIndex = this.getActualColumn(axis);\n        column = chart.columns[actualIndex];\n        this.pushAxis(column, axis);\n        span = actualIndex + axis.span > chart.columns.length ? chart.columns.length : actualIndex + axis.span;\n        for (var j = actualIndex + 1; j < span; j++) {\n          definition = chart.columns[j];\n          definition.axes[column.axes.length - 1] = axis;\n          chart.columns[j] = definition;\n        }\n        chart.columns[actualIndex] = column;\n      }\n      axis.isRTLEnabled = chart.enableRtl;\n      axis.setIsInversedAndOpposedPosition();\n    }\n  };\n  CartesianAxisLayoutPanel.prototype.getAxisOffsetValue = function (position1, position2, plotOffset) {\n    var rangeOffset = position1 ? position1 + (position2 ? position2 : plotOffset) : position2 ? position2 + plotOffset : 2 * plotOffset;\n    return rangeOffset;\n  };\n  CartesianAxisLayoutPanel.prototype.crossAt = function (chart) {\n    for (var _i = 0, _a = chart.axisCollections; _i < _a.length; _i++) {\n      var axis = _a[_i];\n      if (axis.crossesAt === null) {\n        continue;\n      }\n      if (!axis.crossesInAxis) {\n        if (chart.requireInvertedAxis) {\n          axis.crossInAxis = axis.orientation === 'Horizontal' ? chart.primaryXAxis : chart.primaryYAxis;\n        } else {\n          axis.crossInAxis = axis.orientation === 'Horizontal' ? chart.primaryYAxis : chart.primaryXAxis;\n        }\n        axis.crossAt = this.updateCrossAt(axis.crossInAxis, axis.crossesAt);\n        continue;\n      } else {\n        for (var i = 2, len = chart.axisCollections.length; i < len; i++) {\n          if (axis.crossesInAxis === chart.axisCollections[i].name) {\n            axis.crossInAxis = chart.axisCollections[i];\n            axis.crossAt = this.updateCrossAt(axis.crossInAxis, axis.crossesAt);\n            continue;\n          }\n        }\n      }\n    }\n  };\n  CartesianAxisLayoutPanel.prototype.updateCrossAt = function (axis, crossAt) {\n    switch (axis.valueType) {\n      case 'DateTime':\n        var option = {\n          skeleton: 'full',\n          type: 'dateTime'\n        };\n        var dateParser = this.chart.intl.getDateParser(option);\n        var dateFormatter = this.chart.intl.getDateFormat(option);\n        return Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({\n          val: crossAt\n        }).val))));\n      case 'Category':\n        return parseFloat(crossAt) ? parseFloat(crossAt) : axis.labels.indexOf(crossAt);\n      case 'Logarithmic':\n        return logBase(crossAt, axis.logBase);\n      default:\n        return crossAt;\n    }\n  };\n  CartesianAxisLayoutPanel.prototype.pushAxis = function (definition, axis) {\n    for (var i = 0, len = definition.axes.length; i <= len; i++) {\n      if (!definition.axes[i]) {\n        definition.axes[i] = axis;\n        break;\n      }\n    }\n  };\n  CartesianAxisLayoutPanel.prototype.arrangeAxis = function (definition) {\n    var axisCollection = [];\n    for (var i = 0, len = definition.axes.length; i <= len; i++) {\n      if (definition.axes[i]) {\n        axisCollection.push(definition.axes[i]);\n      }\n    }\n    definition.axes = axisCollection;\n  };\n  CartesianAxisLayoutPanel.prototype.getActualColumn = function (axis) {\n    var actualLength = this.chart.columns.length;\n    var pos = axis.columnIndex;\n    var result = pos >= actualLength ? actualLength - 1 : pos < 0 ? 0 : pos;\n    return result;\n  };\n  CartesianAxisLayoutPanel.prototype.getActualRow = function (axis) {\n    var actualLength = this.chart.rows.length;\n    var pos = axis.rowIndex;\n    var result = pos >= actualLength ? actualLength - 1 : pos < 0 ? 0 : pos;\n    return result;\n  };\n  /**\n   * Measure the row size.\n   *\n   * @returns {void}\n   */\n  CartesianAxisLayoutPanel.prototype.calculateRowSize = function (rect) {\n    /*! Calculate row size */\n    var chart = this.chart;\n    var row;\n    var rowTop = rect.y + rect.height;\n    var height = 0;\n    var remainingHeight = Math.max(0, rect.height);\n    for (var i = 0, len = chart.rows.length; i < len; i++) {\n      row = chart.rows[i];\n      if (row.height.indexOf('%') !== -1) {\n        height = Math.min(remainingHeight, rect.height * parseInt(row.height, 10) / 100);\n      } else {\n        height = Math.min(remainingHeight, parseInt(row.height, 10));\n      }\n      height = i !== len - 1 ? height : remainingHeight;\n      row.computedHeight = height;\n      rowTop -= height;\n      row.computedTop = rowTop;\n      remainingHeight -= height;\n    }\n  };\n  /**\n   * Measure the row size.\n   *\n   * @param {Rect} rect rect\n   * @returns {void}\n   */\n  CartesianAxisLayoutPanel.prototype.calculateColumnSize = function (rect) {\n    /*! Calculate column size */\n    var chart = this.chart;\n    var column;\n    var columnLeft = rect.x;\n    var width = 0;\n    var remainingWidth = Math.max(0, rect.width);\n    for (var i = 0, len = chart.columns.length; i < len; i++) {\n      column = chart.columns[i];\n      if (column.width.indexOf('%') !== -1) {\n        width = Math.min(remainingWidth, rect.width * parseInt(column.width, 10) / 100);\n      } else {\n        width = Math.min(remainingWidth, parseInt(column.width, 10));\n      }\n      width = i !== len - 1 ? width : remainingWidth;\n      column.computedWidth = width;\n      column.computedLeft = columnLeft;\n      columnLeft += width;\n      remainingWidth -= width;\n    }\n  };\n  /**\n   * To render the axis element.\n   *\n   * @returns {void}\n   * @private\n   */\n  // tslint:disable-next-line:max-func-body-length\n  CartesianAxisLayoutPanel.prototype.renderAxes = function () {\n    var chart = this.chart;\n    var axis;\n    var axisElement = chart.renderer.createGroup({\n      id: chart.element.id + 'AxisInsideCollection'\n    });\n    var axisLineElement = chart.renderer.createGroup({\n      id: chart.element.id + 'AxisOutsideCollection'\n    });\n    var outsideElement;\n    var isInside;\n    for (var i = 0, len = chart.axisCollections.length; i < len; i++) {\n      var axisVisibility = true;\n      axis = chart.axisCollections[i];\n      this.element = chart.renderer.createGroup({\n        id: chart.element.id + 'AxisGroup' + i + 'Inside'\n      });\n      outsideElement = chart.renderer.createGroup({\n        id: chart.element.id + 'AxisGroup' + i + 'Outside'\n      });\n      for (var _i = 0, _a = this.chart.series; _i < _a.length; _i++) {\n        var series = _a[_i];\n        if (axis.name === series.yAxisName || axis.name === series.xAxisName) {\n          axisVisibility = series.visible;\n          if (axisVisibility) {\n            break;\n          } else {\n            continue;\n          }\n        }\n      }\n      if (!axisVisibility) {\n        break;\n      }\n      isInside = this.findAxisPosition(axis);\n      if (axis.orientation === 'Horizontal') {\n        axis.updateCrossValue();\n        if (axis.visible && axis.internalVisibility && axis.lineStyle.width > 0) {\n          this.drawAxisLine(axis, i, axis.plotOffset, 0, isInside ? outsideElement : this.element, axis.updatedRect);\n        }\n        if (axis.majorGridLines.width > 0 || axis.majorTickLines.width > 0) {\n          this.drawXAxisGridLine(axis, i, isInside || axis.tickPosition === 'Inside' ? outsideElement : this.element, axis.updatedRect);\n        }\n        if (axis.visible && axis.internalVisibility) {\n          this.drawXAxisLabels(axis, i, isInside || axis.labelPosition === 'Inside' ? outsideElement : this.element, axis.placeNextToAxisLine ? axis.updatedRect : axis.rect);\n          this.drawXAxisBorder(axis, i, isInside || axis.labelPosition === 'Inside' ? outsideElement : this.element, axis.placeNextToAxisLine ? axis.updatedRect : axis.rect);\n          this.drawXAxisTitle(axis, i, isInside ? outsideElement : this.element, axis.placeNextToAxisLine ? axis.updatedRect : axis.rect);\n        }\n      } else {\n        axis.updateCrossValue();\n        if (axis.visible && axis.internalVisibility && axis.lineStyle.width > 0) {\n          this.drawAxisLine(axis, i, 0, axis.plotOffset, isInside ? outsideElement : this.element, axis.updatedRect);\n        }\n        if (axis.majorGridLines.width > 0 || axis.majorTickLines.width > 0) {\n          this.drawYAxisGridLine(axis, i, isInside || axis.tickPosition === 'Inside' ? outsideElement : this.element, axis.updatedRect);\n        }\n        if (axis.visible && axis.internalVisibility) {\n          this.drawYAxisLabels(axis, i, isInside || axis.labelPosition === 'Inside' ? outsideElement : this.element, axis.placeNextToAxisLine ? axis.updatedRect : axis.rect);\n          this.drawYAxisBorder(axis, i, isInside || axis.labelPosition === 'Inside' ? outsideElement : this.element, axis.placeNextToAxisLine ? axis.updatedRect : axis.rect);\n          this.drawYAxisTitle(axis, i, isInside ? outsideElement : this.element, axis.placeNextToAxisLine ? axis.updatedRect : axis.rect);\n        }\n      }\n      if (!this.chart.enableCanvas) {\n        axisElement.appendChild(this.element);\n        if (outsideElement && outsideElement.childNodes.length > 0) {\n          axisLineElement.appendChild(outsideElement);\n        }\n      }\n      if (chart.scrollBarModule && (chart.zoomSettings.enableScrollbar && axis.enableScrollbarOnZooming || axis.scrollbarSettings.enable)) {\n        this.renderScrollbar(chart, axis);\n      }\n    }\n    this.element = chart.renderer.createGroup({\n      id: chart.element.id + 'DefinitionLine'\n    });\n    for (var j = 0, len = chart.rows.length; j < len; j++) {\n      var row = chart.rows[j];\n      if (row.border.color) {\n        this.drawBottomLine(row, j, true);\n      }\n    }\n    for (var j = 0, len = chart.columns.length; j < len; j++) {\n      var column = chart.columns[j];\n      if (column.border.color) {\n        this.drawBottomLine(column, j, false);\n      }\n    }\n    if (!this.chart.enableCanvas) {\n      axisElement.appendChild(this.element);\n    }\n    appendChildElement(chart.enableCanvas, chart.svgObject, axisElement, chart.redraw);\n    return axisLineElement;\n  };\n  /**\n   * To render the axis scrollbar\n   *\n   * @param {Chart} chart chart\n   * @param {Axis} axis axis\n   * @returns {void}\n   */\n  CartesianAxisLayoutPanel.prototype.renderScrollbar = function (chart, axis) {\n    var isZoomed = isNullOrUndefined(chart.zoomModule) ? false : chart.zoomModule.isZoomed;\n    if ((isZoomed && (axis.zoomFactor < 1 || axis.zoomPosition > 0) || axis.scrollbarSettings.enable && (axis.zoomFactor <= 1 || axis.zoomPosition >= 0)) && (!axis.zoomingScrollBar.isScrollUI || chart.visibleSeries[0].type.indexOf('Bar') >= 0)) {\n      if (!chart.scrollElement) {\n        chart.scrollElement = redrawElement(chart.redraw, chart.element.id + '_scrollElement') || createElement('div', {\n          id: chart.element.id + '_scrollElement'\n        });\n      }\n      appendChildElement(false, chart.scrollElement, axis.zoomingScrollBar.render(true), true);\n    } else if (axis.zoomFactor === 1 && axis.zoomPosition === 0 && axis.zoomingScrollBar.svgObject && !axis.scrollbarSettings.enable) {\n      axis.zoomingScrollBar.destroy();\n    }\n    if (axis.zoomingScrollBar.isScrollUI) {\n      axis.zoomingScrollBar.isScrollUI = false;\n    }\n  };\n  /**\n   * To find the axis position\n   *\n   * @param {Axis} axis axis\n   * @returns {boolean} axis position\n   */\n  CartesianAxisLayoutPanel.prototype.findAxisPosition = function (axis) {\n    return axis.crossAt !== null && axis.isInside(axis.crossInAxis.visibleRange);\n  };\n  /**\n   * To render the bootom line of the columns and rows\n   *\n   * @param {Row | Column} definition definition\n   * @param {number} index index\n   * @param {boolean} isRow isRow\n   * @returns {void}\n   */\n  CartesianAxisLayoutPanel.prototype.drawBottomLine = function (definition, index, isRow) {\n    var chart = this.chart;\n    var optionsLine = {};\n    var x1;\n    var x2;\n    var y1;\n    var y2;\n    var definitionName;\n    if (isRow) {\n      definition = definition;\n      y1 = y2 = definition.computedTop + definition.computedHeight;\n      x1 = this.seriesClipRect.x;\n      x2 = x1 + this.seriesClipRect.width;\n      definitionName = 'Row';\n    } else {\n      definition = definition;\n      x1 = x2 = definition.computedLeft;\n      y1 = this.seriesClipRect.y;\n      y2 = y1 + this.seriesClipRect.height;\n      definitionName = 'Column';\n    }\n    optionsLine = {\n      'id': chart.element.id + '_AxisBottom_' + definitionName + index,\n      x1: x1,\n      y1: y1,\n      x2: x2,\n      y2: y2,\n      'stroke-width': definition.border.width,\n      'stroke': definition.border.color\n    };\n    this.htmlObject = chart.renderer.drawLine(optionsLine);\n    this.element.appendChild(this.htmlObject);\n  };\n  /**\n   * To render the axis line\n   *\n   * @param {Axis} axis axis\n   * @param {number} index index\n   * @param {number} plotX plotX\n   * @param {number} plotY plotY\n   * @param {Element} parent parent\n   * @param {Rect} rect rect\n   * @returns {void}\n   */\n  CartesianAxisLayoutPanel.prototype.drawAxisLine = function (axis, index, plotX, plotY, parent, rect) {\n    var chart = this.chart;\n    var optionsLine = {};\n    var element = getElement(chart.element.id + 'AxisLine_' + index);\n    var direction = element ? element.getAttribute('d') : '';\n    element = null;\n    optionsLine = {\n      'id': chart.element.id + 'AxisLine_' + index,\n      'd': 'M ' + (rect.x - plotX) + ' ' + (rect.y - plotY) + ' L ' + (rect.x + rect.width + plotX) + ' ' + (rect.y + rect.height + plotY),\n      'stroke-dasharray': axis.lineStyle.dashArray,\n      'stroke-width': axis.lineStyle.width,\n      'stroke': axis.lineStyle.color || chart.themeStyle.axisLine\n    };\n    this.htmlObject = chart.renderer.drawPath(optionsLine);\n    appendChildElement(chart.enableCanvas, parent, this.htmlObject, chart.redraw, true, 'x', 'y', null, direction);\n  };\n  /**\n   * To render the yAxis grid line\n   *\n   * @param {Axis} axis axis\n   * @param {number} index index\n   * @param {Element} parent parent\n   * @param {Rect} rect rect\n   * @returns {void}\n   */\n  CartesianAxisLayoutPanel.prototype.drawYAxisGridLine = function (axis, index, parent, rect) {\n    var isLogAxis = axis.valueType === 'Logarithmic';\n    var isCategoryAxis = axis.valueType.indexOf('Category') > -1;\n    var tempInterval;\n    var pointY = 0;\n    var majorGrid = '';\n    var majorTick = '';\n    var minorGridDirection;\n    var isOpposed = axis.isAxisOpposedPosition;\n    var tickSize = isOpposed ? axis.majorTickLines.height : -axis.majorTickLines.height;\n    var axisLineSize = isOpposed ? axis.lineStyle.width * 0.5 : -axis.lineStyle.width * 0.5;\n    var ticksbwtLabel = axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks' ? 0.5 : 0;\n    var scrollBarHeight = isNullOrUndefined(axis.crossesAt) ? isOpposed ? axis.scrollBarHeight : -axis.scrollBarHeight : 0;\n    var isTickInside = axis.tickPosition === 'Inside';\n    var ticks = isTickInside ? rect.x - tickSize - axisLineSize : rect.x + tickSize + axisLineSize + scrollBarHeight;\n    var length = axis.visibleLabels.length;\n    var chartThemeStyle = this.chart.themeStyle;\n    if (axis.valueType.indexOf('Category') > -1 && axis.labelPlacement === 'BetweenTicks' && length > 0) {\n      length += 1;\n    }\n    var minorGridLines = axis.minorGridLines;\n    var minorTickLines = axis.minorTickLines;\n    //Gridlines\n    for (var i = 0; i < length; i++) {\n      tempInterval = !axis.visibleLabels[i] ? axis.visibleLabels[i - 1].value + axis.visibleRange.interval - ticksbwtLabel : axis.visibleLabels[i].value - ticksbwtLabel;\n      pointY = valueToCoefficient(tempInterval, axis) * rect.height;\n      pointY = pointY * -1 + (rect.y + rect.height);\n      if (pointY >= rect.y && rect.y + rect.height >= pointY) {\n        if (inside(tempInterval, axis.visibleRange) || this.isBorder(axis, i, pointY)) {\n          majorGrid = 'M ' + this.seriesClipRect.x + ' ' + pointY + ' L ' + (this.seriesClipRect.x + this.seriesClipRect.width) + ' ' + pointY;\n          this.renderGridLine(axis, index, majorGrid, axis.majorGridLines, '_MajorGridLine_', i, this.element, chartThemeStyle.majorGridLine, axis.majorGridLines.dashArray);\n        }\n        majorTick = 'M ' + (rect.x + axisLineSize + (isTickInside ? scrollBarHeight : 0)) + ' ' + pointY + ' L ' + ticks + ' ' + pointY;\n        this.renderGridLine(axis, index, majorTick, axis.majorTickLines, '_MajorTickLine_', i, parent, chartThemeStyle.majorTickLine);\n        if ((minorGridLines.width > 0 || minorTickLines.width > 0) && axis.minorTicksPerInterval > 0) {\n          if (i === 0 && isZoomSet(axis) && !isLogAxis && !isCategoryAxis) {\n            this.renderMinorGridOnZooming(axis, tempInterval, rect, i, index, chartThemeStyle, parent);\n          }\n          minorGridDirection = this.drawAxisMinorLine(axis, tempInterval, rect, i);\n          this.renderGridLine(axis, index, minorGridDirection[0], minorGridLines, '_MinorGridLine_', i, this.element, chartThemeStyle.minorGridLine, minorGridLines.dashArray);\n          this.renderGridLine(axis, index, minorGridDirection[1], minorTickLines, '_MinorTickLine_', i, parent, chartThemeStyle.minorTickLine);\n          if (i === length - 1 && isZoomSet(axis) && isLogAxis && !isCategoryAxis) {\n            this.renderMinorGridOnZooming(axis, tempInterval + axis.visibleRange.interval, rect, i, index, chartThemeStyle, parent);\n          }\n        }\n      }\n    }\n  };\n  /**\n   * To check the border of the axis\n   *\n   * @param {Axis} axis axis\n   * @param {number} index index\n   * @param {number} value value\n   * @returns {boolean} check the border of the axis\n   */\n  CartesianAxisLayoutPanel.prototype.isBorder = function (axis, index, value) {\n    var border = this.chart.chartArea.border;\n    var rect = this.seriesClipRect;\n    var orientation = axis.orientation;\n    var start = orientation === 'Horizontal' ? rect.x : rect.y;\n    var size = orientation === 'Horizontal' ? rect.width : rect.height;\n    var startIndex = orientation === 'Horizontal' ? 0 : axis.visibleLabels.length - 1;\n    var endIndex = orientation === 'Horizontal' ? axis.visibleLabels.length - 1 : 0;\n    if (axis.plotOffset > 0) {\n      return true;\n    } else if ((value === start || value === start + size) && (border.width <= 0 || border.color === 'transparent')) {\n      return true;\n    } else if (value !== start && index === startIndex || value !== start + size && index === endIndex) {\n      return true;\n    }\n    return false;\n  };\n  /**\n   * To render the yAxis label\n   *\n   * @param {Axis} axis axis\n   * @param {number} index index\n   * @param {Element} parent parent\n   * @param {Rect} rect rect\n   * @returns {void}\n   * @private\n   */\n  CartesianAxisLayoutPanel.prototype.drawYAxisLabels = function (axis, index, parent, rect) {\n    var chart = this.chart;\n    var label;\n    var pointX = 0;\n    var pointY = 0;\n    var elementSize;\n    var labelSpace = axis.labelPadding;\n    var options;\n    var isAxisBreakLabel;\n    var isLabelInside = axis.labelPosition === 'Inside';\n    var isOpposed = axis.isAxisOpposedPosition;\n    var tickSpace = axis.labelPosition === axis.tickPosition ? axis.majorTickLines.height : 0;\n    var padding = tickSpace + labelSpace + axis.lineStyle.width * 0.5;\n    var angle = axis.angle % 360;\n    padding = isOpposed ? padding : -padding;\n    var labelElement = chart.renderer.createGroup({\n      id: chart.element.id + 'AxisLabels' + index\n    });\n    var scrollBarHeight = isNullOrUndefined(axis.crossesAt) ? axis.scrollBarHeight * (isOpposed ? 1 : -1) : 0;\n    var textHeight;\n    var textPadding;\n    var maxLineWidth;\n    var pixel = 10;\n    var isInverse = axis.isAxisInverse;\n    var previousEnd = isInverse ? rect.y : rect.y + rect.height;\n    var labelPadding;\n    var intervalLength;\n    var labelHeight;\n    var yAxisLabelX;\n    var isLabelOnAxisLineLeft = !isOpposed && !isLabelInside || isOpposed && isLabelInside;\n    if (isLabelInside) {\n      labelPadding = !isLabelOnAxisLineLeft ? -padding : padding;\n    } else {\n      labelPadding = !isLabelOnAxisLineLeft ? -padding + scrollBarHeight : padding + scrollBarHeight;\n    }\n    var sizeWidth = [];\n    var breakLabelSizeWidth = [];\n    axis.visibleLabels.map(function (item) {\n      sizeWidth.push(item.size['width']);\n      breakLabelSizeWidth.push(item.breakLabelSize['width']);\n    });\n    var LabelMaxWidth = Math.max.apply(Math, sizeWidth);\n    var breakLabelMaxWidth = Math.max.apply(Math, breakLabelSizeWidth);\n    for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {\n      label = axis.visibleLabels[i];\n      isAxisBreakLabel = isBreakLabel(axis.visibleLabels[i].originalText);\n      elementSize = isAxisBreakLabel ? axis.visibleLabels[i].breakLabelSize : axis.visibleLabels[i].size;\n      pointY = valueToCoefficient(axis.visibleLabels[i].value, axis) * rect.height + (chart.stockChart ? 7 : 0);\n      pointY = Math.floor(pointY * -1 + (rect.y + rect.height));\n      textHeight = elementSize.height / 8 * axis.visibleLabels[i].text.length / 2;\n      textPadding = elementSize.height / 4 * 3 + 3;\n      intervalLength = rect.height / axis.visibleLabels.length;\n      labelHeight = (axis.labelIntersectAction === 'Trim' || axis.labelIntersectAction === 'Wrap') && angle !== 0 && elementSize.width > intervalLength ? intervalLength : elementSize.width;\n      pointY = isAxisBreakLabel ? axis.labelPosition === 'Inside' ? pointY - elementSize.height / 2 - textHeight + textPadding : pointY - textHeight : axis.labelPosition === 'Inside' ? pointY + textPadding : pointY;\n      if (axis.majorGridLines.width > axis.majorTickLines.width) {\n        maxLineWidth = axis.majorGridLines.width;\n      } else {\n        maxLineWidth = axis.majorTickLines.width;\n      }\n      if (axis.labelStyle.textAlignment === 'Far') {\n        pointY = pointY - maxLineWidth - pixel;\n      } else if (axis.labelStyle.textAlignment === 'Near') {\n        pointY = pointY + maxLineWidth + pixel;\n      } else if (axis.labelStyle.textAlignment === 'Center') {\n        // eslint-disable-next-line no-self-assign\n        pointY = pointY;\n      }\n      // label X value adjustment (Start)\n      if (isLabelInside) {\n        yAxisLabelX = labelPadding + (angle === 0 ? elementSize.width : isAxisBreakLabel ? breakLabelMaxWidth : LabelMaxWidth) / 2;\n      } else {\n        yAxisLabelX = labelPadding - (angle === 0 ? elementSize.width : isAxisBreakLabel ? breakLabelMaxWidth : LabelMaxWidth) / 2;\n      }\n      pointX = isOpposed ? rect.x - yAxisLabelX : rect.x + yAxisLabelX;\n      yAxisLabelX = labelPadding;\n      options = new TextOption(chart.element.id + index + '_AxisLabel_' + i, pointX, pointY, 'middle', label.text, '', 'middle');\n      switch (axis.edgeLabelPlacement) {\n        case 'None':\n          break;\n        case 'Hide':\n          if ((i === 0 || isInverse && i === len - 1) && options.y > rect.y || (i === len - 1 || isInverse && i === 0) && options.y - elementSize.height * 0.5 < rect.y) {\n            options.text = '';\n          }\n          break;\n        case 'Shift':\n          if ((i === 0 || isInverse && i === len - 1) && options.y > rect.y) {\n            options.y = pointY = rect.y + rect.height;\n          } else if ((i === len - 1 || isInverse && i === 0) && options.y - elementSize.height * 0.5 < rect.y) {\n            options.y = pointY = rect.y + elementSize.height * 0.5;\n          }\n          break;\n      }\n      // ------- Hide Calculation (Start) -------------\n      var previousYValue = options.y;\n      var currentYValue = options.y - labelHeight;\n      if (isAxisBreakLabel) {\n        previousYValue = options.y - labelHeight / 2;\n        currentYValue = options.y + labelHeight / 2;\n      }\n      if ((angle === 90 || angle === 270) && axis.labelIntersectAction === 'Hide' && i !== 0 && (!isInverse ? previousYValue >= previousEnd : currentYValue <= previousEnd)) {\n        continue;\n      }\n      previousEnd = isInverse ? previousYValue : currentYValue;\n      // ------- Hide Calculation (End) -------------\n      options.transform = 'rotate(' + angle + ',' + pointX + ',' + pointY + ')';\n      textElement(chart.renderer, options, label.labelStyle, label.labelStyle.color || chart.themeStyle.axisLabel, labelElement, false, chart.redraw, true, true, null, null, null, null, chart.enableCanvas);\n    }\n    if (!this.chart.enableCanvas) {\n      if (!chart.delayRedraw) {\n        appendChildElement(chart.enableCanvas, parent, labelElement, chart.redraw);\n      } else if (axis.visible && axis.internalVisibility) {\n        this.createZoomingLabel(this.chart, labelElement, axis, index, rect);\n      }\n    }\n  };\n  /**\n   * To get X value based on lineBreakAlignment for Y axis line break labels only.\n   *\n   * @param {number} x text x position\n   * @param {Axis} axis y axis values\n   * @param {number} textWidth axis label width\n   * @returns {number} returns suitable axis label x position\n   */\n  CartesianAxisLayoutPanel.prototype.getAxisLabelXvalue = function (x, axis, textWidth) {\n    var anchor = axis.lineBreakAlignment;\n    var isLabelInside = axis.labelPosition === 'Inside';\n    var isOpposed = axis.isAxisOpposedPosition;\n    if (isOpposed && isLabelInside || !isOpposed && !isLabelInside) {\n      return anchor === 'Right' ? x : anchor === 'Center' ? x - textWidth / 2 : x - textWidth;\n    } else {\n      return anchor === 'Left' ? x : anchor === 'Center' ? x + textWidth / 2 : x + textWidth;\n    }\n  };\n  /**\n   * To render the yAxis label border.\n   *\n   * @param {Axis} axis axis\n   * @param {number} index index\n   * @param {Element} parent parent\n   * @param {Rect} rect rect\n   * @returns {void}\n   */\n  CartesianAxisLayoutPanel.prototype.drawYAxisBorder = function (axis, index, parent, rect) {\n    if (axis.border.width > 0) {\n      var startY = void 0;\n      var pointY = void 0;\n      var scrollBarHeight = axis.labelPosition === 'Outside' ? axis.scrollBarHeight : 0;\n      var isOpposed = axis.isAxisOpposedPosition;\n      scrollBarHeight = (isOpposed ? 1 : -1) * scrollBarHeight;\n      var gap = rect.height / axis.visibleRange.delta * (axis.valueType === 'DateTime' ? axis.dateTimeInterval : axis.visibleRange.interval);\n      var endY = void 0;\n      var length_1 = axis.maxLabelSize.width + 10 + (axis.tickPosition === axis.labelPosition ? axis.majorTickLines.height : 0);\n      var labelBorder = '';\n      var ticksbwtLabel = axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks' ? -0.5 : 0;\n      var endX = isOpposed && axis.labelPosition === 'Inside' || !isOpposed && axis.labelPosition === 'Outside' ? rect.x - length_1 + scrollBarHeight : rect.x + length_1 + scrollBarHeight;\n      for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {\n        pointY = valueToCoefficient(axis.visibleLabels[i].value + ticksbwtLabel, axis);\n        pointY = (axis.isAxisInverse ? 1 - pointY : pointY) * rect.height;\n        if (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') {\n          startY = pointY * -1 + (rect.y + rect.height);\n          endY = pointY * -1 - gap + (rect.y + rect.height);\n        } else {\n          startY = pointY * -1 + gap / 2 + (rect.y + rect.height);\n          endY = pointY * -1 - gap / 2 + (rect.y + rect.height);\n        }\n        switch (axis.border.type) {\n          case 'Rectangle':\n          case 'WithoutTopBorder':\n            if (startY > rect.y + rect.height) {\n              labelBorder += 'M' + ' ' + endX + ' ' + (rect.y + rect.height) + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ';\n            } else if (Math.floor(rect.y) > endY) {\n              labelBorder += 'M' + ' ' + (rect.x + scrollBarHeight) + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + rect.y + ' ';\n            } else {\n              labelBorder += 'M' + ' ' + (rect.x + scrollBarHeight) + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ';\n              if (i === axis.visibleLabels.length - 1) {\n                labelBorder += 'M' + ' ' + (rect.x + scrollBarHeight) + ' ' + endY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ';\n              }\n            }\n            break;\n          case 'WithoutTopandBottomBorder':\n            if (!(startY > rect.y + rect.height) && !(endY < Math.floor(rect.y))) {\n              labelBorder += 'M' + ' ' + (rect.x + scrollBarHeight) + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + startY + ' ' + 'M' + ' ' + endX + ' ' + endY + ' ' + 'L' + ' ' + (rect.x + scrollBarHeight) + ' ' + endY;\n            }\n            break;\n        }\n      }\n      labelBorder += axis.border.type === 'Rectangle' ? 'M' + ' ' + (rect.x + scrollBarHeight) + ' ' + rect.y + ' ' + 'L' + ' ' + (rect.x + scrollBarHeight) + ' ' + (rect.y + rect.height) + ' ' : '';\n      if (labelBorder !== '') {\n        this.createAxisBorderElement(axis, index, labelBorder, parent);\n      }\n    }\n    if (axis.multiLevelLabels.length > 0 && this.chart.multiLevelLabelModule) {\n      this.chart.multiLevelLabelModule.renderYAxisMultiLevelLabels(axis, index, parent, rect);\n    }\n  };\n  /**\n   * To render the yAxis title\n   *\n   * @param {Axis} axis axis\n   * @param {number} index index\n   * @param {Element} parent parent\n   * @param {Rect} rect rect\n   * @returns {void}\n   */\n  CartesianAxisLayoutPanel.prototype.drawYAxisTitle = function (axis, index, parent, rect) {\n    if (axis.title) {\n      var chart = this.chart;\n      var isOpposed = axis.isAxisOpposedPosition;\n      var labelRotation = isOpposed ? 90 : -90;\n      var padding = (axis.tickPosition === 'Inside' ? 0 : axis.majorTickLines.height + axis.titlePadding) + (axis.labelPosition === 'Inside' ? 0 : axis.maxLabelSize.width + axis.multiLevelLabelHeight + this.padding);\n      padding = isOpposed ? padding + axis.scrollBarHeight : -padding - axis.scrollBarHeight;\n      var x = rect.x + padding;\n      var y = rect.y + rect.height * 0.5;\n      var titleSize = axis.titleSize.height * (axis.titleCollection.length - 1);\n      var options = new TextOption(chart.element.id + '_AxisTitle_' + index, x, y - axis.labelPadding - titleSize, 'middle', axis.titleCollection, 'rotate(' + labelRotation + ',' + x + ',' + y + ')', null, labelRotation);\n      var element = textElement(chart.renderer, options, axis.titleStyle, axis.titleStyle.color || chart.themeStyle.axisTitle, parent, null, null, null, null, null, null, null, null, chart.enableCanvas);\n      element.setAttribute('tabindex', axis.tabIndex.toString());\n      element.setAttribute('aria-label', axis.description || axis.title);\n    }\n  };\n  /**\n   * xAxis grid line calculation performed here\n   *\n   * @param {Axis} axis axis\n   * @param {number} index index\n   * @param {Element} parent parent\n   * @param {Rect} rect rect\n   * @returns {void}\n   */\n  CartesianAxisLayoutPanel.prototype.drawXAxisGridLine = function (axis, index, parent, rect) {\n    var isLogAxis = axis.valueType === 'Logarithmic';\n    var isCategoryAxis = axis.valueType.indexOf('Category') > -1;\n    var tempInterval;\n    var pointX = 0;\n    var majorGrid = '';\n    var majorTick = '';\n    var minorDirection;\n    var isOpposed = axis.isAxisOpposedPosition;\n    var tickSize = isOpposed ? -axis.majorTickLines.height : axis.majorTickLines.height;\n    var axisLineSize = isOpposed ? -axis.lineStyle.width * 0.5 : axis.lineStyle.width * 0.5;\n    var scrollBarHeight = isNullOrUndefined(axis.crossesAt) ? isOpposed ? -axis.scrollBarHeight : axis.scrollBarHeight : 0;\n    var ticksbwtLabel = axis.valueType.indexOf('Category') > -1 && axis.labelPlacement === 'BetweenTicks' ? 0.5 : 0;\n    var length = axis.visibleLabels.length;\n    var isTickInside = axis.tickPosition === 'Inside';\n    var ticks = isTickInside ? rect.y - tickSize - axisLineSize : rect.y + tickSize + axisLineSize + scrollBarHeight;\n    var chartThemeStyle = this.chart.themeStyle;\n    if (axis.valueType.indexOf('Category') > -1 && length > 0 && axis.labelPlacement === 'BetweenTicks') {\n      length += 1;\n    }\n    //Gridlines\n    for (var i = 0; i < length; i++) {\n      if (axis.valueType !== 'DateTimeCategory') {\n        tempInterval = axis.visibleLabels[i] ? axis.visibleLabels[i].value - ticksbwtLabel : axis.visibleLabels[i - 1].value + axis.visibleRange.interval - ticksbwtLabel;\n      } else {\n        tempInterval = axis.visibleLabels[i] ? axis.visibleLabels[i].value - ticksbwtLabel : axis.visibleRange.max;\n      }\n      pointX = valueToCoefficient(tempInterval, axis) * rect.width + rect.x;\n      if (pointX >= rect.x && rect.x + rect.width >= pointX) {\n        if (inside(tempInterval, axis.visibleRange) || this.isBorder(axis, i, pointX)) {\n          majorGrid = 'M ' + pointX + ' ' + (this.seriesClipRect.y + this.seriesClipRect.height) + ' L ' + pointX + ' ' + this.seriesClipRect.y;\n          this.renderGridLine(axis, index, majorGrid, axis.majorGridLines, '_MajorGridLine_', i, this.element, chartThemeStyle.majorGridLine, axis.majorGridLines.dashArray);\n        }\n        majorTick = 'M ' + pointX + ' ' + (rect.y + axisLineSize + (isTickInside ? scrollBarHeight : 0)) + ' L ' + pointX + ' ' + ticks;\n        this.renderGridLine(axis, index, majorTick, axis.majorTickLines, '_MajorTickLine_', i, parent, chartThemeStyle.majorTickLine);\n        if (axis.minorTicksPerInterval > 0 && (axis.minorGridLines.width > 0 || axis.minorTickLines.width > 0)) {\n          if (i === 0 && isZoomSet(axis) && !isLogAxis && !isCategoryAxis) {\n            this.renderMinorGridOnZooming(axis, tempInterval, rect, i, index, chartThemeStyle, parent);\n          }\n          minorDirection = this.drawAxisMinorLine(axis, tempInterval, rect, i);\n          this.renderGridLine(axis, index, minorDirection[0], axis.minorGridLines, '_MinorGridLine_', i, this.element, chartThemeStyle.minorGridLine, axis.minorGridLines.dashArray);\n          this.renderGridLine(axis, index, minorDirection[1], axis.minorTickLines, '_MinorTickLine_', i, parent, chartThemeStyle.minorTickLine);\n          if (i === length - 1 && isZoomSet(axis) && isLogAxis && !isCategoryAxis) {\n            this.renderMinorGridOnZooming(axis, tempInterval + axis.visibleRange.interval, rect, i, index, chartThemeStyle, parent);\n          }\n        }\n      }\n    }\n  };\n  /**\n   * To render missing minor grid lines while zooming\n   *\n   * @param {Axis} axis axis\n   * @param {number} tempInterval tempInterval\n   * @param {Rect} rect rect\n   * @param {number} i i\n   * @param {number} index index\n   * @param {IThemeStyle} chartThemeStyle chartThemeStyle\n   * @param {Element} parent parent\n   * @returns {void}\n   */\n  CartesianAxisLayoutPanel.prototype.renderMinorGridOnZooming = function (axis, tempInterval, rect, i, index, chartThemeStyle, parent) {\n    var minorDirection = this.drawAxisMinorLine(axis, tempInterval, rect, i, true);\n    this.renderGridLine(axis, index, minorDirection[0], axis.minorGridLines, '_MinorGridLine_', -1, this.element, chartThemeStyle.minorGridLine, axis.minorGridLines.dashArray);\n    this.renderGridLine(axis, index, minorDirection[1], axis.minorTickLines, '_MinorTickLine_', -1, parent, chartThemeStyle.minorTickLine);\n  };\n  /**\n   * To calcualte the axis minor line\n   *\n   * @param {Axis} axis axis\n   * @param {number} tempInterval tempInterval\n   * @param {Rect} rect rect\n   * @param {number} labelIndex labelIndex\n   * @param {boolean} isFirstLabel isFirstLabel\n   * @returns {string[]} axis minor line path\n   */\n  CartesianAxisLayoutPanel.prototype.drawAxisMinorLine = function (axis, tempInterval, rect, labelIndex, isFirstLabel) {\n    var value = tempInterval;\n    var coor = 0;\n    var position = 0;\n    var range = axis.visibleRange;\n    var isTickInside = axis.tickPosition === 'Inside';\n    var direction = [];\n    var tickSize = axis.isAxisOpposedPosition ? -axis.minorTickLines.height : axis.minorTickLines.height;\n    var logStart;\n    var logEnd;\n    var logInterval = 1;\n    var logPosition = 1;\n    var ticksX = isTickInside ? rect.y - tickSize : rect.y + tickSize;\n    var ticksY = isTickInside ? rect.x + tickSize : rect.x - tickSize;\n    var minorGird = '';\n    var minorTick = '';\n    var isInverse = axis.isAxisInverse;\n    if (axis.valueType === 'Logarithmic') {\n      logStart = Math.pow(axis.logBase, value - range.interval);\n      logEnd = Math.pow(axis.logBase, value);\n      logInterval = (logEnd - logStart) / (axis.minorTicksPerInterval + 1);\n      logPosition = logStart + logInterval;\n    }\n    if (axis.orientation === 'Horizontal') {\n      for (var j = 0; j < axis.minorTicksPerInterval; j++) {\n        value = this.findLogNumeric(axis, logPosition, value, labelIndex, isFirstLabel);\n        logPosition += logInterval;\n        if (inside(value, range)) {\n          position = (value - range.min) / (range.max - range.min);\n          position = Math.ceil((isInverse ? 1 - position : position) * rect.width);\n          coor = Math.floor(position + rect.x);\n          minorGird = minorGird.concat('M' + ' ' + coor + ' ' + this.seriesClipRect.y + 'L ' + coor + ' ' + (this.seriesClipRect.y + this.seriesClipRect.height));\n          coor = Math.floor(position + rect.x);\n          minorTick = minorTick.concat('M' + ' ' + coor + ' ' + rect.y + 'L ' + coor + ' ' + (ticksX + axis.scrollBarHeight));\n        }\n      }\n    } else {\n      for (var j = 0; j < axis.minorTicksPerInterval; j++) {\n        value = this.findLogNumeric(axis, logPosition, value, labelIndex, isFirstLabel);\n        if (inside(value, range)) {\n          position = (value - range.min) / (range.max - range.min);\n          position = Math.ceil((isInverse ? 1 - position : position) * rect.height) * -1; // For inversed axis\n          coor = Math.floor(position + rect.y + rect.height);\n          minorGird = minorGird.concat('M' + ' ' + this.seriesClipRect.x + ' ' + coor + 'L ' + (this.seriesClipRect.x + this.seriesClipRect.width) + ' ' + coor + ' ');\n          coor = Math.floor(position + rect.y + rect.height);\n          minorTick = minorTick.concat('M' + ' ' + rect.x + ' ' + coor + 'L ' + (ticksY - axis.scrollBarHeight) + ' ' + coor + ' ');\n        }\n        logPosition += logInterval;\n      }\n    }\n    direction.push(minorGird);\n    direction.push(minorTick);\n    return direction;\n  };\n  /**\n   * To find the numeric value of the log\n   *\n   * @param {Axis} axis axis\n   * @param {number} logPosition logPosition\n   * @param {number} value value\n   * @param {number} labelIndex labelIndex\n   * @param {boolean} isFirstLabel isFirstLabel\n   * @returns {number} value\n   */\n  CartesianAxisLayoutPanel.prototype.findLogNumeric = function (axis, logPosition, value, labelIndex, isFirstLabel) {\n    var range = axis.visibleRange;\n    var tempValue;\n    if (axis.valueType === 'Logarithmic') {\n      value = logBase(logPosition, axis.logBase);\n    } else if (axis.valueType === 'DateTime') {\n      tempValue = axis.dateTimeInterval / (axis.minorTicksPerInterval + 1);\n      value = isFirstLabel ? value - tempValue : value + tempValue;\n    } else if (axis.valueType === 'DateTimeCategory') {\n      var padding = axis.labelPlacement === 'BetweenTicks' ? 0.5 : 0;\n      value += ((axis.visibleLabels[labelIndex + 1] ? axis.visibleLabels[labelIndex + 1].value - padding : axis.visibleRange.max) - (axis.visibleLabels[labelIndex] ? axis.visibleLabels[labelIndex].value - padding : axis.visibleRange.min)) / (axis.minorTicksPerInterval + 1);\n    } else {\n      tempValue = range.interval / (axis.minorTicksPerInterval + 1);\n      value = isFirstLabel ? value - tempValue : value + tempValue;\n    }\n    return value;\n  };\n  /**\n   * To render the xAxis Labels\n   *\n   * @param {Axis} axis axis\n   * @param {number} index index\n   * @param {Element} parent parent\n   * @param {Rect} rect rect\n   * @returns {void}\n   * @private\n   */\n  CartesianAxisLayoutPanel.prototype.drawXAxisLabels = function (axis, index, parent, rect) {\n    var chart = this.chart;\n    var pointX = 0;\n    var pointY = 0;\n    var labelSpace = axis.labelPadding;\n    var labelHeight;\n    var elementSize;\n    var labelPadding;\n    var anchor;\n    var pixel = 10;\n    var labelElement = chart.renderer.createGroup({\n      id: chart.element.id + 'AxisLabels' + index\n    });\n    var islabelInside = axis.labelPosition === 'Inside';\n    var isOpposed = axis.isAxisOpposedPosition;\n    var tickSpace = axis.labelPosition === axis.tickPosition ? axis.majorTickLines.height : 0;\n    var padding = tickSpace + labelSpace + axis.lineStyle.width * 0.5;\n    var angle = axis.angle % 360;\n    var isHorizontalAngle = angle === 0 || angle === -180 || angle === 180;\n    var options;\n    var labelWidth;\n    var isInverse = axis.isAxisInverse;\n    var previousEnd = isInverse ? rect.x + rect.width : rect.x;\n    var width = 0;\n    var length = axis.visibleLabels.length;\n    var intervalLength;\n    var label;\n    var isAxisBreakLabel;\n    var scrollBarHeight = axis.scrollbarSettings.enable || !islabelInside && isNullOrUndefined(axis.crossesAt) && (axis.zoomFactor < 1 || axis.zoomPosition > 0) ? axis.scrollBarHeight : 0;\n    var newPoints = [];\n    var isRotatedLabelIntersect = false;\n    padding += angle === 90 || angle === 270 || angle === -90 || angle === -270 ? islabelInside ? 5 : -5 : 0;\n    var isLabelUnderAxisLine = !isOpposed && !islabelInside || isOpposed && islabelInside;\n    var isEndAnchor = isLabelUnderAxisLine ? 360 >= angle && angle >= 180 || -1 >= angle && angle >= -180 : 1 <= angle && angle <= 180 || -181 >= angle && angle >= -360;\n    for (var i = 0, len = length; i < len; i++) {\n      label = axis.visibleLabels[i];\n      isAxisBreakLabel = isBreakLabel(label.originalText);\n      pointX = valueToCoefficient(label.value, axis) * rect.width + rect.x;\n      elementSize = label.size;\n      intervalLength = rect.width / length;\n      labelWidth = isAxisBreakLabel ? label.breakLabelSize.width : elementSize.width;\n      width = (axis.labelIntersectAction === 'Trim' || axis.labelIntersectAction === 'Wrap') && angle === 0 && labelWidth > intervalLength ? intervalLength : labelWidth;\n      labelHeight = elementSize.height / 4;\n      pointX -= isAxisBreakLabel || angle !== 0 ? 0 : width / 2;\n      // label X value adjustment for label rotation (Start)\n      if (angle !== 0) {\n        if (isAxisBreakLabel) {\n          pointX -= axis.lineBreakAlignment === 'Left' ? label.breakLabelSize.width / 2 : axis.lineBreakAlignment === 'Right' ? -(label.breakLabelSize.width / 2) : 0;\n        } else {\n          pointX -= angle === -90 || angle === 270 ? -labelHeight : angle === 90 || angle === -270 ? labelHeight : 0;\n        }\n      }\n      // label X value adjustment for label rotation (End)\n      if (axis.labelStyle.textAlignment === 'Far') {\n        pointX = pointX + width - pixel;\n      } else if (axis.labelStyle.textAlignment === 'Near') {\n        pointX = pointX - width + pixel;\n      } else if (axis.labelStyle.textAlignment === 'Center') {\n        // eslint-disable-next-line no-self-assign\n        pointX = pointX;\n      }\n      // For line break label alignment like left, right & center in angle 0\n      if (isAxisBreakLabel && axis.lineBreakAlignment !== 'Center' && angle === 0) {\n        pointX += axis.lineBreakAlignment === 'Left' ? -(width / 2) : width / 2;\n      }\n      var paddingForBreakLabel = isAxisBreakLabel ? isHorizontalAngle ? elementSize.height : label.breakLabelSize.width / 2 : 0;\n      padding = isAxisBreakLabel ? tickSpace + labelSpace + axis.lineStyle.width * 0.5 : padding;\n      // label Y value adjustment (Start)\n      if (islabelInside && angle) {\n        if (isAxisBreakLabel) {\n          pointY = isOpposed ? rect.y + padding + paddingForBreakLabel : rect.y - padding - paddingForBreakLabel;\n        } else {\n          pointY = isOpposed ? rect.y + padding + labelHeight : rect.y - padding - labelHeight;\n        }\n      } else {\n        if (isAxisBreakLabel) {\n          labelPadding = !isLabelUnderAxisLine ? -(padding + scrollBarHeight + paddingForBreakLabel) : padding + scrollBarHeight + (angle ? paddingForBreakLabel : 3 * labelHeight);\n        } else {\n          labelPadding = !isLabelUnderAxisLine ? -(padding + scrollBarHeight + (angle ? labelHeight : label.index > 1 ? 2 * labelHeight : 0)) : padding + scrollBarHeight + (angle ? 1 : 3) * labelHeight;\n        }\n        pointY = rect.y + labelPadding * label.index;\n      }\n      // label Y value adjustment (End)\n      if (isAxisBreakLabel) {\n        anchor = this.getAnchor(axis); // for break label self alignment\n      } else {\n        anchor = chart.enableRtl ? isEndAnchor ? '' : 'end' : chart.isRtlEnabled || isEndAnchor ? 'end' : '';\n      }\n      options = new TextOption(chart.element.id + index + '_AxisLabel_' + i, pointX, pointY, anchor);\n      if (axis.edgeLabelPlacement && angle === 0) {\n        switch (axis.edgeLabelPlacement) {\n          case 'None':\n            break;\n          case 'Hide':\n            if ((i === 0 || isInverse && i === len - 1) && options.x < rect.x || (i === len - 1 || isInverse && i === 0) && options.x + width > rect.x + rect.width) {\n              continue;\n            }\n            break;\n          case 'Shift':\n            if ((i === 0 || isInverse && i === len - 1) && options.x < rect.x) {\n              intervalLength -= rect.x - options.x;\n              options.x = pointX = rect.x;\n            } else if ((i === len - 1 || isInverse && i === 0) && options.x + width > rect.x + rect.width) {\n              if (elementSize.width > intervalLength && axis.labelIntersectAction === 'Trim') {\n                intervalLength -= options.x + width - (rect.x + rect.width);\n              } else {\n                intervalLength = width;\n              }\n              options.x = pointX = rect.x + rect.width - intervalLength;\n            }\n            break;\n        }\n      }\n      options.text = this.getLabelText(label, axis, intervalLength);\n      // ------- Hide Calculation (Start) -------------\n      // Currect label actual start value (Start)\n      var xValue = void 0;\n      var xValue2 = void 0;\n      if (isAxisBreakLabel && angle === 0) {\n        if (axis.lineBreakAlignment === 'Right') {\n          xValue = options.x - width;\n          xValue2 = options.x;\n        } else if (axis.lineBreakAlignment === 'Center') {\n          xValue = options.x - width / 2;\n          xValue2 = options.x + width / 2;\n        } else {\n          xValue = options.x;\n          xValue2 = options.x + width;\n        }\n      } else {\n        xValue = options.x;\n        xValue2 = options.x + width;\n      }\n      // Currect label actual start value (End)\n      if (angle === 0 && axis.labelIntersectAction === 'Hide' && i !== 0 && (!isInverse ? xValue <= previousEnd : xValue2 >= previousEnd)) {\n        continue;\n      }\n      // Previous label actual end value (Start)\n      if (isAxisBreakLabel) {\n        if (axis.lineBreakAlignment === 'Right') {\n          previousEnd = isInverse ? options.x - width : options.x;\n        } else if (axis.lineBreakAlignment === 'Center') {\n          previousEnd = isInverse ? options.x - width / 2 : options.x + width / 2;\n        } else {\n          previousEnd = isInverse ? options.x : options.x + width;\n        }\n      } else {\n        previousEnd = isInverse ? options.x : options.x + width;\n      }\n      // Previous label actual end value (End)\n      // ------- Hide Calculation (End) -------------\n      // label Rotataion calculation (Start)\n      if (angle !== 0) {\n        var height = void 0;\n        var rect_1 = void 0;\n        if (isAxisBreakLabel) {\n          var xAdjustment = 0;\n          var yAdjustment = 0;\n          height = label.breakLabelSize.height;\n          yAdjustment = label.breakLabelSize.height - 4; // 4 for label bound correction\n          // xAdjustment (Start)\n          if (axis.lineBreakAlignment === 'Center') {\n            xAdjustment = -(label.breakLabelSize.width / 2);\n          } else if (axis.lineBreakAlignment === 'Right') {\n            xAdjustment = -label.breakLabelSize.width;\n          }\n          // xAdjustment (End)\n          if (isLabelUnderAxisLine) {\n            yAdjustment = label.breakLabelSize.height / (options.text.length + 1);\n          }\n          rect_1 = new Rect(options.x + xAdjustment, options.y - yAdjustment, label.breakLabelSize.width, height);\n        } else {\n          height = pointY - (options.y - (label.size.height / 2 + 10));\n          rect_1 = new Rect(options.x, options.y - (label.size.height / 2 - 5), label.size.width, height);\n        }\n        var rectCoordinates = this.getRectanglePoints(rect_1);\n        var rectCenterX = isAxisBreakLabel ? rect_1.x + rect_1.width / 2 : pointX;\n        var rectCenterY = isAxisBreakLabel ? rect_1.y + rect_1.height / 2 : pointY - height / 2;\n        if (isAxisBreakLabel) {\n          options.transform = 'rotate(' + angle + ',' + rectCenterX + ',' + rectCenterY + ')';\n        } else {\n          options.transform = 'rotate(' + angle + ',' + pointX + ',' + pointY + ')';\n        }\n        newPoints.push(getRotatedRectangleCoordinates(rectCoordinates, rectCenterX, rectCenterY, angle));\n        isRotatedLabelIntersect = false;\n        for (var index_1 = i; index_1 > 0; index_1--) {\n          if (newPoints[i] && newPoints[index_1 - 1] && isRotatedRectIntersect(newPoints[i], newPoints[index_1 - 1])) {\n            isRotatedLabelIntersect = true;\n            newPoints[i] = null;\n            break;\n          }\n        }\n      }\n      // label Rotataion calculation (End)\n      textElement(chart.renderer, options, label.labelStyle, label.labelStyle.color || chart.themeStyle.axisLabel, labelElement, axis.isAxisOpposedPosition !== (axis.labelPosition === 'Inside'), chart.redraw, true, null, null, null, label.size, isRotatedLabelIntersect, chart.enableCanvas);\n    }\n    if (!this.chart.enableCanvas) {\n      if (!chart.delayRedraw) {\n        parent.appendChild(labelElement);\n      } else if (axis.visible && axis.internalVisibility) {\n        this.createZoomingLabel(this.chart, labelElement, axis, index, rect);\n      }\n    }\n  };\n  /**\n   * To get text anchor value for line break labels.\n   *\n   * @param {Axis} axis axis model\n   * @returns {string} returns text anchor\n   */\n  CartesianAxisLayoutPanel.prototype.getAnchor = function (axis) {\n    return axis.lineBreakAlignment === 'Center' ? 'middle' : this.chart.enableRtl ? axis.lineBreakAlignment === 'Left' ? 'end' : 'start' : axis.lineBreakAlignment === 'Left' ? 'start' : 'end';\n  };\n  /**\n   * Get rect coordinates\n   *\n   * @param {Rect} rect rect\n   * @returns {ChartLocation[]} rectangle points\n   */\n  CartesianAxisLayoutPanel.prototype.getRectanglePoints = function (rect) {\n    var point1 = new ChartLocation(rect.x, rect.y);\n    var point2 = new ChartLocation(rect.x + rect.width, rect.y);\n    var point3 = new ChartLocation(rect.x + rect.width, rect.y + rect.height);\n    var point4 = new ChartLocation(rect.x, rect.y + rect.height);\n    return [point1, point2, point3, point4];\n  };\n  /**\n   * To get axis label text\n   *\n   * @param {VisibleLabels} label label\n   * @param {Axis} axis axis\n   * @param {number} intervalLength intervalLength\n   * @returns {string | string[]} label or label collection\n   */\n  CartesianAxisLayoutPanel.prototype.getLabelText = function (label, axis, intervalLength) {\n    if (isBreakLabel(label.originalText)) {\n      var result = [];\n      var str = void 0;\n      for (var index = 0; index < label.text.length; index++) {\n        str = this.findAxisLabel(axis, label.text[index], intervalLength);\n        result.push(str);\n      }\n      return result;\n    } else {\n      return this.findAxisLabel(axis, label.text, intervalLength);\n    }\n  };\n  /**\n   * To render the x-axis label border.\n   *\n   * @param {Axis} axis axis\n   * @param {number} index index\n   * @param {Element} parent parent\n   * @param {Rect} axisRect axisRect\n   * @returns {void}\n   */\n  CartesianAxisLayoutPanel.prototype.drawXAxisBorder = function (axis, index, parent, axisRect) {\n    if (axis.border.width > 0) {\n      var scrollBarHeight = axis.labelPosition === 'Outside' ? axis.scrollBarHeight : 0;\n      var isOpposed = axis.isAxisOpposedPosition;\n      var startX = void 0;\n      var startY = axisRect.y + (isOpposed ? -1 : 1) * scrollBarHeight;\n      var padding = 10;\n      var pointX = void 0;\n      var gap = axisRect.width / axis.visibleRange.delta * (axis.valueType === 'DateTime' ? axis.dateTimeInterval : axis.visibleRange.interval);\n      var endX = void 0;\n      var length_2 = axis.maxLabelSize.height + (axis.tickPosition === axis.labelPosition ? axis.majorTickLines.height : 0);\n      var labelBorder = '';\n      var ticksbwtLabel = axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks' ? -0.5 : 0;\n      var endY = isOpposed && axis.labelPosition === 'Inside' || !isOpposed && axis.labelPosition === 'Outside' ? axisRect.y + length_2 + padding + scrollBarHeight : axisRect.y - length_2 - padding - scrollBarHeight;\n      for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {\n        pointX = valueToCoefficient(axis.visibleLabels[i].value + ticksbwtLabel, axis);\n        pointX = (axis.isAxisInverse ? 1 - pointX : pointX) * axisRect.width;\n        if (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') {\n          startX = pointX + axisRect.x;\n          endX = pointX + gap + axisRect.x;\n        } else {\n          startX = pointX - gap * 0.5 + axisRect.x;\n          endX = pointX + gap * 0.5 + axisRect.x;\n        }\n        switch (axis.border.type) {\n          case 'Rectangle':\n          case 'WithoutTopBorder':\n            if (startX < axisRect.x) {\n              labelBorder += 'M' + ' ' + axisRect.x + ' ' + endY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ';\n            } else if (Math.floor(endX) > axisRect.width + axisRect.x && !(axis.visibleLabels.length === 1)) {\n              labelBorder += 'M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' + endY + ' ' + 'L' + ' ' + (axisRect.width + axisRect.x) + ' ' + endY + ' ';\n            } else {\n              labelBorder += 'M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' + endY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ';\n              if (i === 0) {\n                labelBorder += 'M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' + endY + ' ' + 'M ' + startX + ' ' + endY + ' L ' + axisRect.x + ' ' + endY;\n              }\n              if (i === axis.visibleLabels.length - 1) {\n                labelBorder += 'M' + ' ' + endX + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ' + 'M ' + endX + ' ' + endY + ' L ' + (axisRect.width + axisRect.x) + ' ' + endY;\n              }\n            }\n            break;\n          case 'WithoutTopandBottomBorder':\n            if (!(startX < axisRect.x) && !(Math.floor(endX) > axisRect.width + axisRect.x)) {\n              labelBorder += 'M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' + endY + ' ' + 'M ' + endX + ' ' + startY + ' L ' + endX + ' ' + endY;\n            }\n            break;\n        }\n      }\n      labelBorder += axis.border.type === 'Rectangle' ? 'M ' + ' ' + axisRect.x + ' ' + startY + 'L' + ' ' + (axisRect.x + axisRect.width) + ' ' + startY : '';\n      if (labelBorder !== '') {\n        this.createAxisBorderElement(axis, index, labelBorder, parent);\n      }\n    }\n    if (this.chart.multiLevelLabelModule && axis.multiLevelLabels.length > 0) {\n      this.chart.multiLevelLabelModule.renderXAxisMultiLevelLabels(axis, index, parent, axisRect);\n    }\n  };\n  /**\n   * To create border element of the axis\n   *\n   * @param {Axis} axis axis\n   * @param {number} index index\n   * @param {string} labelBorder labelBorder\n   * @param {Element} parent parent\n   * @returns {void}\n   */\n  CartesianAxisLayoutPanel.prototype.createAxisBorderElement = function (axis, index, labelBorder, parent) {\n    var element = getElement(this.chart.element.id + '_BorderLine_' + index);\n    var direction = element ? element.getAttribute('d') : '';\n    var borderElement = this.chart.renderer.drawPath(new PathOption(this.chart.element.id + '_BorderLine_' + index, 'transparent', axis.border.width, axis.border.color || this.chart.themeStyle.axisLine, 1, '', labelBorder));\n    borderElement.style.pointerEvents = 'none';\n    appendChildElement(this.chart.enableCanvas, parent, borderElement, this.chart.redraw, true, 'x', 'y', null, direction, true);\n  };\n  /**\n   * To find the axis label of the intersect action\n   *\n   * @param {Axis} axis axis\n   * @param {string} label label\n   * @param {number} width width\n   * @returns {string} label\n   */\n  CartesianAxisLayoutPanel.prototype.findAxisLabel = function (axis, label, width) {\n    return axis.labelIntersectAction === 'Trim' ? axis.angle % 360 === 0 && !axis.enableTrim ? textTrim(width, label, axis.labelStyle) : label : label;\n  };\n  /**\n   * X-Axis Title function performed\n   *\n   * @param {Axis} axis axis\n   * @param {number} index index\n   * @param {Element} parent parent\n   * @param {Rect} rect rect\n   * @returns {void}\n   */\n  CartesianAxisLayoutPanel.prototype.drawXAxisTitle = function (axis, index, parent, rect) {\n    if (axis.title) {\n      var chart = this.chart;\n      var elementSize = measureText(axis.title, axis.titleStyle);\n      var scrollBarHeight = isNullOrUndefined(axis.crossesAt) ? axis.scrollBarHeight : 0;\n      var padding = (axis.tickPosition === 'Inside' ? 0 : axis.majorTickLines.height + axis.titlePadding) + (axis.labelPosition === 'Inside' ? 0 : axis.maxLabelSize.height + axis.multiLevelLabelHeight + axis.labelPadding);\n      var titleSize = axis.titleSize.height * (axis.titleCollection.length - 1);\n      padding = axis.isAxisOpposedPosition ? -(padding + elementSize.height / 4 + scrollBarHeight + titleSize) : padding + 3 * elementSize.height / 4 + scrollBarHeight;\n      var options = new TextOption(chart.element.id + '_AxisTitle_' + index, rect.x + rect.width * 0.5, rect.y + padding, 'middle', axis.titleCollection);\n      var element = textElement(chart.renderer, options, axis.titleStyle, axis.titleStyle.color || chart.themeStyle.axisTitle, parent, null, null, null, null, null, null, null, null, chart.enableCanvas);\n      element.setAttribute('aria-label', axis.description || axis.title);\n      element.setAttribute('tabindex', axis.tabIndex.toString());\n    }\n  };\n  /**\n   * To render the axis grid and tick lines(Both Major and Minor)\n   *\n   * @param {Axis} axis axis\n   * @param {number} index index\n   * @param {string} gridDirection gridDirection\n   * @param {MajorTickLinesModel | MinorTickLinesModel | MajorGridLinesModel | MinorGridLinesModel} gridModel gridModel\n   * @param {string} gridId gridId\n   * @param {number} gridIndex gridIndex\n   * @param {Element} parent parent\n   * @param {string} themeColor themeColor\n   * @param {string} dashArray dashArray\n   * @returns {void}\n   */\n  CartesianAxisLayoutPanel.prototype.renderGridLine = function (axis, index, gridDirection, gridModel, gridId, gridIndex, parent, themeColor, dashArray) {\n    if (dashArray === void 0) {\n      dashArray = null;\n    }\n    var chart = this.chart;\n    var direction;\n    var element;\n    if (gridModel.width > 0 && axis.visible && axis.internalVisibility && gridDirection) {\n      element = getElement(chart.element.id + gridId + index + '_' + gridIndex);\n      direction = element ? element.getAttribute('d') : null;\n      element = null;\n      this.htmlObject = chart.renderer.drawPath(new PathOption(chart.element.id + gridId + index + '_' + gridIndex, 'transparent', gridModel.width, gridModel.color || themeColor, null, dashArray, gridDirection));\n      appendChildElement(chart.enableCanvas, parent, this.htmlObject, chart.redraw, true, 'x', 'y', null, direction, true);\n    }\n  };\n  /**\n   * To Find the parent node of the axis\n   *\n   * @param {string} elementId elementId\n   * @param {Element} label label\n   * @param {number} index index\n   * @returns {Element} parent node of the axis\n   */\n  CartesianAxisLayoutPanel.prototype.findParentNode = function (elementId, label, index) {\n    if (document.getElementById(elementId + 'AxisGroup' + index + 'Inside').contains(document.getElementById(label.id))) {\n      return document.getElementById(elementId + 'AxisGroup' + index + 'Inside');\n    } else {\n      return document.getElementById(elementId + 'AxisGroup' + index + 'Outside');\n    }\n  };\n  /**\n   * Create Zooming Labels Function Called here\n   *\n   * @param {Chart} chart chart\n   * @param {Element} labelElement labelElement\n   * @param {Axis} axis axis\n   * @param {number} index index\n   * @param {Rect} rect rect\n   * @returns {void}\n   */\n  CartesianAxisLayoutPanel.prototype.createZoomingLabel = function (chart, labelElement, axis, index, rect) {\n    var parentNode = this.findParentNode(chart.element.id, labelElement, index);\n    labelElement.setAttribute('opacity', '0.3');\n    var zoomElement = chart.renderer.createGroup({\n      id: chart.element.id + 'AxisLabels_Zoom' + index\n    });\n    zoomElement = createZoomingLabels(chart, axis, zoomElement, index, axis.orientation === 'Vertical', rect);\n    parentNode.replaceChild(labelElement, document.getElementById(labelElement.id));\n    if (getElement(chart.element.id + 'AxisLabels_Zoom' + index)) {\n      parentNode.replaceChild(zoomElement, document.getElementById(zoomElement.id));\n    } else {\n      parentNode.appendChild(zoomElement);\n    }\n  };\n  return CartesianAxisLayoutPanel;\n}();\nexport { CartesianAxisLayoutPanel };","map":{"version":3,"names":["createElement","isNullOrUndefined","DataUtil","subtractThickness","valueToCoefficient","sum","redrawElement","isBreakLabel","ChartLocation","subArray","inside","appendChildElement","stringToNumber","Thickness","logBase","createZoomingLabels","getElement","Size","Rect","measureText","TextOption","PathOption","textElement","textTrim","getRotatedRectangleCoordinates","isRotatedRectIntersect","isZoomSet","axisPadding","CartesianAxisLayoutPanel","chartModule","chart","padding","prototype","measureAxis","rect","chartAreaWidth","chartArea","width","availableSize","crossAt","seriesClipRect","x","y","height","initialClipRect","leftSize","rightSize","topSize","bottomSize","measureRowAxis","measureColumnAxis","delayRedraw","calculateAxisSize","calculateFixedChartArea","refreshAxis","margin","right","legendSettings","position","legendModule","legendBounds","_i","_a","rows","length","item","farSizes","row","calculateRowSize","nearSizes","arrangeAxis","measureDefinition","computedHeight","column","calculateColumnSize","columns","computedWidth","definition","size","ele","axes","axis","scrollBarHeight","scrollBarModule","zoomModule","zoomSettings","enableScrollbar","enableScrollbarOnZooming","isZoomed","zoomFactor","zoomPosition","scrollbarSettings","enable","getModule","baseModule","calculateRangeAndInterval","computeSize","nearCount","farCount","axisOffset","i","len","j","len_1","plotOffset","k","len_2","span","computedTop","plotOffsetTop","getAxisOffsetValue","plotOffsetBottom","isAxisOpposedPosition","len_3","len_4","computedLeft","plotOffsetLeft","plotOffsetRight","measure","actualIndex","axisCollections","orientation","verticalAxes","push","getActualRow","pushAxis","horizontalAxes","getActualColumn","isRTLEnabled","enableRtl","setIsInversedAndOpposedPosition","position1","position2","rangeOffset","crossesAt","crossesInAxis","requireInvertedAxis","crossInAxis","primaryXAxis","primaryYAxis","updateCrossAt","name","valueType","option","skeleton","type","dateParser","intl","getDateParser","dateFormatter","getDateFormat","Date","parse","parseJson","val","parseFloat","labels","indexOf","axisCollection","actualLength","pos","columnIndex","result","rowIndex","rowTop","remainingHeight","Math","max","min","parseInt","columnLeft","remainingWidth","renderAxes","axisElement","renderer","createGroup","id","element","axisLineElement","outsideElement","isInside","axisVisibility","series","yAxisName","xAxisName","visible","findAxisPosition","updateCrossValue","internalVisibility","lineStyle","drawAxisLine","updatedRect","majorGridLines","majorTickLines","drawXAxisGridLine","tickPosition","drawXAxisLabels","labelPosition","placeNextToAxisLine","drawXAxisBorder","drawXAxisTitle","drawYAxisGridLine","drawYAxisLabels","drawYAxisBorder","drawYAxisTitle","enableCanvas","appendChild","childNodes","renderScrollbar","border","color","drawBottomLine","svgObject","redraw","zoomingScrollBar","isScrollUI","visibleSeries","scrollElement","render","destroy","visibleRange","index","isRow","optionsLine","x1","x2","y1","y2","definitionName","htmlObject","drawLine","plotX","plotY","parent","direction","getAttribute","dashArray","themeStyle","axisLine","drawPath","isLogAxis","isCategoryAxis","tempInterval","pointY","majorGrid","majorTick","minorGridDirection","isOpposed","tickSize","axisLineSize","ticksbwtLabel","labelPlacement","isTickInside","ticks","visibleLabels","chartThemeStyle","minorGridLines","minorTickLines","value","interval","isBorder","renderGridLine","majorGridLine","majorTickLine","minorTicksPerInterval","renderMinorGridOnZooming","drawAxisMinorLine","minorGridLine","minorTickLine","start","startIndex","endIndex","label","pointX","elementSize","labelSpace","labelPadding","options","isAxisBreakLabel","isLabelInside","tickSpace","angle","labelElement","textHeight","textPadding","maxLineWidth","pixel","isInverse","isAxisInverse","previousEnd","intervalLength","labelHeight","yAxisLabelX","isLabelOnAxisLineLeft","sizeWidth","breakLabelSizeWidth","map","breakLabelSize","LabelMaxWidth","apply","breakLabelMaxWidth","originalText","stockChart","floor","text","labelIntersectAction","labelStyle","textAlignment","edgeLabelPlacement","previousYValue","currentYValue","transform","axisLabel","createZoomingLabel","getAxisLabelXvalue","textWidth","anchor","lineBreakAlignment","startY","gap","delta","dateTimeInterval","endY","length_1","maxLabelSize","labelBorder","endX","createAxisBorderElement","multiLevelLabels","multiLevelLabelModule","renderYAxisMultiLevelLabels","title","labelRotation","titlePadding","multiLevelLabelHeight","titleSize","titleCollection","titleStyle","axisTitle","setAttribute","tabIndex","toString","description","minorDirection","labelIndex","isFirstLabel","coor","range","logStart","logEnd","logInterval","logPosition","ticksX","ticksY","minorGird","minorTick","pow","findLogNumeric","ceil","concat","tempValue","islabelInside","isHorizontalAngle","labelWidth","newPoints","isRotatedLabelIntersect","isLabelUnderAxisLine","isEndAnchor","paddingForBreakLabel","getAnchor","isRtlEnabled","getLabelText","xValue","xValue2","rect_1","xAdjustment","yAdjustment","rectCoordinates","getRectanglePoints","rectCenterX","rectCenterY","index_1","point1","point2","point3","point4","str","findAxisLabel","axisRect","startX","length_2","renderXAxisMultiLevelLabels","borderElement","style","pointerEvents","enableTrim","gridDirection","gridModel","gridId","gridIndex","themeColor","findParentNode","elementId","document","getElementById","contains","parentNode","zoomElement","replaceChild"],"sources":["D:/USPERSO IMPLEMENTATION/Projet_DevIII/frontend/node_modules/@syncfusion/ej2-charts/src/chart/axis/cartesian-panel.js"],"sourcesContent":["import { createElement, isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { DataUtil } from '@syncfusion/ej2-data';\nimport { subtractThickness, valueToCoefficient, sum, redrawElement, isBreakLabel, ChartLocation } from '../../common/utils/helper';\nimport { subArray, inside, appendChildElement, stringToNumber } from '../../common/utils/helper';\nimport { Thickness, logBase, createZoomingLabels, getElement } from '../../common/utils/helper';\nimport { Size, Rect, measureText, TextOption, PathOption } from '@syncfusion/ej2-svg-base';\nimport { textElement, textTrim, getRotatedRectangleCoordinates, isRotatedRectIntersect, isZoomSet } from '../../common/utils/helper';\n/**\n * Specifies the Cartesian Axis Layout.\n */\nvar axisPadding = 10;\nvar CartesianAxisLayoutPanel = /** @class */ (function () {\n    /** @private */\n    function CartesianAxisLayoutPanel(chartModule) {\n        this.chart = chartModule;\n        this.padding = 5;\n    }\n    /**\n     * Measure the axis size.\n     *\n     * @returns {void}\n     * @private\n     */\n    CartesianAxisLayoutPanel.prototype.measureAxis = function (rect) {\n        var chart = this.chart;\n        var chartAreaWidth = chart.chartArea.width ? stringToNumber(chart.chartArea.width, chart.availableSize.width) : null;\n        this.crossAt(chart);\n        this.seriesClipRect = new Rect(rect.x, rect.y, rect.width, rect.height);\n        this.initialClipRect = rect;\n        this.leftSize = 0;\n        this.rightSize = 0;\n        this.topSize = 0;\n        this.bottomSize = 0;\n        //Measure Axis size with initial Rect\n        this.measureRowAxis(chart, this.initialClipRect);\n        this.initialClipRect = subtractThickness(this.initialClipRect, new Thickness(this.leftSize, this.rightSize, 0, 0));\n        this.measureColumnAxis(chart, this.initialClipRect);\n        this.initialClipRect = subtractThickness(this.initialClipRect, new Thickness(0, 0, this.topSize, this.bottomSize));\n        if (!this.chart.delayRedraw) {\n            this.calculateAxisSize(this.initialClipRect);\n        }\n        this.leftSize = 0;\n        this.rightSize = 0;\n        this.topSize = 0;\n        this.bottomSize = 0;\n        //Measure Axis size with series Rect\n        this.measureRowAxis(chart, this.initialClipRect);\n        this.seriesClipRect = subtractThickness(this.seriesClipRect, new Thickness(this.leftSize, this.rightSize, 0, 0));\n        this.measureColumnAxis(chart, this.initialClipRect);\n        this.seriesClipRect = subtractThickness(this.seriesClipRect, new Thickness(0, 0, this.topSize, this.bottomSize));\n        if (chartAreaWidth) {\n            this.calculateFixedChartArea(chart, chartAreaWidth);\n        }\n        if (!this.chart.delayRedraw) {\n            chart.refreshAxis();\n            this.calculateAxisSize(this.seriesClipRect);\n        }\n    };\n    CartesianAxisLayoutPanel.prototype.calculateFixedChartArea = function (chart, chartAreaWidth) {\n        this.seriesClipRect.width = chartAreaWidth;\n        this.seriesClipRect.x = chart.availableSize.width - chart.margin.right - chartAreaWidth -\n            (chart.legendSettings.position === \"Right\" ? chart.legendModule.legendBounds.width : 0);\n        for (var _i = 0, _a = chart.rows; _i < _a.length; _i++) {\n            var item = _a[_i];\n            this.seriesClipRect.x -= sum(item.farSizes);\n        }\n    };\n    CartesianAxisLayoutPanel.prototype.measureRowAxis = function (chart, rect) {\n        var row;\n        this.calculateRowSize(rect);\n        for (var _i = 0, _a = chart.rows; _i < _a.length; _i++) {\n            var item = _a[_i];\n            row = item;\n            row.nearSizes = [];\n            row.farSizes = [];\n            this.arrangeAxis(row);\n            this.measureDefinition(row, chart, new Size(chart.availableSize.width, row.computedHeight));\n            if (this.leftSize < sum(row.nearSizes)) {\n                this.leftSize = sum(row.nearSizes);\n            }\n            if (this.rightSize < sum(row.farSizes)) {\n                this.rightSize = sum(row.farSizes);\n            }\n        }\n    };\n    CartesianAxisLayoutPanel.prototype.measureColumnAxis = function (chart, rect) {\n        var column;\n        this.calculateColumnSize(rect);\n        for (var _i = 0, _a = chart.columns; _i < _a.length; _i++) {\n            var item = _a[_i];\n            column = item;\n            column.farSizes = [];\n            column.nearSizes = [];\n            this.arrangeAxis(column);\n            this.measureDefinition(column, chart, new Size(column.computedWidth, chart.availableSize.height));\n            if (this.bottomSize < sum(column.nearSizes)) {\n                this.bottomSize = sum(column.nearSizes);\n            }\n            if (this.topSize < sum(column.farSizes)) {\n                this.topSize = sum(column.farSizes);\n            }\n        }\n    };\n    /**\n     * Measure the column and row in chart.\n     *\n     * @returns {void}\n     * @private\n     */\n    CartesianAxisLayoutPanel.prototype.measureDefinition = function (definition, chart, size) {\n        var ele = 16; // scrollbar element height is 16.\n        for (var _i = 0, _a = definition.axes; _i < _a.length; _i++) {\n            var axis = _a[_i];\n            axis.scrollBarHeight = chart.scrollBarModule && chart.zoomModule && chart.zoomSettings.enableScrollbar &&\n                axis.enableScrollbarOnZooming && chart.zoomModule.isZoomed && (axis.zoomFactor < 1 || axis.zoomPosition > 0) ? ele : 0;\n            axis.scrollBarHeight = chart.scrollBarModule && (chart.zoomModule && chart.zoomSettings.enableScrollbar &&\n                axis.enableScrollbarOnZooming && chart.zoomModule.isZoomed && (axis.zoomFactor < 1 || axis.zoomPosition > 0)\n                || axis.scrollbarSettings.enable) ? ele : 0;\n            axis.getModule(chart);\n            axis.baseModule.calculateRangeAndInterval(size, axis);\n            definition.computeSize(axis, axis.scrollBarHeight);\n        }\n        if (definition.farSizes.length > 0) {\n            definition.farSizes[definition.farSizes.length - 1] -= axisPadding;\n        }\n        if (definition.nearSizes.length > 0) {\n            definition.nearSizes[definition.nearSizes.length - 1] -= axisPadding;\n        }\n    };\n    /**\n     * Measure the axis.\n     *\n     * @returns {void}\n     * @private\n     */\n    CartesianAxisLayoutPanel.prototype.calculateAxisSize = function (rect) {\n        var chart = this.chart;\n        var row;\n        var column;\n        var definition;\n        var axis;\n        var nearCount = 0;\n        var farCount = 0;\n        var size = 0;\n        var x;\n        var y;\n        var axisOffset;\n        this.calculateRowSize(rect);\n        for (var i = 0, len = chart.rows.length; i < len; i++) {\n            row = chart.rows[i];\n            nearCount = 0;\n            farCount = 0;\n            for (var j = 0, len_1 = row.axes.length; j < len_1; j++) {\n                axis = row.axes[j];\n                axisOffset = axis.plotOffset;\n                if (axis.rect.height === 0) {\n                    axis.rect.height = row.computedHeight;\n                    size = 0;\n                    for (var k = i + 1, len_2 = i + axis.span; k < len_2; k++) {\n                        definition = chart.rows[k];\n                        size += definition.computedHeight;\n                    }\n                    axis.rect.y = (row.computedTop - size) + (axis.plotOffsetTop ? axis.plotOffsetTop : axisOffset);\n                    axis.rect.height = (axis.rect.height + size) -\n                        (this.getAxisOffsetValue(axis.plotOffsetTop, axis.plotOffsetBottom, axis.plotOffset));\n                    axis.rect.width = 0;\n                }\n                if (axis.isAxisOpposedPosition) {\n                    x = rect.x + rect.width + sum(subArray(row.farSizes, farCount));\n                    axis.rect.x = axis.rect.x >= x ? axis.rect.x : x;\n                    farCount++;\n                }\n                else {\n                    x = rect.x - sum(subArray(row.nearSizes, nearCount));\n                    axis.rect.x = axis.rect.x <= x ? axis.rect.x : x;\n                    nearCount++;\n                }\n            }\n        }\n        this.calculateColumnSize(rect);\n        for (var i = 0, len = chart.columns.length; i < len; i++) {\n            column = chart.columns[i];\n            nearCount = 0;\n            farCount = 0;\n            for (var j = 0, len_3 = column.axes.length; j < len_3; j++) {\n                axis = column.axes[j];\n                axisOffset = axis.plotOffset;\n                if (axis.rect.width === 0) {\n                    for (var k = i, len_4 = (i + axis.span); k < len_4; k++) {\n                        definition = chart.columns[k];\n                        axis.rect.width += definition.computedWidth;\n                    }\n                    axis.rect.x = column.computedLeft + (axis.plotOffsetLeft ? axis.plotOffsetLeft : axisOffset);\n                    axis.rect.width -= (this.getAxisOffsetValue(axis.plotOffsetLeft, axis.plotOffsetRight, axis.plotOffset));\n                    axis.rect.height = 0;\n                }\n                if (axis.isAxisOpposedPosition) {\n                    y = rect.y - sum(subArray(column.farSizes, farCount));\n                    axis.rect.y = axis.rect.y <= y ? axis.rect.y : y;\n                    farCount++;\n                }\n                else {\n                    y = rect.y + rect.height + sum(subArray(column.nearSizes, nearCount));\n                    axis.rect.y = axis.rect.y >= y ? axis.rect.y : y;\n                    nearCount++;\n                }\n            }\n        }\n    };\n    /**\n     * Measure the axis.\n     *\n     * @returns {void}\n     * @private\n     */\n    CartesianAxisLayoutPanel.prototype.measure = function () {\n        var chart = this.chart;\n        var row;\n        var column;\n        var definition;\n        var actualIndex;\n        var span;\n        for (var _i = 0, _a = chart.axisCollections; _i < _a.length; _i++) {\n            var axis = _a[_i];\n            //definition.Axes = axis;\n            if (axis.orientation === 'Vertical') {\n                chart.verticalAxes.push(axis);\n                actualIndex = this.getActualRow(axis);\n                row = chart.rows[actualIndex];\n                this.pushAxis(row, axis);\n                span = ((actualIndex + axis.span) > chart.rows.length ? chart.rows.length : (actualIndex + axis.span));\n                for (var j = actualIndex + 1; j < span; j++) {\n                    definition = chart.rows[j];\n                    definition.axes[row.axes.length - 1] = axis;\n                    chart.rows[j] = definition;\n                }\n                chart.rows[actualIndex] = row;\n            }\n            else {\n                chart.horizontalAxes.push(axis);\n                actualIndex = this.getActualColumn(axis);\n                column = chart.columns[actualIndex];\n                this.pushAxis(column, axis);\n                span = ((actualIndex + axis.span) > chart.columns.length ? chart.columns.length : (actualIndex + axis.span));\n                for (var j = actualIndex + 1; j < span; j++) {\n                    definition = chart.columns[j];\n                    definition.axes[column.axes.length - 1] = axis;\n                    chart.columns[j] = definition;\n                }\n                chart.columns[actualIndex] = column;\n            }\n            axis.isRTLEnabled = chart.enableRtl;\n            axis.setIsInversedAndOpposedPosition();\n        }\n    };\n    CartesianAxisLayoutPanel.prototype.getAxisOffsetValue = function (position1, position2, plotOffset) {\n        var rangeOffset = position1 ? (position1 + (position2 ? position2 :\n            plotOffset)) : (position2 ? position2 + plotOffset : 2 * plotOffset);\n        return rangeOffset;\n    };\n    CartesianAxisLayoutPanel.prototype.crossAt = function (chart) {\n        for (var _i = 0, _a = chart.axisCollections; _i < _a.length; _i++) {\n            var axis = _a[_i];\n            if (axis.crossesAt === null) {\n                continue;\n            }\n            if (!axis.crossesInAxis) {\n                if (chart.requireInvertedAxis) {\n                    axis.crossInAxis = ((axis.orientation === 'Horizontal')) ? chart.primaryXAxis : chart.primaryYAxis;\n                }\n                else {\n                    axis.crossInAxis = ((axis.orientation === 'Horizontal')) ? chart.primaryYAxis : chart.primaryXAxis;\n                }\n                axis.crossAt = this.updateCrossAt(axis.crossInAxis, axis.crossesAt);\n                continue;\n            }\n            else {\n                for (var i = 2, len = chart.axisCollections.length; i < len; i++) {\n                    if (axis.crossesInAxis === chart.axisCollections[i].name) {\n                        axis.crossInAxis = chart.axisCollections[i];\n                        axis.crossAt = this.updateCrossAt(axis.crossInAxis, axis.crossesAt);\n                        continue;\n                    }\n                }\n            }\n        }\n    };\n    CartesianAxisLayoutPanel.prototype.updateCrossAt = function (axis, crossAt) {\n        switch (axis.valueType) {\n            case 'DateTime':\n                var option = {\n                    skeleton: 'full',\n                    type: 'dateTime'\n                };\n                var dateParser = this.chart.intl.getDateParser(option);\n                var dateFormatter = this.chart.intl.getDateFormat(option);\n                return Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({ val: crossAt }).val))));\n            case 'Category':\n                return parseFloat(crossAt) ? parseFloat(crossAt) : axis.labels.indexOf(crossAt);\n            case 'Logarithmic':\n                return logBase(crossAt, axis.logBase);\n            default:\n                return crossAt;\n        }\n    };\n    CartesianAxisLayoutPanel.prototype.pushAxis = function (definition, axis) {\n        for (var i = 0, len = definition.axes.length; i <= len; i++) {\n            if (!definition.axes[i]) {\n                definition.axes[i] = axis;\n                break;\n            }\n        }\n    };\n    CartesianAxisLayoutPanel.prototype.arrangeAxis = function (definition) {\n        var axisCollection = [];\n        for (var i = 0, len = definition.axes.length; i <= len; i++) {\n            if (definition.axes[i]) {\n                axisCollection.push(definition.axes[i]);\n            }\n        }\n        definition.axes = axisCollection;\n    };\n    CartesianAxisLayoutPanel.prototype.getActualColumn = function (axis) {\n        var actualLength = this.chart.columns.length;\n        var pos = axis.columnIndex;\n        var result = pos >= actualLength ? actualLength - 1 : (pos < 0 ? 0 : pos);\n        return result;\n    };\n    CartesianAxisLayoutPanel.prototype.getActualRow = function (axis) {\n        var actualLength = this.chart.rows.length;\n        var pos = axis.rowIndex;\n        var result = pos >= actualLength ? actualLength - 1 : (pos < 0 ? 0 : pos);\n        return result;\n    };\n    /**\n     * Measure the row size.\n     *\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.calculateRowSize = function (rect) {\n        /*! Calculate row size */\n        var chart = this.chart;\n        var row;\n        var rowTop = rect.y + rect.height;\n        var height = 0;\n        var remainingHeight = Math.max(0, rect.height);\n        for (var i = 0, len = chart.rows.length; i < len; i++) {\n            row = chart.rows[i];\n            if (row.height.indexOf('%') !== -1) {\n                height = Math.min(remainingHeight, (rect.height * parseInt(row.height, 10) / 100));\n            }\n            else {\n                height = Math.min(remainingHeight, parseInt(row.height, 10));\n            }\n            height = (i !== (len - 1)) ? height : remainingHeight;\n            row.computedHeight = height;\n            rowTop -= height;\n            row.computedTop = rowTop;\n            remainingHeight -= height;\n        }\n    };\n    /**\n     * Measure the row size.\n     *\n     * @param {Rect} rect rect\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.calculateColumnSize = function (rect) {\n        /*! Calculate column size */\n        var chart = this.chart;\n        var column;\n        var columnLeft = rect.x;\n        var width = 0;\n        var remainingWidth = Math.max(0, rect.width);\n        for (var i = 0, len = chart.columns.length; i < len; i++) {\n            column = chart.columns[i];\n            if (column.width.indexOf('%') !== -1) {\n                width = Math.min(remainingWidth, (rect.width * parseInt(column.width, 10) / 100));\n            }\n            else {\n                width = Math.min(remainingWidth, parseInt(column.width, 10));\n            }\n            width = (i !== (len - 1)) ? width : remainingWidth;\n            column.computedWidth = width;\n            column.computedLeft = columnLeft;\n            columnLeft += width;\n            remainingWidth -= width;\n        }\n    };\n    /**\n     * To render the axis element.\n     *\n     * @returns {void}\n     * @private\n     */\n    // tslint:disable-next-line:max-func-body-length\n    CartesianAxisLayoutPanel.prototype.renderAxes = function () {\n        var chart = this.chart;\n        var axis;\n        var axisElement = chart.renderer.createGroup({ id: chart.element.id + 'AxisInsideCollection' });\n        var axisLineElement = chart.renderer.createGroup({ id: chart.element.id + 'AxisOutsideCollection' });\n        var outsideElement;\n        var isInside;\n        for (var i = 0, len = chart.axisCollections.length; i < len; i++) {\n            var axisVisibility = true;\n            axis = chart.axisCollections[i];\n            this.element = chart.renderer.createGroup({ id: chart.element.id + 'AxisGroup' + i + 'Inside' });\n            outsideElement = chart.renderer.createGroup({ id: chart.element.id + 'AxisGroup' + i + 'Outside' });\n            for (var _i = 0, _a = this.chart.series; _i < _a.length; _i++) {\n                var series = _a[_i];\n                if (axis.name === series.yAxisName || axis.name === series.xAxisName) {\n                    axisVisibility = series.visible;\n                    if (axisVisibility) {\n                        break;\n                    }\n                    else {\n                        continue;\n                    }\n                }\n            }\n            if (!axisVisibility) {\n                break;\n            }\n            isInside = this.findAxisPosition(axis);\n            if (axis.orientation === 'Horizontal') {\n                axis.updateCrossValue();\n                if (axis.visible && axis.internalVisibility && axis.lineStyle.width > 0) {\n                    this.drawAxisLine(axis, i, axis.plotOffset, 0, isInside ? outsideElement : this.element, axis.updatedRect);\n                }\n                if (axis.majorGridLines.width > 0 || axis.majorTickLines.width > 0) {\n                    this.drawXAxisGridLine(axis, i, (isInside || axis.tickPosition === 'Inside') ? outsideElement : this.element, axis.updatedRect);\n                }\n                if (axis.visible && axis.internalVisibility) {\n                    this.drawXAxisLabels(axis, i, (isInside || axis.labelPosition === 'Inside') ? outsideElement : this.element, (axis.placeNextToAxisLine ? axis.updatedRect : axis.rect));\n                    this.drawXAxisBorder(axis, i, (isInside || axis.labelPosition === 'Inside') ? outsideElement : this.element, (axis.placeNextToAxisLine ? axis.updatedRect : axis.rect));\n                    this.drawXAxisTitle(axis, i, isInside ? outsideElement : this.element, (axis.placeNextToAxisLine ? axis.updatedRect : axis.rect));\n                }\n            }\n            else {\n                axis.updateCrossValue();\n                if (axis.visible && axis.internalVisibility && axis.lineStyle.width > 0) {\n                    this.drawAxisLine(axis, i, 0, axis.plotOffset, isInside ? outsideElement : this.element, axis.updatedRect);\n                }\n                if (axis.majorGridLines.width > 0 || axis.majorTickLines.width > 0) {\n                    this.drawYAxisGridLine(axis, i, (isInside || axis.tickPosition === 'Inside') ? outsideElement : this.element, axis.updatedRect);\n                }\n                if (axis.visible && axis.internalVisibility) {\n                    this.drawYAxisLabels(axis, i, (isInside || axis.labelPosition === 'Inside') ? outsideElement : this.element, (axis.placeNextToAxisLine ? axis.updatedRect : axis.rect));\n                    this.drawYAxisBorder(axis, i, (isInside || axis.labelPosition === 'Inside') ? outsideElement : this.element, (axis.placeNextToAxisLine ? axis.updatedRect : axis.rect));\n                    this.drawYAxisTitle(axis, i, isInside ? outsideElement : this.element, (axis.placeNextToAxisLine ? axis.updatedRect : axis.rect));\n                }\n            }\n            if (!this.chart.enableCanvas) {\n                axisElement.appendChild(this.element);\n                if (outsideElement && outsideElement.childNodes.length > 0) {\n                    axisLineElement.appendChild(outsideElement);\n                }\n            }\n            if (chart.scrollBarModule && ((chart.zoomSettings.enableScrollbar && axis.enableScrollbarOnZooming) ||\n                axis.scrollbarSettings.enable)) {\n                this.renderScrollbar(chart, axis);\n            }\n        }\n        this.element = chart.renderer.createGroup({ id: chart.element.id + 'DefinitionLine' });\n        for (var j = 0, len = chart.rows.length; j < len; j++) {\n            var row = chart.rows[j];\n            if (row.border.color) {\n                this.drawBottomLine(row, j, true);\n            }\n        }\n        for (var j = 0, len = chart.columns.length; j < len; j++) {\n            var column = chart.columns[j];\n            if (column.border.color) {\n                this.drawBottomLine(column, j, false);\n            }\n        }\n        if (!this.chart.enableCanvas) {\n            axisElement.appendChild(this.element);\n        }\n        appendChildElement(chart.enableCanvas, chart.svgObject, axisElement, chart.redraw);\n        return axisLineElement;\n    };\n    /**\n     * To render the axis scrollbar\n     *\n     * @param {Chart} chart chart\n     * @param {Axis} axis axis\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.renderScrollbar = function (chart, axis) {\n        var isZoomed = isNullOrUndefined(chart.zoomModule) ? false : chart.zoomModule.isZoomed;\n        if (((isZoomed && (axis.zoomFactor < 1 || axis.zoomPosition > 0)) || (axis.scrollbarSettings.enable &&\n            (axis.zoomFactor <= 1 || axis.zoomPosition >= 0))) &&\n            (!axis.zoomingScrollBar.isScrollUI || chart.visibleSeries[0].type.indexOf('Bar') >= 0)) {\n            if (!chart.scrollElement) {\n                chart.scrollElement = redrawElement(chart.redraw, chart.element.id + '_scrollElement') || createElement('div', { id: chart.element.id + '_scrollElement' });\n            }\n            appendChildElement(false, chart.scrollElement, axis.zoomingScrollBar.render(true), true);\n        }\n        else if (axis.zoomFactor === 1 && axis.zoomPosition === 0 && axis.zoomingScrollBar.svgObject && !axis.scrollbarSettings.enable) {\n            axis.zoomingScrollBar.destroy();\n        }\n        if (axis.zoomingScrollBar.isScrollUI) {\n            axis.zoomingScrollBar.isScrollUI = false;\n        }\n    };\n    /**\n     * To find the axis position\n     *\n     * @param {Axis} axis axis\n     * @returns {boolean} axis position\n     */\n    CartesianAxisLayoutPanel.prototype.findAxisPosition = function (axis) {\n        return axis.crossAt !== null && axis.isInside(axis.crossInAxis.visibleRange);\n    };\n    /**\n     * To render the bootom line of the columns and rows\n     *\n     * @param {Row | Column} definition definition\n     * @param {number} index index\n     * @param {boolean} isRow isRow\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.drawBottomLine = function (definition, index, isRow) {\n        var chart = this.chart;\n        var optionsLine = {};\n        var x1;\n        var x2;\n        var y1;\n        var y2;\n        var definitionName;\n        if (isRow) {\n            definition = definition;\n            y1 = y2 = definition.computedTop + definition.computedHeight;\n            x1 = this.seriesClipRect.x;\n            x2 = x1 + this.seriesClipRect.width;\n            definitionName = 'Row';\n        }\n        else {\n            definition = definition;\n            x1 = x2 = definition.computedLeft;\n            y1 = this.seriesClipRect.y;\n            y2 = y1 + this.seriesClipRect.height;\n            definitionName = 'Column';\n        }\n        optionsLine = {\n            'id': chart.element.id + '_AxisBottom_' + definitionName + index,\n            x1: x1,\n            y1: y1,\n            x2: x2,\n            y2: y2,\n            'stroke-width': definition.border.width,\n            'stroke': definition.border.color\n        };\n        this.htmlObject = chart.renderer.drawLine(optionsLine);\n        this.element.appendChild(this.htmlObject);\n    };\n    /**\n     * To render the axis line\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {number} plotX plotX\n     * @param {number} plotY plotY\n     * @param {Element} parent parent\n     * @param {Rect} rect rect\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.drawAxisLine = function (axis, index, plotX, plotY, parent, rect) {\n        var chart = this.chart;\n        var optionsLine = {};\n        var element = getElement(chart.element.id + 'AxisLine_' + index);\n        var direction = element ? element.getAttribute('d') : '';\n        element = null;\n        optionsLine = {\n            'id': chart.element.id + 'AxisLine_' + index,\n            'd': 'M ' + (rect.x - plotX) + ' ' + (rect.y - plotY) +\n                ' L ' + (rect.x + rect.width + plotX) + ' ' + (rect.y + rect.height + plotY),\n            'stroke-dasharray': axis.lineStyle.dashArray,\n            'stroke-width': axis.lineStyle.width,\n            'stroke': axis.lineStyle.color || chart.themeStyle.axisLine\n        };\n        this.htmlObject = chart.renderer.drawPath(optionsLine);\n        appendChildElement(chart.enableCanvas, parent, this.htmlObject, chart.redraw, true, 'x', 'y', null, direction);\n    };\n    /**\n     * To render the yAxis grid line\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {Element} parent parent\n     * @param {Rect} rect rect\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.drawYAxisGridLine = function (axis, index, parent, rect) {\n        var isLogAxis = axis.valueType === 'Logarithmic';\n        var isCategoryAxis = axis.valueType.indexOf('Category') > -1;\n        var tempInterval;\n        var pointY = 0;\n        var majorGrid = '';\n        var majorTick = '';\n        var minorGridDirection;\n        var isOpposed = axis.isAxisOpposedPosition;\n        var tickSize = isOpposed ? axis.majorTickLines.height : -axis.majorTickLines.height;\n        var axisLineSize = (isOpposed) ? axis.lineStyle.width * 0.5 : -axis.lineStyle.width * 0.5;\n        var ticksbwtLabel = (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') ?\n            0.5 : 0;\n        var scrollBarHeight = isNullOrUndefined(axis.crossesAt) ? isOpposed ? axis.scrollBarHeight :\n            -axis.scrollBarHeight : 0;\n        var isTickInside = axis.tickPosition === 'Inside';\n        var ticks = isTickInside ? (rect.x - tickSize - axisLineSize) : (rect.x + tickSize + axisLineSize + scrollBarHeight);\n        var length = axis.visibleLabels.length;\n        var chartThemeStyle = this.chart.themeStyle;\n        if (axis.valueType.indexOf('Category') > -1 && axis.labelPlacement === 'BetweenTicks' && length > 0) {\n            length += 1;\n        }\n        var minorGridLines = axis.minorGridLines;\n        var minorTickLines = axis.minorTickLines;\n        //Gridlines\n        for (var i = 0; i < length; i++) {\n            tempInterval = !axis.visibleLabels[i] ? (axis.visibleLabels[i - 1].value + axis.visibleRange.interval) - ticksbwtLabel\n                : axis.visibleLabels[i].value - ticksbwtLabel;\n            pointY = valueToCoefficient(tempInterval, axis) * rect.height;\n            pointY = (pointY * -1) + (rect.y + rect.height);\n            if (pointY >= rect.y && (rect.y + rect.height) >= pointY) {\n                if ((inside(tempInterval, axis.visibleRange)) || this.isBorder(axis, i, pointY)) {\n                    majorGrid = 'M ' + this.seriesClipRect.x + ' ' + (pointY) +\n                        ' L ' + (this.seriesClipRect.x + this.seriesClipRect.width) + ' ' + pointY;\n                    this.renderGridLine(axis, index, majorGrid, axis.majorGridLines, '_MajorGridLine_', i, this.element, chartThemeStyle.majorGridLine, axis.majorGridLines.dashArray);\n                }\n                majorTick = 'M ' + (rect.x + axisLineSize + (isTickInside ? scrollBarHeight : 0)) + ' ' + pointY +\n                    ' L ' + (ticks) + ' ' + pointY;\n                this.renderGridLine(axis, index, majorTick, axis.majorTickLines, '_MajorTickLine_', i, parent, chartThemeStyle.majorTickLine);\n                if ((minorGridLines.width > 0 || minorTickLines.width > 0) && axis.minorTicksPerInterval > 0) {\n                    if (i === 0 && isZoomSet(axis) && !isLogAxis && !isCategoryAxis) {\n                        this.renderMinorGridOnZooming(axis, tempInterval, rect, i, index, chartThemeStyle, parent);\n                    }\n                    minorGridDirection = this.drawAxisMinorLine(axis, tempInterval, rect, i);\n                    this.renderGridLine(axis, index, minorGridDirection[0], minorGridLines, '_MinorGridLine_', i, this.element, chartThemeStyle.minorGridLine, minorGridLines.dashArray);\n                    this.renderGridLine(axis, index, minorGridDirection[1], minorTickLines, '_MinorTickLine_', i, parent, chartThemeStyle.minorTickLine);\n                    if (i === length - 1 && isZoomSet(axis) && isLogAxis && !isCategoryAxis) {\n                        this.renderMinorGridOnZooming(axis, (tempInterval + axis.visibleRange.interval), rect, i, index, chartThemeStyle, parent);\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * To check the border of the axis\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {number} value value\n     * @returns {boolean} check the border of the axis\n     */\n    CartesianAxisLayoutPanel.prototype.isBorder = function (axis, index, value) {\n        var border = this.chart.chartArea.border;\n        var rect = this.seriesClipRect;\n        var orientation = axis.orientation;\n        var start = (orientation === 'Horizontal') ? rect.x : rect.y;\n        var size = (orientation === 'Horizontal') ? rect.width : rect.height;\n        var startIndex = (orientation === 'Horizontal') ? 0 : axis.visibleLabels.length - 1;\n        var endIndex = (orientation === 'Horizontal') ? axis.visibleLabels.length - 1 : 0;\n        if (axis.plotOffset > 0) {\n            return true;\n        }\n        else if ((value === start || value === (start + size)) && (border.width <= 0 || border.color === 'transparent')) {\n            return true;\n        }\n        else if ((value !== start && index === startIndex) || (value !== (start + size) && index === endIndex)) {\n            return true;\n        }\n        return false;\n    };\n    /**\n     * To render the yAxis label\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {Element} parent parent\n     * @param {Rect} rect rect\n     * @returns {void}\n     * @private\n     */\n    CartesianAxisLayoutPanel.prototype.drawYAxisLabels = function (axis, index, parent, rect) {\n        var chart = this.chart;\n        var label;\n        var pointX = 0;\n        var pointY = 0;\n        var elementSize;\n        var labelSpace = axis.labelPadding;\n        var options;\n        var isAxisBreakLabel;\n        var isLabelInside = axis.labelPosition === 'Inside';\n        var isOpposed = axis.isAxisOpposedPosition;\n        var tickSpace = axis.labelPosition === axis.tickPosition ? axis.majorTickLines.height : 0;\n        var padding = tickSpace + labelSpace + axis.lineStyle.width * 0.5;\n        var angle = axis.angle % 360;\n        padding = (isOpposed) ? padding : -padding;\n        var labelElement = chart.renderer.createGroup({ id: chart.element.id + 'AxisLabels' + index });\n        var scrollBarHeight = isNullOrUndefined(axis.crossesAt) ? axis.scrollBarHeight * (isOpposed ? 1 : -1) : 0;\n        var textHeight;\n        var textPadding;\n        var maxLineWidth;\n        var pixel = 10;\n        var isInverse = axis.isAxisInverse;\n        var previousEnd = isInverse ? rect.y : (rect.y + rect.height);\n        var labelPadding;\n        var intervalLength;\n        var labelHeight;\n        var yAxisLabelX;\n        var isLabelOnAxisLineLeft = ((!isOpposed && !isLabelInside) || (isOpposed && isLabelInside));\n        if (isLabelInside) {\n            labelPadding = !isLabelOnAxisLineLeft ? -padding : padding;\n        }\n        else {\n            labelPadding = !isLabelOnAxisLineLeft ? -padding + scrollBarHeight : padding + scrollBarHeight;\n        }\n        var sizeWidth = [];\n        var breakLabelSizeWidth = [];\n        axis.visibleLabels.map(function (item) {\n            sizeWidth.push(item.size['width']);\n            breakLabelSizeWidth.push(item.breakLabelSize['width']);\n        });\n        var LabelMaxWidth = Math.max.apply(Math, sizeWidth);\n        var breakLabelMaxWidth = Math.max.apply(Math, breakLabelSizeWidth);\n        for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {\n            label = axis.visibleLabels[i];\n            isAxisBreakLabel = isBreakLabel(axis.visibleLabels[i].originalText);\n            elementSize = isAxisBreakLabel ? axis.visibleLabels[i].breakLabelSize : axis.visibleLabels[i].size;\n            pointY = (valueToCoefficient(axis.visibleLabels[i].value, axis) * rect.height) + (chart.stockChart ? 7 : 0);\n            pointY = Math.floor((pointY * -1) + (rect.y + rect.height));\n            textHeight = ((elementSize.height / 8) * axis.visibleLabels[i].text.length / 2);\n            textPadding = ((elementSize.height / 4) * 3) + 3;\n            intervalLength = rect.height / axis.visibleLabels.length;\n            labelHeight = ((axis.labelIntersectAction === 'Trim' || axis.labelIntersectAction === 'Wrap') && angle !== 0 &&\n                elementSize.width > intervalLength) ? intervalLength : elementSize.width;\n            pointY = (isAxisBreakLabel ? (axis.labelPosition === 'Inside' ? (pointY - (elementSize.height / 2) - textHeight + textPadding)\n                : (pointY - textHeight)) : (axis.labelPosition === 'Inside' ? pointY + textPadding : pointY));\n            if (axis.majorGridLines.width > axis.majorTickLines.width) {\n                maxLineWidth = axis.majorGridLines.width;\n            }\n            else {\n                maxLineWidth = axis.majorTickLines.width;\n            }\n            if (axis.labelStyle.textAlignment === 'Far') {\n                pointY = pointY - maxLineWidth - pixel;\n            }\n            else if (axis.labelStyle.textAlignment === 'Near') {\n                pointY = pointY + maxLineWidth + pixel;\n            }\n            else if (axis.labelStyle.textAlignment === 'Center') {\n                // eslint-disable-next-line no-self-assign\n                pointY = pointY;\n            }\n            // label X value adjustment (Start)\n            if (isLabelInside) {\n                yAxisLabelX = labelPadding + ((angle === 0 ? elementSize.width : (isAxisBreakLabel ? breakLabelMaxWidth : LabelMaxWidth)) / 2);\n            }\n            else {\n                yAxisLabelX = labelPadding - ((angle === 0 ? elementSize.width : (isAxisBreakLabel ? breakLabelMaxWidth : LabelMaxWidth)) / 2);\n            }\n            pointX = isOpposed ? (rect.x - yAxisLabelX) : (rect.x + yAxisLabelX);\n            yAxisLabelX = labelPadding;\n            options = new TextOption(chart.element.id + index + '_AxisLabel_' + i, pointX, pointY, 'middle', label.text, '', 'middle');\n            switch (axis.edgeLabelPlacement) {\n                case 'None':\n                    break;\n                case 'Hide':\n                    if (((i === 0 || (isInverse && i === len - 1)) && options.y > rect.y) ||\n                        (((i === len - 1) || (isInverse && i === 0)) && options.y - elementSize.height * 0.5 < rect.y)) {\n                        options.text = '';\n                    }\n                    break;\n                case 'Shift':\n                    if ((i === 0 || (isInverse && i === len - 1)) && options.y > rect.y) {\n                        options.y = pointY = rect.y + rect.height;\n                    }\n                    else if (((i === len - 1) || (isInverse && i === 0)) && (options.y - elementSize.height * 0.5 < rect.y)) {\n                        options.y = pointY = rect.y + elementSize.height * 0.5;\n                    }\n                    break;\n            }\n            // ------- Hide Calculation (Start) -------------\n            var previousYValue = options.y;\n            var currentYValue = options.y - labelHeight;\n            if (isAxisBreakLabel) {\n                previousYValue = (options.y - (labelHeight / 2));\n                currentYValue = options.y + (labelHeight / 2);\n            }\n            if ((angle === 90 || angle === 270) && axis.labelIntersectAction === 'Hide' && i !== 0 &&\n                (!isInverse ? previousYValue >= previousEnd : currentYValue <= previousEnd)) {\n                continue;\n            }\n            previousEnd = isInverse ? previousYValue : currentYValue;\n            // ------- Hide Calculation (End) -------------\n            options.transform = 'rotate(' + angle + ',' + pointX + ',' + pointY + ')';\n            textElement(chart.renderer, options, label.labelStyle, label.labelStyle.color || chart.themeStyle.axisLabel, labelElement, false, chart.redraw, true, true, null, null, null, null, chart.enableCanvas);\n        }\n        if (!this.chart.enableCanvas) {\n            if (!chart.delayRedraw) {\n                appendChildElement(chart.enableCanvas, parent, labelElement, chart.redraw);\n            }\n            else if (axis.visible && axis.internalVisibility) {\n                this.createZoomingLabel(this.chart, labelElement, axis, index, rect);\n            }\n        }\n    };\n    /**\n     * To get X value based on lineBreakAlignment for Y axis line break labels only.\n     *\n     * @param {number} x text x position\n     * @param {Axis} axis y axis values\n     * @param {number} textWidth axis label width\n     * @returns {number} returns suitable axis label x position\n     */\n    CartesianAxisLayoutPanel.prototype.getAxisLabelXvalue = function (x, axis, textWidth) {\n        var anchor = axis.lineBreakAlignment;\n        var isLabelInside = axis.labelPosition === 'Inside';\n        var isOpposed = axis.isAxisOpposedPosition;\n        if ((isOpposed && isLabelInside) || (!isOpposed && !isLabelInside)) {\n            return (anchor === 'Right' ? x : (anchor === 'Center' ? (x - textWidth / 2) : (x - textWidth)));\n        }\n        else {\n            return (anchor === 'Left' ? x : (anchor === 'Center' ? (x + textWidth / 2) : (x + textWidth)));\n        }\n    };\n    /**\n     * To render the yAxis label border.\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {Element} parent parent\n     * @param {Rect} rect rect\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.drawYAxisBorder = function (axis, index, parent, rect) {\n        if (axis.border.width > 0) {\n            var startY = void 0;\n            var pointY = void 0;\n            var scrollBarHeight = axis.labelPosition === 'Outside' ? axis.scrollBarHeight : 0;\n            var isOpposed = axis.isAxisOpposedPosition;\n            scrollBarHeight = (isOpposed ? 1 : -1) * scrollBarHeight;\n            var gap = (rect.height / axis.visibleRange.delta) * (axis.valueType === 'DateTime' ? axis.dateTimeInterval\n                : axis.visibleRange.interval);\n            var endY = void 0;\n            var length_1 = axis.maxLabelSize.width + 10 + ((axis.tickPosition === axis.labelPosition) ?\n                axis.majorTickLines.height : 0);\n            var labelBorder = '';\n            var ticksbwtLabel = (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') ? -0.5 : 0;\n            var endX = ((isOpposed && axis.labelPosition === 'Inside') || (!isOpposed\n                && axis.labelPosition === 'Outside')) ? rect.x - length_1 + scrollBarHeight : rect.x + length_1 + scrollBarHeight;\n            for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {\n                pointY = valueToCoefficient(axis.visibleLabels[i].value + ticksbwtLabel, axis);\n                pointY = (axis.isAxisInverse ? (1 - pointY) : pointY) * rect.height;\n                if (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') {\n                    startY = (pointY * -1) + (rect.y + rect.height);\n                    endY = (pointY * -1) - (gap) + (rect.y + rect.height);\n                }\n                else {\n                    startY = (pointY * -1) + gap / 2 + (rect.y + rect.height);\n                    endY = (pointY * -1) - gap / 2 + (rect.y + rect.height);\n                }\n                switch (axis.border.type) {\n                    case 'Rectangle':\n                    case 'WithoutTopBorder':\n                        if (startY > (rect.y + rect.height)) {\n                            labelBorder += ('M' + ' ' + endX + ' ' + (rect.y + rect.height) + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ');\n                        }\n                        else if (Math.floor(rect.y) > (endY)) {\n                            labelBorder += ('M' + ' ' + (rect.x + scrollBarHeight) + ' ' + startY + ' ' + 'L' + ' ' + endX\n                                + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + (rect.y) + ' ');\n                        }\n                        else {\n                            labelBorder += ('M' + ' ' + (rect.x + scrollBarHeight) + ' ' + startY + ' ' + 'L' + ' ' + endX +\n                                ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ');\n                            if (i === axis.visibleLabels.length - 1) {\n                                labelBorder += ('M' + ' ' + (rect.x + scrollBarHeight) + ' ' + endY + ' ' + 'L' + ' ' +\n                                    endX + ' ' + endY + ' ');\n                            }\n                        }\n                        break;\n                    case 'WithoutTopandBottomBorder':\n                        if (!(startY > rect.y + rect.height) && !((endY) < Math.floor(rect.y))) {\n                            labelBorder += ('M' + ' ' + (rect.x + scrollBarHeight) + ' ' + startY + ' ' + 'L' + ' ' + endX +\n                                ' ' + startY + ' ' + 'M' + ' ' + endX + ' ' + endY + ' ' +\n                                'L' + ' ' + (rect.x + scrollBarHeight) + ' ' + endY);\n                        }\n                        break;\n                }\n            }\n            labelBorder += (axis.border.type === 'Rectangle') ? ('M' + ' ' + (rect.x + scrollBarHeight) + ' ' + rect.y + ' ' + 'L' + ' ' +\n                (rect.x + scrollBarHeight) + ' ' + (rect.y + rect.height) + ' ') : '';\n            if (labelBorder !== '') {\n                this.createAxisBorderElement(axis, index, labelBorder, parent);\n            }\n        }\n        if (axis.multiLevelLabels.length > 0 && this.chart.multiLevelLabelModule) {\n            this.chart.multiLevelLabelModule.renderYAxisMultiLevelLabels(axis, index, parent, rect);\n        }\n    };\n    /**\n     * To render the yAxis title\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {Element} parent parent\n     * @param {Rect} rect rect\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.drawYAxisTitle = function (axis, index, parent, rect) {\n        if (axis.title) {\n            var chart = this.chart;\n            var isOpposed = axis.isAxisOpposedPosition;\n            var labelRotation = isOpposed ? 90 : -90;\n            var padding = (axis.tickPosition === 'Inside' ? 0 : axis.majorTickLines.height + axis.titlePadding) +\n                (axis.labelPosition === 'Inside' ? 0 :\n                    (axis.maxLabelSize.width + axis.multiLevelLabelHeight + this.padding));\n            padding = isOpposed ? padding + axis.scrollBarHeight : -padding - axis.scrollBarHeight;\n            var x = rect.x + padding;\n            var y = rect.y + rect.height * 0.5;\n            var titleSize = (axis.titleSize.height * (axis.titleCollection.length - 1));\n            var options = new TextOption(chart.element.id + '_AxisTitle_' + index, x, y - axis.labelPadding - titleSize, 'middle', axis.titleCollection, 'rotate(' + labelRotation + ',' + (x) + ',' + (y) + ')', null, labelRotation);\n            var element = textElement(chart.renderer, options, axis.titleStyle, axis.titleStyle.color || chart.themeStyle.axisTitle, parent, null, null, null, null, null, null, null, null, chart.enableCanvas);\n            element.setAttribute('tabindex', axis.tabIndex.toString());\n            element.setAttribute('aria-label', axis.description || axis.title);\n        }\n    };\n    /**\n     * xAxis grid line calculation performed here\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {Element} parent parent\n     * @param {Rect} rect rect\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.drawXAxisGridLine = function (axis, index, parent, rect) {\n        var isLogAxis = axis.valueType === 'Logarithmic';\n        var isCategoryAxis = axis.valueType.indexOf('Category') > -1;\n        var tempInterval;\n        var pointX = 0;\n        var majorGrid = '';\n        var majorTick = '';\n        var minorDirection;\n        var isOpposed = axis.isAxisOpposedPosition;\n        var tickSize = (isOpposed) ? -axis.majorTickLines.height : axis.majorTickLines.height;\n        var axisLineSize = (isOpposed) ? -axis.lineStyle.width * 0.5 : axis.lineStyle.width * 0.5;\n        var scrollBarHeight = isNullOrUndefined(axis.crossesAt) ? isOpposed ? -axis.scrollBarHeight :\n            axis.scrollBarHeight : 0;\n        var ticksbwtLabel = (axis.valueType.indexOf('Category') > -1 && axis.labelPlacement === 'BetweenTicks') ?\n            0.5 : 0;\n        var length = axis.visibleLabels.length;\n        var isTickInside = axis.tickPosition === 'Inside';\n        var ticks = isTickInside ? (rect.y - tickSize - axisLineSize) : (rect.y + tickSize + axisLineSize + scrollBarHeight);\n        var chartThemeStyle = this.chart.themeStyle;\n        if (axis.valueType.indexOf('Category') > -1 && length > 0 && axis.labelPlacement === 'BetweenTicks') {\n            length += 1;\n        }\n        //Gridlines\n        for (var i = 0; i < length; i++) {\n            if (axis.valueType !== 'DateTimeCategory') {\n                tempInterval = axis.visibleLabels[i] ? axis.visibleLabels[i].value - ticksbwtLabel\n                    : (axis.visibleLabels[i - 1].value + axis.visibleRange.interval) - ticksbwtLabel;\n            }\n            else {\n                tempInterval = axis.visibleLabels[i] ?\n                    axis.visibleLabels[i].value - ticksbwtLabel : axis.visibleRange.max;\n            }\n            pointX = (valueToCoefficient(tempInterval, axis) * rect.width) + rect.x;\n            if (pointX >= rect.x && (rect.x + rect.width) >= pointX) {\n                if (inside(tempInterval, axis.visibleRange) || this.isBorder(axis, i, pointX)) {\n                    majorGrid = 'M ' + pointX + ' ' + (this.seriesClipRect.y + this.seriesClipRect.height) +\n                        ' L ' + pointX + ' ' + this.seriesClipRect.y;\n                    this.renderGridLine(axis, index, majorGrid, axis.majorGridLines, '_MajorGridLine_', i, this.element, chartThemeStyle.majorGridLine, axis.majorGridLines.dashArray);\n                }\n                majorTick = 'M ' + (pointX) + ' ' + (rect.y + axisLineSize + (isTickInside ? scrollBarHeight : 0))\n                    + ' L ' + (pointX) + ' ' + ticks;\n                this.renderGridLine(axis, index, majorTick, axis.majorTickLines, '_MajorTickLine_', i, parent, chartThemeStyle.majorTickLine);\n                if (axis.minorTicksPerInterval > 0 && (axis.minorGridLines.width > 0 || axis.minorTickLines.width > 0)) {\n                    if (i === 0 && isZoomSet(axis) && !isLogAxis && !isCategoryAxis) {\n                        this.renderMinorGridOnZooming(axis, tempInterval, rect, i, index, chartThemeStyle, parent);\n                    }\n                    minorDirection = this.drawAxisMinorLine(axis, tempInterval, rect, i);\n                    this.renderGridLine(axis, index, minorDirection[0], axis.minorGridLines, '_MinorGridLine_', i, this.element, chartThemeStyle.minorGridLine, axis.minorGridLines.dashArray);\n                    this.renderGridLine(axis, index, minorDirection[1], axis.minorTickLines, '_MinorTickLine_', i, parent, chartThemeStyle.minorTickLine);\n                    if (i === length - 1 && isZoomSet(axis) && isLogAxis && !isCategoryAxis) {\n                        this.renderMinorGridOnZooming(axis, (tempInterval + axis.visibleRange.interval), rect, i, index, chartThemeStyle, parent);\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * To render missing minor grid lines while zooming\n     *\n     * @param {Axis} axis axis\n     * @param {number} tempInterval tempInterval\n     * @param {Rect} rect rect\n     * @param {number} i i\n     * @param {number} index index\n     * @param {IThemeStyle} chartThemeStyle chartThemeStyle\n     * @param {Element} parent parent\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.renderMinorGridOnZooming = function (axis, tempInterval, rect, i, index, chartThemeStyle, parent) {\n        var minorDirection = this.drawAxisMinorLine(axis, tempInterval, rect, i, true);\n        this.renderGridLine(axis, index, minorDirection[0], axis.minorGridLines, '_MinorGridLine_', -1, this.element, chartThemeStyle.minorGridLine, axis.minorGridLines.dashArray);\n        this.renderGridLine(axis, index, minorDirection[1], axis.minorTickLines, '_MinorTickLine_', -1, parent, chartThemeStyle.minorTickLine);\n    };\n    /**\n     * To calcualte the axis minor line\n     *\n     * @param {Axis} axis axis\n     * @param {number} tempInterval tempInterval\n     * @param {Rect} rect rect\n     * @param {number} labelIndex labelIndex\n     * @param {boolean} isFirstLabel isFirstLabel\n     * @returns {string[]} axis minor line path\n     */\n    CartesianAxisLayoutPanel.prototype.drawAxisMinorLine = function (axis, tempInterval, rect, labelIndex, isFirstLabel) {\n        var value = tempInterval;\n        var coor = 0;\n        var position = 0;\n        var range = axis.visibleRange;\n        var isTickInside = axis.tickPosition === 'Inside';\n        var direction = [];\n        var tickSize = axis.isAxisOpposedPosition ? -axis.minorTickLines.height : axis.minorTickLines.height;\n        var logStart;\n        var logEnd;\n        var logInterval = 1;\n        var logPosition = 1;\n        var ticksX = isTickInside ? (rect.y - tickSize) : (rect.y + tickSize);\n        var ticksY = isTickInside ? (rect.x + tickSize) : (rect.x - tickSize);\n        var minorGird = '';\n        var minorTick = '';\n        var isInverse = axis.isAxisInverse;\n        if (axis.valueType === 'Logarithmic') {\n            logStart = Math.pow(axis.logBase, value - range.interval);\n            logEnd = Math.pow(axis.logBase, value);\n            logInterval = (logEnd - logStart) / (axis.minorTicksPerInterval + 1);\n            logPosition = logStart + logInterval;\n        }\n        if (axis.orientation === 'Horizontal') {\n            for (var j = 0; j < axis.minorTicksPerInterval; j++) {\n                value = this.findLogNumeric(axis, logPosition, value, labelIndex, isFirstLabel);\n                logPosition += logInterval;\n                if (inside(value, range)) {\n                    position = ((value - range.min) / (range.max - range.min));\n                    position = Math.ceil((isInverse ? (1 - position) : position) * rect.width);\n                    coor = (Math.floor(position + rect.x));\n                    minorGird = minorGird.concat('M' + ' ' + coor + ' ' + (this.seriesClipRect.y)\n                        + 'L ' + coor + ' ' + (this.seriesClipRect.y + this.seriesClipRect.height));\n                    coor = (Math.floor(position + rect.x));\n                    minorTick = minorTick.concat('M' + ' ' + coor + ' ' + (rect.y)\n                        + 'L ' + coor + ' ' + (ticksX + axis.scrollBarHeight));\n                }\n            }\n        }\n        else {\n            for (var j = 0; j < axis.minorTicksPerInterval; j++) {\n                value = this.findLogNumeric(axis, logPosition, value, labelIndex, isFirstLabel);\n                if (inside(value, range)) {\n                    position = ((value - range.min) / (range.max - range.min));\n                    position = Math.ceil(((isInverse ? (1 - position) : position)) * rect.height) * -1; // For inversed axis\n                    coor = (Math.floor(position + rect.y + rect.height));\n                    minorGird = minorGird.concat('M' + ' ' + (this.seriesClipRect.x) + ' ' + coor\n                        + 'L ' + (this.seriesClipRect.x + this.seriesClipRect.width) + ' ' + coor + ' ');\n                    coor = (Math.floor(position + rect.y + rect.height));\n                    minorTick = minorTick.concat('M' + ' ' + rect.x + ' ' + coor + 'L ' + (ticksY - axis.scrollBarHeight) +\n                        ' ' + coor + ' ');\n                }\n                logPosition += logInterval;\n            }\n        }\n        direction.push(minorGird);\n        direction.push(minorTick);\n        return direction;\n    };\n    /**\n     * To find the numeric value of the log\n     *\n     * @param {Axis} axis axis\n     * @param {number} logPosition logPosition\n     * @param {number} value value\n     * @param {number} labelIndex labelIndex\n     * @param {boolean} isFirstLabel isFirstLabel\n     * @returns {number} value\n     */\n    CartesianAxisLayoutPanel.prototype.findLogNumeric = function (axis, logPosition, value, labelIndex, isFirstLabel) {\n        var range = axis.visibleRange;\n        var tempValue;\n        if (axis.valueType === 'Logarithmic') {\n            value = logBase(logPosition, axis.logBase);\n        }\n        else if (axis.valueType === 'DateTime') {\n            tempValue = axis.dateTimeInterval / (axis.minorTicksPerInterval + 1);\n            value = isFirstLabel ? (value - tempValue) : (value + tempValue);\n        }\n        else if (axis.valueType === 'DateTimeCategory') {\n            var padding = axis.labelPlacement === 'BetweenTicks' ? 0.5 : 0;\n            value += ((axis.visibleLabels[labelIndex + 1] ?\n                axis.visibleLabels[labelIndex + 1].value - padding : axis.visibleRange.max) -\n                (axis.visibleLabels[labelIndex] ?\n                    axis.visibleLabels[labelIndex].value - padding : axis.visibleRange.min)) /\n                (axis.minorTicksPerInterval + 1);\n        }\n        else {\n            tempValue = range.interval / (axis.minorTicksPerInterval + 1);\n            value = isFirstLabel ? (value - tempValue) : (value + tempValue);\n        }\n        return value;\n    };\n    /**\n     * To render the xAxis Labels\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {Element} parent parent\n     * @param {Rect} rect rect\n     * @returns {void}\n     * @private\n     */\n    CartesianAxisLayoutPanel.prototype.drawXAxisLabels = function (axis, index, parent, rect) {\n        var chart = this.chart;\n        var pointX = 0;\n        var pointY = 0;\n        var labelSpace = axis.labelPadding;\n        var labelHeight;\n        var elementSize;\n        var labelPadding;\n        var anchor;\n        var pixel = 10;\n        var labelElement = chart.renderer.createGroup({ id: chart.element.id + 'AxisLabels' + index });\n        var islabelInside = axis.labelPosition === 'Inside';\n        var isOpposed = axis.isAxisOpposedPosition;\n        var tickSpace = axis.labelPosition === axis.tickPosition ? axis.majorTickLines.height : 0;\n        var padding = tickSpace + labelSpace + axis.lineStyle.width * 0.5;\n        var angle = axis.angle % 360;\n        var isHorizontalAngle = (angle === 0 || angle === -180 || angle === 180);\n        var options;\n        var labelWidth;\n        var isInverse = axis.isAxisInverse;\n        var previousEnd = isInverse ? (rect.x + rect.width) : rect.x;\n        var width = 0;\n        var length = axis.visibleLabels.length;\n        var intervalLength;\n        var label;\n        var isAxisBreakLabel;\n        var scrollBarHeight = axis.scrollbarSettings.enable || (!islabelInside && isNullOrUndefined(axis.crossesAt)\n            && (axis.zoomFactor < 1 || axis.zoomPosition > 0)) ? axis.scrollBarHeight : 0;\n        var newPoints = [];\n        var isRotatedLabelIntersect = false;\n        padding += (angle === 90 || angle === 270 || angle === -90 || angle === -270) ? (islabelInside ? 5 : -5) : 0;\n        var isLabelUnderAxisLine = ((!isOpposed && !islabelInside) || (isOpposed && islabelInside));\n        var isEndAnchor = isLabelUnderAxisLine ?\n            ((360 >= angle && angle >= 180) || (-1 >= angle && angle >= -180)) :\n            ((1 <= angle && angle <= 180) || (-181 >= angle && angle >= -360));\n        for (var i = 0, len = length; i < len; i++) {\n            label = axis.visibleLabels[i];\n            isAxisBreakLabel = isBreakLabel(label.originalText);\n            pointX = (valueToCoefficient(label.value, axis) * rect.width) + rect.x;\n            elementSize = label.size;\n            intervalLength = rect.width / length;\n            labelWidth = isAxisBreakLabel ? label.breakLabelSize.width : elementSize.width;\n            width = ((axis.labelIntersectAction === 'Trim' || axis.labelIntersectAction === 'Wrap') && angle === 0 &&\n                labelWidth > intervalLength) ? intervalLength : labelWidth;\n            labelHeight = elementSize.height / 4;\n            pointX -= (isAxisBreakLabel || angle !== 0) ? 0 : (width / 2);\n            // label X value adjustment for label rotation (Start)\n            if (angle !== 0) {\n                if (isAxisBreakLabel) {\n                    pointX -= axis.lineBreakAlignment === 'Left' ? (label.breakLabelSize.width / 2) : axis.lineBreakAlignment === 'Right' ?\n                        -(label.breakLabelSize.width / 2) : 0;\n                }\n                else {\n                    pointX -= (angle === -90 || angle === 270 ? -labelHeight : (angle === 90 || angle === -270) ? labelHeight : 0);\n                }\n            }\n            // label X value adjustment for label rotation (End)\n            if (axis.labelStyle.textAlignment === 'Far') {\n                pointX = pointX + width - pixel;\n            }\n            else if (axis.labelStyle.textAlignment === 'Near') {\n                pointX = pointX - width + pixel;\n            }\n            else if (axis.labelStyle.textAlignment === 'Center') {\n                // eslint-disable-next-line no-self-assign\n                pointX = pointX;\n            }\n            // For line break label alignment like left, right & center in angle 0\n            if (isAxisBreakLabel && axis.lineBreakAlignment !== 'Center' && angle === 0) {\n                pointX += axis.lineBreakAlignment === 'Left' ? -(width / 2) : (width / 2);\n            }\n            var paddingForBreakLabel = isAxisBreakLabel ?\n                (isHorizontalAngle ? (elementSize.height) : (label.breakLabelSize.width / 2)) : 0;\n            padding = isAxisBreakLabel ? (tickSpace + labelSpace + axis.lineStyle.width * 0.5) : padding;\n            // label Y value adjustment (Start)\n            if (islabelInside && angle) {\n                if (isAxisBreakLabel) {\n                    pointY = isOpposed ? (rect.y + padding + (paddingForBreakLabel)) : (rect.y - padding - (paddingForBreakLabel));\n                }\n                else {\n                    pointY = isOpposed ? (rect.y + padding + labelHeight) : (rect.y - padding - labelHeight);\n                }\n            }\n            else {\n                if (isAxisBreakLabel) {\n                    labelPadding = !isLabelUnderAxisLine ? -(padding + scrollBarHeight + (paddingForBreakLabel)) :\n                        padding + scrollBarHeight + (angle ? paddingForBreakLabel : (3 * labelHeight));\n                }\n                else {\n                    labelPadding = !isLabelUnderAxisLine ?\n                        -(padding + scrollBarHeight + (angle ? labelHeight : (label.index > 1 ? (2 * labelHeight) : 0))) :\n                        padding + scrollBarHeight + ((angle ? 1 : 3) * labelHeight);\n                }\n                pointY = (rect.y + (labelPadding * label.index));\n            }\n            // label Y value adjustment (End)\n            if (isAxisBreakLabel) {\n                anchor = this.getAnchor(axis); // for break label self alignment\n            }\n            else {\n                anchor = (chart.enableRtl) ? ((isEndAnchor) ? '' : 'end') : (chart.isRtlEnabled || isEndAnchor) ? 'end' : '';\n            }\n            options = new TextOption(chart.element.id + index + '_AxisLabel_' + i, pointX, pointY, anchor);\n            if (axis.edgeLabelPlacement && (angle === 0)) {\n                switch (axis.edgeLabelPlacement) {\n                    case 'None':\n                        break;\n                    case 'Hide':\n                        if (((i === 0 || (isInverse && i === len - 1)) && options.x < rect.x) ||\n                            ((i === len - 1 || (isInverse && i === 0)) && (options.x + width > rect.x + rect.width))) {\n                            continue;\n                        }\n                        break;\n                    case 'Shift':\n                        if ((i === 0 || (isInverse && i === len - 1)) && options.x < rect.x) {\n                            intervalLength -= (rect.x - options.x);\n                            options.x = pointX = rect.x;\n                        }\n                        else if ((i === len - 1 || (isInverse && i === 0)) && ((options.x + width) > rect.x + rect.width)) {\n                            if (elementSize.width > intervalLength && axis.labelIntersectAction === 'Trim') {\n                                intervalLength -= (options.x + width - (rect.x + rect.width));\n                            }\n                            else {\n                                intervalLength = width;\n                            }\n                            options.x = pointX = rect.x + rect.width - intervalLength;\n                        }\n                        break;\n                }\n            }\n            options.text = this.getLabelText(label, axis, intervalLength);\n            // ------- Hide Calculation (Start) -------------\n            // Currect label actual start value (Start)\n            var xValue = void 0;\n            var xValue2 = void 0;\n            if (isAxisBreakLabel && angle === 0) {\n                if (axis.lineBreakAlignment === 'Right') {\n                    xValue = (options.x - width);\n                    xValue2 = options.x;\n                }\n                else if (axis.lineBreakAlignment === 'Center') {\n                    xValue = (options.x - (width / 2));\n                    xValue2 = options.x + (width / 2);\n                }\n                else {\n                    xValue = options.x;\n                    xValue2 = options.x + width;\n                }\n            }\n            else {\n                xValue = options.x;\n                xValue2 = options.x + width;\n            }\n            // Currect label actual start value (End)\n            if (angle === 0 && axis.labelIntersectAction === 'Hide' && i !== 0 &&\n                (!isInverse ? xValue <= previousEnd : xValue2 >= previousEnd)) {\n                continue;\n            }\n            // Previous label actual end value (Start)\n            if (isAxisBreakLabel) {\n                if (axis.lineBreakAlignment === 'Right') {\n                    previousEnd = isInverse ? (options.x - width) : options.x;\n                }\n                else if (axis.lineBreakAlignment === 'Center') {\n                    previousEnd = isInverse ? (options.x - (width / 2)) : options.x + (width / 2);\n                }\n                else {\n                    previousEnd = isInverse ? options.x : options.x + width;\n                }\n            }\n            else {\n                previousEnd = isInverse ? options.x : options.x + width;\n            }\n            // Previous label actual end value (End)\n            // ------- Hide Calculation (End) -------------\n            // label Rotataion calculation (Start)\n            if (angle !== 0) {\n                var height = void 0;\n                var rect_1 = void 0;\n                if (isAxisBreakLabel) {\n                    var xAdjustment = 0;\n                    var yAdjustment = 0;\n                    height = (label.breakLabelSize.height);\n                    yAdjustment = (label.breakLabelSize.height) - 4; // 4 for label bound correction\n                    // xAdjustment (Start)\n                    if (axis.lineBreakAlignment === 'Center') {\n                        xAdjustment = -(label.breakLabelSize.width / 2);\n                    }\n                    else if (axis.lineBreakAlignment === 'Right') {\n                        xAdjustment = -label.breakLabelSize.width;\n                    }\n                    // xAdjustment (End)\n                    if (isLabelUnderAxisLine) {\n                        yAdjustment = (label.breakLabelSize.height) / (options.text.length + 1);\n                    }\n                    rect_1 = new Rect(options.x + xAdjustment, options.y - (yAdjustment), label.breakLabelSize.width, height);\n                }\n                else {\n                    height = (pointY) - (options.y - ((label.size.height / 2) + 10));\n                    rect_1 = new Rect(options.x, options.y - ((label.size.height / 2) - 5), label.size.width, height);\n                }\n                var rectCoordinates = this.getRectanglePoints(rect_1);\n                var rectCenterX = isAxisBreakLabel ? rect_1.x + (rect_1.width / 2) : pointX;\n                var rectCenterY = isAxisBreakLabel ? rect_1.y + (rect_1.height / 2) : (pointY - (height / 2));\n                if (isAxisBreakLabel) {\n                    options.transform = 'rotate(' + angle + ',' + rectCenterX + ',' + rectCenterY + ')';\n                }\n                else {\n                    options.transform = 'rotate(' + angle + ',' + pointX + ',' + pointY + ')';\n                }\n                newPoints.push(getRotatedRectangleCoordinates(rectCoordinates, rectCenterX, rectCenterY, angle));\n                isRotatedLabelIntersect = false;\n                for (var index_1 = i; index_1 > 0; index_1--) {\n                    if (newPoints[i] && newPoints[index_1 - 1] && isRotatedRectIntersect(newPoints[i], newPoints[index_1 - 1])) {\n                        isRotatedLabelIntersect = true;\n                        newPoints[i] = null;\n                        break;\n                    }\n                }\n            }\n            // label Rotataion calculation (End)\n            textElement(chart.renderer, options, label.labelStyle, label.labelStyle.color || chart.themeStyle.axisLabel, labelElement, (axis.isAxisOpposedPosition !== (axis.labelPosition === 'Inside')), chart.redraw, true, null, null, null, label.size, isRotatedLabelIntersect, chart.enableCanvas);\n        }\n        if (!this.chart.enableCanvas) {\n            if (!chart.delayRedraw) {\n                parent.appendChild(labelElement);\n            }\n            else if (axis.visible && axis.internalVisibility) {\n                this.createZoomingLabel(this.chart, labelElement, axis, index, rect);\n            }\n        }\n    };\n    /**\n     * To get text anchor value for line break labels.\n     *\n     * @param {Axis} axis axis model\n     * @returns {string} returns text anchor\n     */\n    CartesianAxisLayoutPanel.prototype.getAnchor = function (axis) {\n        return (axis.lineBreakAlignment === 'Center' ? 'middle' : (this.chart.enableRtl) ? (axis.lineBreakAlignment === 'Left' ? 'end' : 'start') : (axis.lineBreakAlignment === 'Left' ? 'start' : 'end'));\n    };\n    /**\n     * Get rect coordinates\n     *\n     * @param {Rect} rect rect\n     * @returns {ChartLocation[]} rectangle points\n     */\n    CartesianAxisLayoutPanel.prototype.getRectanglePoints = function (rect) {\n        var point1 = new ChartLocation(rect.x, rect.y);\n        var point2 = new ChartLocation(rect.x + rect.width, rect.y);\n        var point3 = new ChartLocation(rect.x + rect.width, rect.y + rect.height);\n        var point4 = new ChartLocation(rect.x, rect.y + rect.height);\n        return [point1, point2, point3, point4];\n    };\n    /**\n     * To get axis label text\n     *\n     * @param {VisibleLabels} label label\n     * @param {Axis} axis axis\n     * @param {number} intervalLength intervalLength\n     * @returns {string | string[]} label or label collection\n     */\n    CartesianAxisLayoutPanel.prototype.getLabelText = function (label, axis, intervalLength) {\n        if (isBreakLabel(label.originalText)) {\n            var result = [];\n            var str = void 0;\n            for (var index = 0; index < label.text.length; index++) {\n                str = this.findAxisLabel(axis, label.text[index], intervalLength);\n                result.push(str);\n            }\n            return result;\n        }\n        else {\n            return this.findAxisLabel(axis, label.text, intervalLength);\n        }\n    };\n    /**\n     * To render the x-axis label border.\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {Element} parent parent\n     * @param {Rect} axisRect axisRect\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.drawXAxisBorder = function (axis, index, parent, axisRect) {\n        if (axis.border.width > 0) {\n            var scrollBarHeight = axis.labelPosition === 'Outside' ? axis.scrollBarHeight : 0;\n            var isOpposed = axis.isAxisOpposedPosition;\n            var startX = void 0;\n            var startY = axisRect.y + ((isOpposed ? -1 : 1) * scrollBarHeight);\n            var padding = 10;\n            var pointX = void 0;\n            var gap = (axisRect.width / axis.visibleRange.delta) * (axis.valueType === 'DateTime' ? axis.dateTimeInterval\n                : axis.visibleRange.interval);\n            var endX = void 0;\n            var length_2 = axis.maxLabelSize.height +\n                ((axis.tickPosition === axis.labelPosition) ? axis.majorTickLines.height : 0);\n            var labelBorder = '';\n            var ticksbwtLabel = (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') ? -0.5 : 0;\n            var endY = ((isOpposed && axis.labelPosition === 'Inside') ||\n                (!isOpposed && axis.labelPosition === 'Outside')) ?\n                (axisRect.y + length_2 + padding + scrollBarHeight) : (axisRect.y - length_2 - padding - scrollBarHeight);\n            for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {\n                pointX = valueToCoefficient(axis.visibleLabels[i].value + ticksbwtLabel, axis);\n                pointX = (axis.isAxisInverse ? (1 - pointX) : pointX) * axisRect.width;\n                if (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') {\n                    startX = pointX + axisRect.x;\n                    endX = pointX + (gap) + axisRect.x;\n                }\n                else {\n                    startX = pointX - gap * 0.5 + axisRect.x;\n                    endX = pointX + gap * 0.5 + axisRect.x;\n                }\n                switch (axis.border.type) {\n                    case 'Rectangle':\n                    case 'WithoutTopBorder':\n                        if (startX < axisRect.x) {\n                            labelBorder += ('M' + ' ' + axisRect.x + ' ' + endY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ');\n                        }\n                        else if (Math.floor(endX) > axisRect.width + axisRect.x && !(axis.visibleLabels.length === 1)) {\n                            labelBorder += ('M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' + endY + ' ' +\n                                'L' + ' ' + (axisRect.width + axisRect.x) + ' ' + endY + ' ');\n                        }\n                        else {\n                            labelBorder += ('M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' +\n                                endY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ');\n                            if (i === 0) {\n                                labelBorder += ('M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' + endY + ' ' +\n                                    'M ' + startX + ' ' + endY + ' L ' + (axisRect.x) + ' ' + endY);\n                            }\n                            if (i === axis.visibleLabels.length - 1) {\n                                labelBorder += ('M' + ' ' + endX + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ' +\n                                    'M ' + endX + ' ' + endY + ' L ' + (axisRect.width + axisRect.x) + ' ' + endY);\n                            }\n                        }\n                        break;\n                    case 'WithoutTopandBottomBorder':\n                        if (!(startX < axisRect.x) && !(Math.floor(endX) > axisRect.width + axisRect.x)) {\n                            labelBorder += ('M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' + endY + ' ' +\n                                'M ' + endX + ' ' + startY + ' L ' + endX + ' ' + endY);\n                        }\n                        break;\n                }\n            }\n            labelBorder += (axis.border.type === 'Rectangle' ? ('M ' + ' ' + axisRect.x + ' ' + startY + 'L' + ' ' +\n                (axisRect.x + axisRect.width) + ' ' + startY) : '');\n            if (labelBorder !== '') {\n                this.createAxisBorderElement(axis, index, labelBorder, parent);\n            }\n        }\n        if (this.chart.multiLevelLabelModule && axis.multiLevelLabels.length > 0) {\n            this.chart.multiLevelLabelModule.renderXAxisMultiLevelLabels(axis, index, parent, axisRect);\n        }\n    };\n    /**\n     * To create border element of the axis\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {string} labelBorder labelBorder\n     * @param {Element} parent parent\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.createAxisBorderElement = function (axis, index, labelBorder, parent) {\n        var element = getElement(this.chart.element.id + '_BorderLine_' + index);\n        var direction = element ? element.getAttribute('d') : '';\n        var borderElement = this.chart.renderer.drawPath(new PathOption(this.chart.element.id + '_BorderLine_' + index, 'transparent', axis.border.width, axis.border.color || this.chart.themeStyle.axisLine, 1, '', labelBorder));\n        borderElement.style.pointerEvents = 'none';\n        appendChildElement(this.chart.enableCanvas, parent, borderElement, this.chart.redraw, true, 'x', 'y', null, direction, true);\n    };\n    /**\n     * To find the axis label of the intersect action\n     *\n     * @param {Axis} axis axis\n     * @param {string} label label\n     * @param {number} width width\n     * @returns {string} label\n     */\n    CartesianAxisLayoutPanel.prototype.findAxisLabel = function (axis, label, width) {\n        return (axis.labelIntersectAction === 'Trim' ?\n            ((axis.angle % 360 === 0 && !axis.enableTrim) ? textTrim(width, label, axis.labelStyle) : label) : label);\n    };\n    /**\n     * X-Axis Title function performed\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {Element} parent parent\n     * @param {Rect} rect rect\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.drawXAxisTitle = function (axis, index, parent, rect) {\n        if (axis.title) {\n            var chart = this.chart;\n            var elementSize = measureText(axis.title, axis.titleStyle);\n            var scrollBarHeight = isNullOrUndefined(axis.crossesAt) ? axis.scrollBarHeight : 0;\n            var padding = (axis.tickPosition === 'Inside' ? 0 : axis.majorTickLines.height + axis.titlePadding) +\n                (axis.labelPosition === 'Inside' ? 0 :\n                    axis.maxLabelSize.height + axis.multiLevelLabelHeight + axis.labelPadding);\n            var titleSize = (axis.titleSize.height * (axis.titleCollection.length - 1));\n            padding = axis.isAxisOpposedPosition ? -(padding + elementSize.height / 4 + scrollBarHeight + titleSize) : (padding + (3 *\n                elementSize.height / 4) + scrollBarHeight);\n            var options = new TextOption(chart.element.id + '_AxisTitle_' + index, rect.x + rect.width * 0.5, rect.y + padding, 'middle', axis.titleCollection);\n            var element = textElement(chart.renderer, options, axis.titleStyle, axis.titleStyle.color || chart.themeStyle.axisTitle, parent, null, null, null, null, null, null, null, null, chart.enableCanvas);\n            element.setAttribute('aria-label', axis.description || axis.title);\n            element.setAttribute('tabindex', axis.tabIndex.toString());\n        }\n    };\n    /**\n     * To render the axis grid and tick lines(Both Major and Minor)\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {string} gridDirection gridDirection\n     * @param {MajorTickLinesModel | MinorTickLinesModel | MajorGridLinesModel | MinorGridLinesModel} gridModel gridModel\n     * @param {string} gridId gridId\n     * @param {number} gridIndex gridIndex\n     * @param {Element} parent parent\n     * @param {string} themeColor themeColor\n     * @param {string} dashArray dashArray\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.renderGridLine = function (axis, index, gridDirection, gridModel, gridId, gridIndex, parent, themeColor, dashArray) {\n        if (dashArray === void 0) { dashArray = null; }\n        var chart = this.chart;\n        var direction;\n        var element;\n        if (gridModel.width > 0 && axis.visible && axis.internalVisibility && gridDirection) {\n            element = getElement(chart.element.id + gridId + index + '_' + gridIndex);\n            direction = element ? element.getAttribute('d') : null;\n            element = null;\n            this.htmlObject = chart.renderer.drawPath(new PathOption(chart.element.id + gridId + index + '_' + gridIndex, 'transparent', gridModel.width, gridModel.color || themeColor, null, dashArray, gridDirection));\n            appendChildElement(chart.enableCanvas, parent, this.htmlObject, chart.redraw, true, 'x', 'y', null, direction, true);\n        }\n    };\n    /**\n     * To Find the parent node of the axis\n     *\n     * @param {string} elementId elementId\n     * @param {Element} label label\n     * @param {number} index index\n     * @returns {Element} parent node of the axis\n     */\n    CartesianAxisLayoutPanel.prototype.findParentNode = function (elementId, label, index) {\n        if (document.getElementById(elementId + 'AxisGroup' + index + 'Inside').contains(document.getElementById(label.id))) {\n            return document.getElementById(elementId + 'AxisGroup' + index + 'Inside');\n        }\n        else {\n            return document.getElementById(elementId + 'AxisGroup' + index + 'Outside');\n        }\n    };\n    /**\n     * Create Zooming Labels Function Called here\n     *\n     * @param {Chart} chart chart\n     * @param {Element} labelElement labelElement\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {Rect} rect rect\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.createZoomingLabel = function (chart, labelElement, axis, index, rect) {\n        var parentNode = this.findParentNode(chart.element.id, labelElement, index);\n        labelElement.setAttribute('opacity', '0.3');\n        var zoomElement = chart.renderer.createGroup({\n            id: chart.element.id + 'AxisLabels_Zoom' + index\n        });\n        zoomElement = createZoomingLabels(chart, axis, zoomElement, index, axis.orientation === 'Vertical', rect);\n        parentNode.replaceChild(labelElement, document.getElementById(labelElement.id));\n        if (getElement(chart.element.id + 'AxisLabels_Zoom' + index)) {\n            parentNode.replaceChild(zoomElement, document.getElementById(zoomElement.id));\n        }\n        else {\n            parentNode.appendChild(zoomElement);\n        }\n    };\n    return CartesianAxisLayoutPanel;\n}());\nexport { CartesianAxisLayoutPanel };\n"],"mappings":"AAAA,SAASA,aAAa,EAAEC,iBAAiB,QAAQ,sBAAsB;AACvE,SAASC,QAAQ,QAAQ,sBAAsB;AAC/C,SAASC,iBAAiB,EAAEC,kBAAkB,EAAEC,GAAG,EAAEC,aAAa,EAAEC,YAAY,EAAEC,aAAa,QAAQ,2BAA2B;AAClI,SAASC,QAAQ,EAAEC,MAAM,EAAEC,kBAAkB,EAAEC,cAAc,QAAQ,2BAA2B;AAChG,SAASC,SAAS,EAAEC,OAAO,EAAEC,mBAAmB,EAAEC,UAAU,QAAQ,2BAA2B;AAC/F,SAASC,IAAI,EAAEC,IAAI,EAAEC,WAAW,EAAEC,UAAU,EAAEC,UAAU,QAAQ,0BAA0B;AAC1F,SAASC,WAAW,EAAEC,QAAQ,EAAEC,8BAA8B,EAAEC,sBAAsB,EAAEC,SAAS,QAAQ,2BAA2B;AACpI;AACA;AACA;AACA,IAAIC,WAAW,GAAG,EAAE;AACpB,IAAIC,wBAAwB,GAAG,aAAe,YAAY;EACtD;EACA,SAASA,wBAAwBA,CAACC,WAAW,EAAE;IAC3C,IAAI,CAACC,KAAK,GAAGD,WAAW;IACxB,IAAI,CAACE,OAAO,GAAG,CAAC;EACpB;EACA;AACJ;AACA;AACA;AACA;AACA;EACIH,wBAAwB,CAACI,SAAS,CAACC,WAAW,GAAG,UAAUC,IAAI,EAAE;IAC7D,IAAIJ,KAAK,GAAG,IAAI,CAACA,KAAK;IACtB,IAAIK,cAAc,GAAGL,KAAK,CAACM,SAAS,CAACC,KAAK,GAAGzB,cAAc,CAACkB,KAAK,CAACM,SAAS,CAACC,KAAK,EAAEP,KAAK,CAACQ,aAAa,CAACD,KAAK,CAAC,GAAG,IAAI;IACpH,IAAI,CAACE,OAAO,CAACT,KAAK,CAAC;IACnB,IAAI,CAACU,cAAc,GAAG,IAAItB,IAAI,CAACgB,IAAI,CAACO,CAAC,EAAEP,IAAI,CAACQ,CAAC,EAAER,IAAI,CAACG,KAAK,EAAEH,IAAI,CAACS,MAAM,CAAC;IACvE,IAAI,CAACC,eAAe,GAAGV,IAAI;IAC3B,IAAI,CAACW,QAAQ,GAAG,CAAC;IACjB,IAAI,CAACC,SAAS,GAAG,CAAC;IAClB,IAAI,CAACC,OAAO,GAAG,CAAC;IAChB,IAAI,CAACC,UAAU,GAAG,CAAC;IACnB;IACA,IAAI,CAACC,cAAc,CAACnB,KAAK,EAAE,IAAI,CAACc,eAAe,CAAC;IAChD,IAAI,CAACA,eAAe,GAAGzC,iBAAiB,CAAC,IAAI,CAACyC,eAAe,EAAE,IAAI/B,SAAS,CAAC,IAAI,CAACgC,QAAQ,EAAE,IAAI,CAACC,SAAS,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IAClH,IAAI,CAACI,iBAAiB,CAACpB,KAAK,EAAE,IAAI,CAACc,eAAe,CAAC;IACnD,IAAI,CAACA,eAAe,GAAGzC,iBAAiB,CAAC,IAAI,CAACyC,eAAe,EAAE,IAAI/B,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAACkC,OAAO,EAAE,IAAI,CAACC,UAAU,CAAC,CAAC;IAClH,IAAI,CAAC,IAAI,CAAClB,KAAK,CAACqB,WAAW,EAAE;MACzB,IAAI,CAACC,iBAAiB,CAAC,IAAI,CAACR,eAAe,CAAC;IAChD;IACA,IAAI,CAACC,QAAQ,GAAG,CAAC;IACjB,IAAI,CAACC,SAAS,GAAG,CAAC;IAClB,IAAI,CAACC,OAAO,GAAG,CAAC;IAChB,IAAI,CAACC,UAAU,GAAG,CAAC;IACnB;IACA,IAAI,CAACC,cAAc,CAACnB,KAAK,EAAE,IAAI,CAACc,eAAe,CAAC;IAChD,IAAI,CAACJ,cAAc,GAAGrC,iBAAiB,CAAC,IAAI,CAACqC,cAAc,EAAE,IAAI3B,SAAS,CAAC,IAAI,CAACgC,QAAQ,EAAE,IAAI,CAACC,SAAS,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IAChH,IAAI,CAACI,iBAAiB,CAACpB,KAAK,EAAE,IAAI,CAACc,eAAe,CAAC;IACnD,IAAI,CAACJ,cAAc,GAAGrC,iBAAiB,CAAC,IAAI,CAACqC,cAAc,EAAE,IAAI3B,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAACkC,OAAO,EAAE,IAAI,CAACC,UAAU,CAAC,CAAC;IAChH,IAAIb,cAAc,EAAE;MAChB,IAAI,CAACkB,uBAAuB,CAACvB,KAAK,EAAEK,cAAc,CAAC;IACvD;IACA,IAAI,CAAC,IAAI,CAACL,KAAK,CAACqB,WAAW,EAAE;MACzBrB,KAAK,CAACwB,WAAW,EAAE;MACnB,IAAI,CAACF,iBAAiB,CAAC,IAAI,CAACZ,cAAc,CAAC;IAC/C;EACJ,CAAC;EACDZ,wBAAwB,CAACI,SAAS,CAACqB,uBAAuB,GAAG,UAAUvB,KAAK,EAAEK,cAAc,EAAE;IAC1F,IAAI,CAACK,cAAc,CAACH,KAAK,GAAGF,cAAc;IAC1C,IAAI,CAACK,cAAc,CAACC,CAAC,GAAGX,KAAK,CAACQ,aAAa,CAACD,KAAK,GAAGP,KAAK,CAACyB,MAAM,CAACC,KAAK,GAAGrB,cAAc,IAClFL,KAAK,CAAC2B,cAAc,CAACC,QAAQ,KAAK,OAAO,GAAG5B,KAAK,CAAC6B,YAAY,CAACC,YAAY,CAACvB,KAAK,GAAG,CAAC,CAAC;IAC3F,KAAK,IAAIwB,EAAE,GAAG,CAAC,EAAEC,EAAE,GAAGhC,KAAK,CAACiC,IAAI,EAAEF,EAAE,GAAGC,EAAE,CAACE,MAAM,EAAEH,EAAE,EAAE,EAAE;MACpD,IAAII,IAAI,GAAGH,EAAE,CAACD,EAAE,CAAC;MACjB,IAAI,CAACrB,cAAc,CAACC,CAAC,IAAIpC,GAAG,CAAC4D,IAAI,CAACC,QAAQ,CAAC;IAC/C;EACJ,CAAC;EACDtC,wBAAwB,CAACI,SAAS,CAACiB,cAAc,GAAG,UAAUnB,KAAK,EAAEI,IAAI,EAAE;IACvE,IAAIiC,GAAG;IACP,IAAI,CAACC,gBAAgB,CAAClC,IAAI,CAAC;IAC3B,KAAK,IAAI2B,EAAE,GAAG,CAAC,EAAEC,EAAE,GAAGhC,KAAK,CAACiC,IAAI,EAAEF,EAAE,GAAGC,EAAE,CAACE,MAAM,EAAEH,EAAE,EAAE,EAAE;MACpD,IAAII,IAAI,GAAGH,EAAE,CAACD,EAAE,CAAC;MACjBM,GAAG,GAAGF,IAAI;MACVE,GAAG,CAACE,SAAS,GAAG,EAAE;MAClBF,GAAG,CAACD,QAAQ,GAAG,EAAE;MACjB,IAAI,CAACI,WAAW,CAACH,GAAG,CAAC;MACrB,IAAI,CAACI,iBAAiB,CAACJ,GAAG,EAAErC,KAAK,EAAE,IAAIb,IAAI,CAACa,KAAK,CAACQ,aAAa,CAACD,KAAK,EAAE8B,GAAG,CAACK,cAAc,CAAC,CAAC;MAC3F,IAAI,IAAI,CAAC3B,QAAQ,GAAGxC,GAAG,CAAC8D,GAAG,CAACE,SAAS,CAAC,EAAE;QACpC,IAAI,CAACxB,QAAQ,GAAGxC,GAAG,CAAC8D,GAAG,CAACE,SAAS,CAAC;MACtC;MACA,IAAI,IAAI,CAACvB,SAAS,GAAGzC,GAAG,CAAC8D,GAAG,CAACD,QAAQ,CAAC,EAAE;QACpC,IAAI,CAACpB,SAAS,GAAGzC,GAAG,CAAC8D,GAAG,CAACD,QAAQ,CAAC;MACtC;IACJ;EACJ,CAAC;EACDtC,wBAAwB,CAACI,SAAS,CAACkB,iBAAiB,GAAG,UAAUpB,KAAK,EAAEI,IAAI,EAAE;IAC1E,IAAIuC,MAAM;IACV,IAAI,CAACC,mBAAmB,CAACxC,IAAI,CAAC;IAC9B,KAAK,IAAI2B,EAAE,GAAG,CAAC,EAAEC,EAAE,GAAGhC,KAAK,CAAC6C,OAAO,EAAEd,EAAE,GAAGC,EAAE,CAACE,MAAM,EAAEH,EAAE,EAAE,EAAE;MACvD,IAAII,IAAI,GAAGH,EAAE,CAACD,EAAE,CAAC;MACjBY,MAAM,GAAGR,IAAI;MACbQ,MAAM,CAACP,QAAQ,GAAG,EAAE;MACpBO,MAAM,CAACJ,SAAS,GAAG,EAAE;MACrB,IAAI,CAACC,WAAW,CAACG,MAAM,CAAC;MACxB,IAAI,CAACF,iBAAiB,CAACE,MAAM,EAAE3C,KAAK,EAAE,IAAIb,IAAI,CAACwD,MAAM,CAACG,aAAa,EAAE9C,KAAK,CAACQ,aAAa,CAACK,MAAM,CAAC,CAAC;MACjG,IAAI,IAAI,CAACK,UAAU,GAAG3C,GAAG,CAACoE,MAAM,CAACJ,SAAS,CAAC,EAAE;QACzC,IAAI,CAACrB,UAAU,GAAG3C,GAAG,CAACoE,MAAM,CAACJ,SAAS,CAAC;MAC3C;MACA,IAAI,IAAI,CAACtB,OAAO,GAAG1C,GAAG,CAACoE,MAAM,CAACP,QAAQ,CAAC,EAAE;QACrC,IAAI,CAACnB,OAAO,GAAG1C,GAAG,CAACoE,MAAM,CAACP,QAAQ,CAAC;MACvC;IACJ;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACItC,wBAAwB,CAACI,SAAS,CAACuC,iBAAiB,GAAG,UAAUM,UAAU,EAAE/C,KAAK,EAAEgD,IAAI,EAAE;IACtF,IAAIC,GAAG,GAAG,EAAE,CAAC,CAAC;IACd,KAAK,IAAIlB,EAAE,GAAG,CAAC,EAAEC,EAAE,GAAGe,UAAU,CAACG,IAAI,EAAEnB,EAAE,GAAGC,EAAE,CAACE,MAAM,EAAEH,EAAE,EAAE,EAAE;MACzD,IAAIoB,IAAI,GAAGnB,EAAE,CAACD,EAAE,CAAC;MACjBoB,IAAI,CAACC,eAAe,GAAGpD,KAAK,CAACqD,eAAe,IAAIrD,KAAK,CAACsD,UAAU,IAAItD,KAAK,CAACuD,YAAY,CAACC,eAAe,IAClGL,IAAI,CAACM,wBAAwB,IAAIzD,KAAK,CAACsD,UAAU,CAACI,QAAQ,KAAKP,IAAI,CAACQ,UAAU,GAAG,CAAC,IAAIR,IAAI,CAACS,YAAY,GAAG,CAAC,CAAC,GAAGX,GAAG,GAAG,CAAC;MAC1HE,IAAI,CAACC,eAAe,GAAGpD,KAAK,CAACqD,eAAe,KAAKrD,KAAK,CAACsD,UAAU,IAAItD,KAAK,CAACuD,YAAY,CAACC,eAAe,IACnGL,IAAI,CAACM,wBAAwB,IAAIzD,KAAK,CAACsD,UAAU,CAACI,QAAQ,KAAKP,IAAI,CAACQ,UAAU,GAAG,CAAC,IAAIR,IAAI,CAACS,YAAY,GAAG,CAAC,CAAC,IACzGT,IAAI,CAACU,iBAAiB,CAACC,MAAM,CAAC,GAAGb,GAAG,GAAG,CAAC;MAC/CE,IAAI,CAACY,SAAS,CAAC/D,KAAK,CAAC;MACrBmD,IAAI,CAACa,UAAU,CAACC,yBAAyB,CAACjB,IAAI,EAAEG,IAAI,CAAC;MACrDJ,UAAU,CAACmB,WAAW,CAACf,IAAI,EAAEA,IAAI,CAACC,eAAe,CAAC;IACtD;IACA,IAAIL,UAAU,CAACX,QAAQ,CAACF,MAAM,GAAG,CAAC,EAAE;MAChCa,UAAU,CAACX,QAAQ,CAACW,UAAU,CAACX,QAAQ,CAACF,MAAM,GAAG,CAAC,CAAC,IAAIrC,WAAW;IACtE;IACA,IAAIkD,UAAU,CAACR,SAAS,CAACL,MAAM,GAAG,CAAC,EAAE;MACjCa,UAAU,CAACR,SAAS,CAACQ,UAAU,CAACR,SAAS,CAACL,MAAM,GAAG,CAAC,CAAC,IAAIrC,WAAW;IACxE;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACIC,wBAAwB,CAACI,SAAS,CAACoB,iBAAiB,GAAG,UAAUlB,IAAI,EAAE;IACnE,IAAIJ,KAAK,GAAG,IAAI,CAACA,KAAK;IACtB,IAAIqC,GAAG;IACP,IAAIM,MAAM;IACV,IAAII,UAAU;IACd,IAAII,IAAI;IACR,IAAIgB,SAAS,GAAG,CAAC;IACjB,IAAIC,QAAQ,GAAG,CAAC;IAChB,IAAIpB,IAAI,GAAG,CAAC;IACZ,IAAIrC,CAAC;IACL,IAAIC,CAAC;IACL,IAAIyD,UAAU;IACd,IAAI,CAAC/B,gBAAgB,CAAClC,IAAI,CAAC;IAC3B,KAAK,IAAIkE,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGvE,KAAK,CAACiC,IAAI,CAACC,MAAM,EAAEoC,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACnDjC,GAAG,GAAGrC,KAAK,CAACiC,IAAI,CAACqC,CAAC,CAAC;MACnBH,SAAS,GAAG,CAAC;MACbC,QAAQ,GAAG,CAAC;MACZ,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEC,KAAK,GAAGpC,GAAG,CAACa,IAAI,CAAChB,MAAM,EAAEsC,CAAC,GAAGC,KAAK,EAAED,CAAC,EAAE,EAAE;QACrDrB,IAAI,GAAGd,GAAG,CAACa,IAAI,CAACsB,CAAC,CAAC;QAClBH,UAAU,GAAGlB,IAAI,CAACuB,UAAU;QAC5B,IAAIvB,IAAI,CAAC/C,IAAI,CAACS,MAAM,KAAK,CAAC,EAAE;UACxBsC,IAAI,CAAC/C,IAAI,CAACS,MAAM,GAAGwB,GAAG,CAACK,cAAc;UACrCM,IAAI,GAAG,CAAC;UACR,KAAK,IAAI2B,CAAC,GAAGL,CAAC,GAAG,CAAC,EAAEM,KAAK,GAAGN,CAAC,GAAGnB,IAAI,CAAC0B,IAAI,EAAEF,CAAC,GAAGC,KAAK,EAAED,CAAC,EAAE,EAAE;YACvD5B,UAAU,GAAG/C,KAAK,CAACiC,IAAI,CAAC0C,CAAC,CAAC;YAC1B3B,IAAI,IAAID,UAAU,CAACL,cAAc;UACrC;UACAS,IAAI,CAAC/C,IAAI,CAACQ,CAAC,GAAIyB,GAAG,CAACyC,WAAW,GAAG9B,IAAI,IAAKG,IAAI,CAAC4B,aAAa,GAAG5B,IAAI,CAAC4B,aAAa,GAAGV,UAAU,CAAC;UAC/FlB,IAAI,CAAC/C,IAAI,CAACS,MAAM,GAAIsC,IAAI,CAAC/C,IAAI,CAACS,MAAM,GAAGmC,IAAI,GACtC,IAAI,CAACgC,kBAAkB,CAAC7B,IAAI,CAAC4B,aAAa,EAAE5B,IAAI,CAAC8B,gBAAgB,EAAE9B,IAAI,CAACuB,UAAU,CAAE;UACzFvB,IAAI,CAAC/C,IAAI,CAACG,KAAK,GAAG,CAAC;QACvB;QACA,IAAI4C,IAAI,CAAC+B,qBAAqB,EAAE;UAC5BvE,CAAC,GAAGP,IAAI,CAACO,CAAC,GAAGP,IAAI,CAACG,KAAK,GAAGhC,GAAG,CAACI,QAAQ,CAAC0D,GAAG,CAACD,QAAQ,EAAEgC,QAAQ,CAAC,CAAC;UAC/DjB,IAAI,CAAC/C,IAAI,CAACO,CAAC,GAAGwC,IAAI,CAAC/C,IAAI,CAACO,CAAC,IAAIA,CAAC,GAAGwC,IAAI,CAAC/C,IAAI,CAACO,CAAC,GAAGA,CAAC;UAChDyD,QAAQ,EAAE;QACd,CAAC,MACI;UACDzD,CAAC,GAAGP,IAAI,CAACO,CAAC,GAAGpC,GAAG,CAACI,QAAQ,CAAC0D,GAAG,CAACE,SAAS,EAAE4B,SAAS,CAAC,CAAC;UACpDhB,IAAI,CAAC/C,IAAI,CAACO,CAAC,GAAGwC,IAAI,CAAC/C,IAAI,CAACO,CAAC,IAAIA,CAAC,GAAGwC,IAAI,CAAC/C,IAAI,CAACO,CAAC,GAAGA,CAAC;UAChDwD,SAAS,EAAE;QACf;MACJ;IACJ;IACA,IAAI,CAACvB,mBAAmB,CAACxC,IAAI,CAAC;IAC9B,KAAK,IAAIkE,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGvE,KAAK,CAAC6C,OAAO,CAACX,MAAM,EAAEoC,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACtD3B,MAAM,GAAG3C,KAAK,CAAC6C,OAAO,CAACyB,CAAC,CAAC;MACzBH,SAAS,GAAG,CAAC;MACbC,QAAQ,GAAG,CAAC;MACZ,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEW,KAAK,GAAGxC,MAAM,CAACO,IAAI,CAAChB,MAAM,EAAEsC,CAAC,GAAGW,KAAK,EAAEX,CAAC,EAAE,EAAE;QACxDrB,IAAI,GAAGR,MAAM,CAACO,IAAI,CAACsB,CAAC,CAAC;QACrBH,UAAU,GAAGlB,IAAI,CAACuB,UAAU;QAC5B,IAAIvB,IAAI,CAAC/C,IAAI,CAACG,KAAK,KAAK,CAAC,EAAE;UACvB,KAAK,IAAIoE,CAAC,GAAGL,CAAC,EAAEc,KAAK,GAAId,CAAC,GAAGnB,IAAI,CAAC0B,IAAK,EAAEF,CAAC,GAAGS,KAAK,EAAET,CAAC,EAAE,EAAE;YACrD5B,UAAU,GAAG/C,KAAK,CAAC6C,OAAO,CAAC8B,CAAC,CAAC;YAC7BxB,IAAI,CAAC/C,IAAI,CAACG,KAAK,IAAIwC,UAAU,CAACD,aAAa;UAC/C;UACAK,IAAI,CAAC/C,IAAI,CAACO,CAAC,GAAGgC,MAAM,CAAC0C,YAAY,IAAIlC,IAAI,CAACmC,cAAc,GAAGnC,IAAI,CAACmC,cAAc,GAAGjB,UAAU,CAAC;UAC5FlB,IAAI,CAAC/C,IAAI,CAACG,KAAK,IAAK,IAAI,CAACyE,kBAAkB,CAAC7B,IAAI,CAACmC,cAAc,EAAEnC,IAAI,CAACoC,eAAe,EAAEpC,IAAI,CAACuB,UAAU,CAAE;UACxGvB,IAAI,CAAC/C,IAAI,CAACS,MAAM,GAAG,CAAC;QACxB;QACA,IAAIsC,IAAI,CAAC+B,qBAAqB,EAAE;UAC5BtE,CAAC,GAAGR,IAAI,CAACQ,CAAC,GAAGrC,GAAG,CAACI,QAAQ,CAACgE,MAAM,CAACP,QAAQ,EAAEgC,QAAQ,CAAC,CAAC;UACrDjB,IAAI,CAAC/C,IAAI,CAACQ,CAAC,GAAGuC,IAAI,CAAC/C,IAAI,CAACQ,CAAC,IAAIA,CAAC,GAAGuC,IAAI,CAAC/C,IAAI,CAACQ,CAAC,GAAGA,CAAC;UAChDwD,QAAQ,EAAE;QACd,CAAC,MACI;UACDxD,CAAC,GAAGR,IAAI,CAACQ,CAAC,GAAGR,IAAI,CAACS,MAAM,GAAGtC,GAAG,CAACI,QAAQ,CAACgE,MAAM,CAACJ,SAAS,EAAE4B,SAAS,CAAC,CAAC;UACrEhB,IAAI,CAAC/C,IAAI,CAACQ,CAAC,GAAGuC,IAAI,CAAC/C,IAAI,CAACQ,CAAC,IAAIA,CAAC,GAAGuC,IAAI,CAAC/C,IAAI,CAACQ,CAAC,GAAGA,CAAC;UAChDuD,SAAS,EAAE;QACf;MACJ;IACJ;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACIrE,wBAAwB,CAACI,SAAS,CAACsF,OAAO,GAAG,YAAY;IACrD,IAAIxF,KAAK,GAAG,IAAI,CAACA,KAAK;IACtB,IAAIqC,GAAG;IACP,IAAIM,MAAM;IACV,IAAII,UAAU;IACd,IAAI0C,WAAW;IACf,IAAIZ,IAAI;IACR,KAAK,IAAI9C,EAAE,GAAG,CAAC,EAAEC,EAAE,GAAGhC,KAAK,CAAC0F,eAAe,EAAE3D,EAAE,GAAGC,EAAE,CAACE,MAAM,EAAEH,EAAE,EAAE,EAAE;MAC/D,IAAIoB,IAAI,GAAGnB,EAAE,CAACD,EAAE,CAAC;MACjB;MACA,IAAIoB,IAAI,CAACwC,WAAW,KAAK,UAAU,EAAE;QACjC3F,KAAK,CAAC4F,YAAY,CAACC,IAAI,CAAC1C,IAAI,CAAC;QAC7BsC,WAAW,GAAG,IAAI,CAACK,YAAY,CAAC3C,IAAI,CAAC;QACrCd,GAAG,GAAGrC,KAAK,CAACiC,IAAI,CAACwD,WAAW,CAAC;QAC7B,IAAI,CAACM,QAAQ,CAAC1D,GAAG,EAAEc,IAAI,CAAC;QACxB0B,IAAI,GAAKY,WAAW,GAAGtC,IAAI,CAAC0B,IAAI,GAAI7E,KAAK,CAACiC,IAAI,CAACC,MAAM,GAAGlC,KAAK,CAACiC,IAAI,CAACC,MAAM,GAAIuD,WAAW,GAAGtC,IAAI,CAAC0B,IAAM;QACtG,KAAK,IAAIL,CAAC,GAAGiB,WAAW,GAAG,CAAC,EAAEjB,CAAC,GAAGK,IAAI,EAAEL,CAAC,EAAE,EAAE;UACzCzB,UAAU,GAAG/C,KAAK,CAACiC,IAAI,CAACuC,CAAC,CAAC;UAC1BzB,UAAU,CAACG,IAAI,CAACb,GAAG,CAACa,IAAI,CAAChB,MAAM,GAAG,CAAC,CAAC,GAAGiB,IAAI;UAC3CnD,KAAK,CAACiC,IAAI,CAACuC,CAAC,CAAC,GAAGzB,UAAU;QAC9B;QACA/C,KAAK,CAACiC,IAAI,CAACwD,WAAW,CAAC,GAAGpD,GAAG;MACjC,CAAC,MACI;QACDrC,KAAK,CAACgG,cAAc,CAACH,IAAI,CAAC1C,IAAI,CAAC;QAC/BsC,WAAW,GAAG,IAAI,CAACQ,eAAe,CAAC9C,IAAI,CAAC;QACxCR,MAAM,GAAG3C,KAAK,CAAC6C,OAAO,CAAC4C,WAAW,CAAC;QACnC,IAAI,CAACM,QAAQ,CAACpD,MAAM,EAAEQ,IAAI,CAAC;QAC3B0B,IAAI,GAAKY,WAAW,GAAGtC,IAAI,CAAC0B,IAAI,GAAI7E,KAAK,CAAC6C,OAAO,CAACX,MAAM,GAAGlC,KAAK,CAAC6C,OAAO,CAACX,MAAM,GAAIuD,WAAW,GAAGtC,IAAI,CAAC0B,IAAM;QAC5G,KAAK,IAAIL,CAAC,GAAGiB,WAAW,GAAG,CAAC,EAAEjB,CAAC,GAAGK,IAAI,EAAEL,CAAC,EAAE,EAAE;UACzCzB,UAAU,GAAG/C,KAAK,CAAC6C,OAAO,CAAC2B,CAAC,CAAC;UAC7BzB,UAAU,CAACG,IAAI,CAACP,MAAM,CAACO,IAAI,CAAChB,MAAM,GAAG,CAAC,CAAC,GAAGiB,IAAI;UAC9CnD,KAAK,CAAC6C,OAAO,CAAC2B,CAAC,CAAC,GAAGzB,UAAU;QACjC;QACA/C,KAAK,CAAC6C,OAAO,CAAC4C,WAAW,CAAC,GAAG9C,MAAM;MACvC;MACAQ,IAAI,CAAC+C,YAAY,GAAGlG,KAAK,CAACmG,SAAS;MACnChD,IAAI,CAACiD,+BAA+B,EAAE;IAC1C;EACJ,CAAC;EACDtG,wBAAwB,CAACI,SAAS,CAAC8E,kBAAkB,GAAG,UAAUqB,SAAS,EAAEC,SAAS,EAAE5B,UAAU,EAAE;IAChG,IAAI6B,WAAW,GAAGF,SAAS,GAAIA,SAAS,IAAIC,SAAS,GAAGA,SAAS,GAC7D5B,UAAU,CAAC,GAAK4B,SAAS,GAAGA,SAAS,GAAG5B,UAAU,GAAG,CAAC,GAAGA,UAAW;IACxE,OAAO6B,WAAW;EACtB,CAAC;EACDzG,wBAAwB,CAACI,SAAS,CAACO,OAAO,GAAG,UAAUT,KAAK,EAAE;IAC1D,KAAK,IAAI+B,EAAE,GAAG,CAAC,EAAEC,EAAE,GAAGhC,KAAK,CAAC0F,eAAe,EAAE3D,EAAE,GAAGC,EAAE,CAACE,MAAM,EAAEH,EAAE,EAAE,EAAE;MAC/D,IAAIoB,IAAI,GAAGnB,EAAE,CAACD,EAAE,CAAC;MACjB,IAAIoB,IAAI,CAACqD,SAAS,KAAK,IAAI,EAAE;QACzB;MACJ;MACA,IAAI,CAACrD,IAAI,CAACsD,aAAa,EAAE;QACrB,IAAIzG,KAAK,CAAC0G,mBAAmB,EAAE;UAC3BvD,IAAI,CAACwD,WAAW,GAAKxD,IAAI,CAACwC,WAAW,KAAK,YAAY,GAAK3F,KAAK,CAAC4G,YAAY,GAAG5G,KAAK,CAAC6G,YAAY;QACtG,CAAC,MACI;UACD1D,IAAI,CAACwD,WAAW,GAAKxD,IAAI,CAACwC,WAAW,KAAK,YAAY,GAAK3F,KAAK,CAAC6G,YAAY,GAAG7G,KAAK,CAAC4G,YAAY;QACtG;QACAzD,IAAI,CAAC1C,OAAO,GAAG,IAAI,CAACqG,aAAa,CAAC3D,IAAI,CAACwD,WAAW,EAAExD,IAAI,CAACqD,SAAS,CAAC;QACnE;MACJ,CAAC,MACI;QACD,KAAK,IAAIlC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGvE,KAAK,CAAC0F,eAAe,CAACxD,MAAM,EAAEoC,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;UAC9D,IAAInB,IAAI,CAACsD,aAAa,KAAKzG,KAAK,CAAC0F,eAAe,CAACpB,CAAC,CAAC,CAACyC,IAAI,EAAE;YACtD5D,IAAI,CAACwD,WAAW,GAAG3G,KAAK,CAAC0F,eAAe,CAACpB,CAAC,CAAC;YAC3CnB,IAAI,CAAC1C,OAAO,GAAG,IAAI,CAACqG,aAAa,CAAC3D,IAAI,CAACwD,WAAW,EAAExD,IAAI,CAACqD,SAAS,CAAC;YACnE;UACJ;QACJ;MACJ;IACJ;EACJ,CAAC;EACD1G,wBAAwB,CAACI,SAAS,CAAC4G,aAAa,GAAG,UAAU3D,IAAI,EAAE1C,OAAO,EAAE;IACxE,QAAQ0C,IAAI,CAAC6D,SAAS;MAClB,KAAK,UAAU;QACX,IAAIC,MAAM,GAAG;UACTC,QAAQ,EAAE,MAAM;UAChBC,IAAI,EAAE;QACV,CAAC;QACD,IAAIC,UAAU,GAAG,IAAI,CAACpH,KAAK,CAACqH,IAAI,CAACC,aAAa,CAACL,MAAM,CAAC;QACtD,IAAIM,aAAa,GAAG,IAAI,CAACvH,KAAK,CAACqH,IAAI,CAACG,aAAa,CAACP,MAAM,CAAC;QACzD,OAAOQ,IAAI,CAACC,KAAK,CAACN,UAAU,CAACG,aAAa,CAAC,IAAIE,IAAI,CAACrJ,QAAQ,CAACsJ,KAAK,CAACC,SAAS,CAAC;UAAEC,GAAG,EAAEnH;QAAQ,CAAC,CAAC,CAACmH,GAAG,CAAC,CAAC,CAAC,CAAC;MAC1G,KAAK,UAAU;QACX,OAAOC,UAAU,CAACpH,OAAO,CAAC,GAAGoH,UAAU,CAACpH,OAAO,CAAC,GAAG0C,IAAI,CAAC2E,MAAM,CAACC,OAAO,CAACtH,OAAO,CAAC;MACnF,KAAK,aAAa;QACd,OAAOzB,OAAO,CAACyB,OAAO,EAAE0C,IAAI,CAACnE,OAAO,CAAC;MACzC;QACI,OAAOyB,OAAO;IAAC;EAE3B,CAAC;EACDX,wBAAwB,CAACI,SAAS,CAAC6F,QAAQ,GAAG,UAAUhD,UAAU,EAAEI,IAAI,EAAE;IACtE,KAAK,IAAImB,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGxB,UAAU,CAACG,IAAI,CAAChB,MAAM,EAAEoC,CAAC,IAAIC,GAAG,EAAED,CAAC,EAAE,EAAE;MACzD,IAAI,CAACvB,UAAU,CAACG,IAAI,CAACoB,CAAC,CAAC,EAAE;QACrBvB,UAAU,CAACG,IAAI,CAACoB,CAAC,CAAC,GAAGnB,IAAI;QACzB;MACJ;IACJ;EACJ,CAAC;EACDrD,wBAAwB,CAACI,SAAS,CAACsC,WAAW,GAAG,UAAUO,UAAU,EAAE;IACnE,IAAIiF,cAAc,GAAG,EAAE;IACvB,KAAK,IAAI1D,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGxB,UAAU,CAACG,IAAI,CAAChB,MAAM,EAAEoC,CAAC,IAAIC,GAAG,EAAED,CAAC,EAAE,EAAE;MACzD,IAAIvB,UAAU,CAACG,IAAI,CAACoB,CAAC,CAAC,EAAE;QACpB0D,cAAc,CAACnC,IAAI,CAAC9C,UAAU,CAACG,IAAI,CAACoB,CAAC,CAAC,CAAC;MAC3C;IACJ;IACAvB,UAAU,CAACG,IAAI,GAAG8E,cAAc;EACpC,CAAC;EACDlI,wBAAwB,CAACI,SAAS,CAAC+F,eAAe,GAAG,UAAU9C,IAAI,EAAE;IACjE,IAAI8E,YAAY,GAAG,IAAI,CAACjI,KAAK,CAAC6C,OAAO,CAACX,MAAM;IAC5C,IAAIgG,GAAG,GAAG/E,IAAI,CAACgF,WAAW;IAC1B,IAAIC,MAAM,GAAGF,GAAG,IAAID,YAAY,GAAGA,YAAY,GAAG,CAAC,GAAIC,GAAG,GAAG,CAAC,GAAG,CAAC,GAAGA,GAAI;IACzE,OAAOE,MAAM;EACjB,CAAC;EACDtI,wBAAwB,CAACI,SAAS,CAAC4F,YAAY,GAAG,UAAU3C,IAAI,EAAE;IAC9D,IAAI8E,YAAY,GAAG,IAAI,CAACjI,KAAK,CAACiC,IAAI,CAACC,MAAM;IACzC,IAAIgG,GAAG,GAAG/E,IAAI,CAACkF,QAAQ;IACvB,IAAID,MAAM,GAAGF,GAAG,IAAID,YAAY,GAAGA,YAAY,GAAG,CAAC,GAAIC,GAAG,GAAG,CAAC,GAAG,CAAC,GAAGA,GAAI;IACzE,OAAOE,MAAM;EACjB,CAAC;EACD;AACJ;AACA;AACA;AACA;EACItI,wBAAwB,CAACI,SAAS,CAACoC,gBAAgB,GAAG,UAAUlC,IAAI,EAAE;IAClE;IACA,IAAIJ,KAAK,GAAG,IAAI,CAACA,KAAK;IACtB,IAAIqC,GAAG;IACP,IAAIiG,MAAM,GAAGlI,IAAI,CAACQ,CAAC,GAAGR,IAAI,CAACS,MAAM;IACjC,IAAIA,MAAM,GAAG,CAAC;IACd,IAAI0H,eAAe,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAErI,IAAI,CAACS,MAAM,CAAC;IAC9C,KAAK,IAAIyD,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGvE,KAAK,CAACiC,IAAI,CAACC,MAAM,EAAEoC,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACnDjC,GAAG,GAAGrC,KAAK,CAACiC,IAAI,CAACqC,CAAC,CAAC;MACnB,IAAIjC,GAAG,CAACxB,MAAM,CAACkH,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;QAChClH,MAAM,GAAG2H,IAAI,CAACE,GAAG,CAACH,eAAe,EAAGnI,IAAI,CAACS,MAAM,GAAG8H,QAAQ,CAACtG,GAAG,CAACxB,MAAM,EAAE,EAAE,CAAC,GAAG,GAAG,CAAE;MACtF,CAAC,MACI;QACDA,MAAM,GAAG2H,IAAI,CAACE,GAAG,CAACH,eAAe,EAAEI,QAAQ,CAACtG,GAAG,CAACxB,MAAM,EAAE,EAAE,CAAC,CAAC;MAChE;MACAA,MAAM,GAAIyD,CAAC,KAAMC,GAAG,GAAG,CAAE,GAAI1D,MAAM,GAAG0H,eAAe;MACrDlG,GAAG,CAACK,cAAc,GAAG7B,MAAM;MAC3ByH,MAAM,IAAIzH,MAAM;MAChBwB,GAAG,CAACyC,WAAW,GAAGwD,MAAM;MACxBC,eAAe,IAAI1H,MAAM;IAC7B;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACIf,wBAAwB,CAACI,SAAS,CAAC0C,mBAAmB,GAAG,UAAUxC,IAAI,EAAE;IACrE;IACA,IAAIJ,KAAK,GAAG,IAAI,CAACA,KAAK;IACtB,IAAI2C,MAAM;IACV,IAAIiG,UAAU,GAAGxI,IAAI,CAACO,CAAC;IACvB,IAAIJ,KAAK,GAAG,CAAC;IACb,IAAIsI,cAAc,GAAGL,IAAI,CAACC,GAAG,CAAC,CAAC,EAAErI,IAAI,CAACG,KAAK,CAAC;IAC5C,KAAK,IAAI+D,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGvE,KAAK,CAAC6C,OAAO,CAACX,MAAM,EAAEoC,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACtD3B,MAAM,GAAG3C,KAAK,CAAC6C,OAAO,CAACyB,CAAC,CAAC;MACzB,IAAI3B,MAAM,CAACpC,KAAK,CAACwH,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;QAClCxH,KAAK,GAAGiI,IAAI,CAACE,GAAG,CAACG,cAAc,EAAGzI,IAAI,CAACG,KAAK,GAAGoI,QAAQ,CAAChG,MAAM,CAACpC,KAAK,EAAE,EAAE,CAAC,GAAG,GAAG,CAAE;MACrF,CAAC,MACI;QACDA,KAAK,GAAGiI,IAAI,CAACE,GAAG,CAACG,cAAc,EAAEF,QAAQ,CAAChG,MAAM,CAACpC,KAAK,EAAE,EAAE,CAAC,CAAC;MAChE;MACAA,KAAK,GAAI+D,CAAC,KAAMC,GAAG,GAAG,CAAE,GAAIhE,KAAK,GAAGsI,cAAc;MAClDlG,MAAM,CAACG,aAAa,GAAGvC,KAAK;MAC5BoC,MAAM,CAAC0C,YAAY,GAAGuD,UAAU;MAChCA,UAAU,IAAIrI,KAAK;MACnBsI,cAAc,IAAItI,KAAK;IAC3B;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACI;EACAT,wBAAwB,CAACI,SAAS,CAAC4I,UAAU,GAAG,YAAY;IACxD,IAAI9I,KAAK,GAAG,IAAI,CAACA,KAAK;IACtB,IAAImD,IAAI;IACR,IAAI4F,WAAW,GAAG/I,KAAK,CAACgJ,QAAQ,CAACC,WAAW,CAAC;MAAEC,EAAE,EAAElJ,KAAK,CAACmJ,OAAO,CAACD,EAAE,GAAG;IAAuB,CAAC,CAAC;IAC/F,IAAIE,eAAe,GAAGpJ,KAAK,CAACgJ,QAAQ,CAACC,WAAW,CAAC;MAAEC,EAAE,EAAElJ,KAAK,CAACmJ,OAAO,CAACD,EAAE,GAAG;IAAwB,CAAC,CAAC;IACpG,IAAIG,cAAc;IAClB,IAAIC,QAAQ;IACZ,KAAK,IAAIhF,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGvE,KAAK,CAAC0F,eAAe,CAACxD,MAAM,EAAEoC,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MAC9D,IAAIiF,cAAc,GAAG,IAAI;MACzBpG,IAAI,GAAGnD,KAAK,CAAC0F,eAAe,CAACpB,CAAC,CAAC;MAC/B,IAAI,CAAC6E,OAAO,GAAGnJ,KAAK,CAACgJ,QAAQ,CAACC,WAAW,CAAC;QAAEC,EAAE,EAAElJ,KAAK,CAACmJ,OAAO,CAACD,EAAE,GAAG,WAAW,GAAG5E,CAAC,GAAG;MAAS,CAAC,CAAC;MAChG+E,cAAc,GAAGrJ,KAAK,CAACgJ,QAAQ,CAACC,WAAW,CAAC;QAAEC,EAAE,EAAElJ,KAAK,CAACmJ,OAAO,CAACD,EAAE,GAAG,WAAW,GAAG5E,CAAC,GAAG;MAAU,CAAC,CAAC;MACnG,KAAK,IAAIvC,EAAE,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAAChC,KAAK,CAACwJ,MAAM,EAAEzH,EAAE,GAAGC,EAAE,CAACE,MAAM,EAAEH,EAAE,EAAE,EAAE;QAC3D,IAAIyH,MAAM,GAAGxH,EAAE,CAACD,EAAE,CAAC;QACnB,IAAIoB,IAAI,CAAC4D,IAAI,KAAKyC,MAAM,CAACC,SAAS,IAAItG,IAAI,CAAC4D,IAAI,KAAKyC,MAAM,CAACE,SAAS,EAAE;UAClEH,cAAc,GAAGC,MAAM,CAACG,OAAO;UAC/B,IAAIJ,cAAc,EAAE;YAChB;UACJ,CAAC,MACI;YACD;UACJ;QACJ;MACJ;MACA,IAAI,CAACA,cAAc,EAAE;QACjB;MACJ;MACAD,QAAQ,GAAG,IAAI,CAACM,gBAAgB,CAACzG,IAAI,CAAC;MACtC,IAAIA,IAAI,CAACwC,WAAW,KAAK,YAAY,EAAE;QACnCxC,IAAI,CAAC0G,gBAAgB,EAAE;QACvB,IAAI1G,IAAI,CAACwG,OAAO,IAAIxG,IAAI,CAAC2G,kBAAkB,IAAI3G,IAAI,CAAC4G,SAAS,CAACxJ,KAAK,GAAG,CAAC,EAAE;UACrE,IAAI,CAACyJ,YAAY,CAAC7G,IAAI,EAAEmB,CAAC,EAAEnB,IAAI,CAACuB,UAAU,EAAE,CAAC,EAAE4E,QAAQ,GAAGD,cAAc,GAAG,IAAI,CAACF,OAAO,EAAEhG,IAAI,CAAC8G,WAAW,CAAC;QAC9G;QACA,IAAI9G,IAAI,CAAC+G,cAAc,CAAC3J,KAAK,GAAG,CAAC,IAAI4C,IAAI,CAACgH,cAAc,CAAC5J,KAAK,GAAG,CAAC,EAAE;UAChE,IAAI,CAAC6J,iBAAiB,CAACjH,IAAI,EAAEmB,CAAC,EAAGgF,QAAQ,IAAInG,IAAI,CAACkH,YAAY,KAAK,QAAQ,GAAIhB,cAAc,GAAG,IAAI,CAACF,OAAO,EAAEhG,IAAI,CAAC8G,WAAW,CAAC;QACnI;QACA,IAAI9G,IAAI,CAACwG,OAAO,IAAIxG,IAAI,CAAC2G,kBAAkB,EAAE;UACzC,IAAI,CAACQ,eAAe,CAACnH,IAAI,EAAEmB,CAAC,EAAGgF,QAAQ,IAAInG,IAAI,CAACoH,aAAa,KAAK,QAAQ,GAAIlB,cAAc,GAAG,IAAI,CAACF,OAAO,EAAGhG,IAAI,CAACqH,mBAAmB,GAAGrH,IAAI,CAAC8G,WAAW,GAAG9G,IAAI,CAAC/C,IAAI,CAAE;UACvK,IAAI,CAACqK,eAAe,CAACtH,IAAI,EAAEmB,CAAC,EAAGgF,QAAQ,IAAInG,IAAI,CAACoH,aAAa,KAAK,QAAQ,GAAIlB,cAAc,GAAG,IAAI,CAACF,OAAO,EAAGhG,IAAI,CAACqH,mBAAmB,GAAGrH,IAAI,CAAC8G,WAAW,GAAG9G,IAAI,CAAC/C,IAAI,CAAE;UACvK,IAAI,CAACsK,cAAc,CAACvH,IAAI,EAAEmB,CAAC,EAAEgF,QAAQ,GAAGD,cAAc,GAAG,IAAI,CAACF,OAAO,EAAGhG,IAAI,CAACqH,mBAAmB,GAAGrH,IAAI,CAAC8G,WAAW,GAAG9G,IAAI,CAAC/C,IAAI,CAAE;QACrI;MACJ,CAAC,MACI;QACD+C,IAAI,CAAC0G,gBAAgB,EAAE;QACvB,IAAI1G,IAAI,CAACwG,OAAO,IAAIxG,IAAI,CAAC2G,kBAAkB,IAAI3G,IAAI,CAAC4G,SAAS,CAACxJ,KAAK,GAAG,CAAC,EAAE;UACrE,IAAI,CAACyJ,YAAY,CAAC7G,IAAI,EAAEmB,CAAC,EAAE,CAAC,EAAEnB,IAAI,CAACuB,UAAU,EAAE4E,QAAQ,GAAGD,cAAc,GAAG,IAAI,CAACF,OAAO,EAAEhG,IAAI,CAAC8G,WAAW,CAAC;QAC9G;QACA,IAAI9G,IAAI,CAAC+G,cAAc,CAAC3J,KAAK,GAAG,CAAC,IAAI4C,IAAI,CAACgH,cAAc,CAAC5J,KAAK,GAAG,CAAC,EAAE;UAChE,IAAI,CAACoK,iBAAiB,CAACxH,IAAI,EAAEmB,CAAC,EAAGgF,QAAQ,IAAInG,IAAI,CAACkH,YAAY,KAAK,QAAQ,GAAIhB,cAAc,GAAG,IAAI,CAACF,OAAO,EAAEhG,IAAI,CAAC8G,WAAW,CAAC;QACnI;QACA,IAAI9G,IAAI,CAACwG,OAAO,IAAIxG,IAAI,CAAC2G,kBAAkB,EAAE;UACzC,IAAI,CAACc,eAAe,CAACzH,IAAI,EAAEmB,CAAC,EAAGgF,QAAQ,IAAInG,IAAI,CAACoH,aAAa,KAAK,QAAQ,GAAIlB,cAAc,GAAG,IAAI,CAACF,OAAO,EAAGhG,IAAI,CAACqH,mBAAmB,GAAGrH,IAAI,CAAC8G,WAAW,GAAG9G,IAAI,CAAC/C,IAAI,CAAE;UACvK,IAAI,CAACyK,eAAe,CAAC1H,IAAI,EAAEmB,CAAC,EAAGgF,QAAQ,IAAInG,IAAI,CAACoH,aAAa,KAAK,QAAQ,GAAIlB,cAAc,GAAG,IAAI,CAACF,OAAO,EAAGhG,IAAI,CAACqH,mBAAmB,GAAGrH,IAAI,CAAC8G,WAAW,GAAG9G,IAAI,CAAC/C,IAAI,CAAE;UACvK,IAAI,CAAC0K,cAAc,CAAC3H,IAAI,EAAEmB,CAAC,EAAEgF,QAAQ,GAAGD,cAAc,GAAG,IAAI,CAACF,OAAO,EAAGhG,IAAI,CAACqH,mBAAmB,GAAGrH,IAAI,CAAC8G,WAAW,GAAG9G,IAAI,CAAC/C,IAAI,CAAE;QACrI;MACJ;MACA,IAAI,CAAC,IAAI,CAACJ,KAAK,CAAC+K,YAAY,EAAE;QAC1BhC,WAAW,CAACiC,WAAW,CAAC,IAAI,CAAC7B,OAAO,CAAC;QACrC,IAAIE,cAAc,IAAIA,cAAc,CAAC4B,UAAU,CAAC/I,MAAM,GAAG,CAAC,EAAE;UACxDkH,eAAe,CAAC4B,WAAW,CAAC3B,cAAc,CAAC;QAC/C;MACJ;MACA,IAAIrJ,KAAK,CAACqD,eAAe,KAAMrD,KAAK,CAACuD,YAAY,CAACC,eAAe,IAAIL,IAAI,CAACM,wBAAwB,IAC9FN,IAAI,CAACU,iBAAiB,CAACC,MAAM,CAAC,EAAE;QAChC,IAAI,CAACoH,eAAe,CAAClL,KAAK,EAAEmD,IAAI,CAAC;MACrC;IACJ;IACA,IAAI,CAACgG,OAAO,GAAGnJ,KAAK,CAACgJ,QAAQ,CAACC,WAAW,CAAC;MAAEC,EAAE,EAAElJ,KAAK,CAACmJ,OAAO,CAACD,EAAE,GAAG;IAAiB,CAAC,CAAC;IACtF,KAAK,IAAI1E,CAAC,GAAG,CAAC,EAAED,GAAG,GAAGvE,KAAK,CAACiC,IAAI,CAACC,MAAM,EAAEsC,CAAC,GAAGD,GAAG,EAAEC,CAAC,EAAE,EAAE;MACnD,IAAInC,GAAG,GAAGrC,KAAK,CAACiC,IAAI,CAACuC,CAAC,CAAC;MACvB,IAAInC,GAAG,CAAC8I,MAAM,CAACC,KAAK,EAAE;QAClB,IAAI,CAACC,cAAc,CAAChJ,GAAG,EAAEmC,CAAC,EAAE,IAAI,CAAC;MACrC;IACJ;IACA,KAAK,IAAIA,CAAC,GAAG,CAAC,EAAED,GAAG,GAAGvE,KAAK,CAAC6C,OAAO,CAACX,MAAM,EAAEsC,CAAC,GAAGD,GAAG,EAAEC,CAAC,EAAE,EAAE;MACtD,IAAI7B,MAAM,GAAG3C,KAAK,CAAC6C,OAAO,CAAC2B,CAAC,CAAC;MAC7B,IAAI7B,MAAM,CAACwI,MAAM,CAACC,KAAK,EAAE;QACrB,IAAI,CAACC,cAAc,CAAC1I,MAAM,EAAE6B,CAAC,EAAE,KAAK,CAAC;MACzC;IACJ;IACA,IAAI,CAAC,IAAI,CAACxE,KAAK,CAAC+K,YAAY,EAAE;MAC1BhC,WAAW,CAACiC,WAAW,CAAC,IAAI,CAAC7B,OAAO,CAAC;IACzC;IACAtK,kBAAkB,CAACmB,KAAK,CAAC+K,YAAY,EAAE/K,KAAK,CAACsL,SAAS,EAAEvC,WAAW,EAAE/I,KAAK,CAACuL,MAAM,CAAC;IAClF,OAAOnC,eAAe;EAC1B,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACItJ,wBAAwB,CAACI,SAAS,CAACgL,eAAe,GAAG,UAAUlL,KAAK,EAAEmD,IAAI,EAAE;IACxE,IAAIO,QAAQ,GAAGvF,iBAAiB,CAAC6B,KAAK,CAACsD,UAAU,CAAC,GAAG,KAAK,GAAGtD,KAAK,CAACsD,UAAU,CAACI,QAAQ;IACtF,IAAI,CAAEA,QAAQ,KAAKP,IAAI,CAACQ,UAAU,GAAG,CAAC,IAAIR,IAAI,CAACS,YAAY,GAAG,CAAC,CAAC,IAAMT,IAAI,CAACU,iBAAiB,CAACC,MAAM,KAC9FX,IAAI,CAACQ,UAAU,IAAI,CAAC,IAAIR,IAAI,CAACS,YAAY,IAAI,CAAC,CAAE,MAChD,CAACT,IAAI,CAACqI,gBAAgB,CAACC,UAAU,IAAIzL,KAAK,CAAC0L,aAAa,CAAC,CAAC,CAAC,CAACvE,IAAI,CAACY,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,EAAE;MACxF,IAAI,CAAC/H,KAAK,CAAC2L,aAAa,EAAE;QACtB3L,KAAK,CAAC2L,aAAa,GAAGnN,aAAa,CAACwB,KAAK,CAACuL,MAAM,EAAEvL,KAAK,CAACmJ,OAAO,CAACD,EAAE,GAAG,gBAAgB,CAAC,IAAIhL,aAAa,CAAC,KAAK,EAAE;UAAEgL,EAAE,EAAElJ,KAAK,CAACmJ,OAAO,CAACD,EAAE,GAAG;QAAiB,CAAC,CAAC;MAC/J;MACArK,kBAAkB,CAAC,KAAK,EAAEmB,KAAK,CAAC2L,aAAa,EAAExI,IAAI,CAACqI,gBAAgB,CAACI,MAAM,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC;IAC5F,CAAC,MACI,IAAIzI,IAAI,CAACQ,UAAU,KAAK,CAAC,IAAIR,IAAI,CAACS,YAAY,KAAK,CAAC,IAAIT,IAAI,CAACqI,gBAAgB,CAACF,SAAS,IAAI,CAACnI,IAAI,CAACU,iBAAiB,CAACC,MAAM,EAAE;MAC5HX,IAAI,CAACqI,gBAAgB,CAACK,OAAO,EAAE;IACnC;IACA,IAAI1I,IAAI,CAACqI,gBAAgB,CAACC,UAAU,EAAE;MAClCtI,IAAI,CAACqI,gBAAgB,CAACC,UAAU,GAAG,KAAK;IAC5C;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACI3L,wBAAwB,CAACI,SAAS,CAAC0J,gBAAgB,GAAG,UAAUzG,IAAI,EAAE;IAClE,OAAOA,IAAI,CAAC1C,OAAO,KAAK,IAAI,IAAI0C,IAAI,CAACmG,QAAQ,CAACnG,IAAI,CAACwD,WAAW,CAACmF,YAAY,CAAC;EAChF,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIhM,wBAAwB,CAACI,SAAS,CAACmL,cAAc,GAAG,UAAUtI,UAAU,EAAEgJ,KAAK,EAAEC,KAAK,EAAE;IACpF,IAAIhM,KAAK,GAAG,IAAI,CAACA,KAAK;IACtB,IAAIiM,WAAW,GAAG,CAAC,CAAC;IACpB,IAAIC,EAAE;IACN,IAAIC,EAAE;IACN,IAAIC,EAAE;IACN,IAAIC,EAAE;IACN,IAAIC,cAAc;IAClB,IAAIN,KAAK,EAAE;MACPjJ,UAAU,GAAGA,UAAU;MACvBqJ,EAAE,GAAGC,EAAE,GAAGtJ,UAAU,CAAC+B,WAAW,GAAG/B,UAAU,CAACL,cAAc;MAC5DwJ,EAAE,GAAG,IAAI,CAACxL,cAAc,CAACC,CAAC;MAC1BwL,EAAE,GAAGD,EAAE,GAAG,IAAI,CAACxL,cAAc,CAACH,KAAK;MACnC+L,cAAc,GAAG,KAAK;IAC1B,CAAC,MACI;MACDvJ,UAAU,GAAGA,UAAU;MACvBmJ,EAAE,GAAGC,EAAE,GAAGpJ,UAAU,CAACsC,YAAY;MACjC+G,EAAE,GAAG,IAAI,CAAC1L,cAAc,CAACE,CAAC;MAC1ByL,EAAE,GAAGD,EAAE,GAAG,IAAI,CAAC1L,cAAc,CAACG,MAAM;MACpCyL,cAAc,GAAG,QAAQ;IAC7B;IACAL,WAAW,GAAG;MACV,IAAI,EAAEjM,KAAK,CAACmJ,OAAO,CAACD,EAAE,GAAG,cAAc,GAAGoD,cAAc,GAAGP,KAAK;MAChEG,EAAE,EAAEA,EAAE;MACNE,EAAE,EAAEA,EAAE;MACND,EAAE,EAAEA,EAAE;MACNE,EAAE,EAAEA,EAAE;MACN,cAAc,EAAEtJ,UAAU,CAACoI,MAAM,CAAC5K,KAAK;MACvC,QAAQ,EAAEwC,UAAU,CAACoI,MAAM,CAACC;IAChC,CAAC;IACD,IAAI,CAACmB,UAAU,GAAGvM,KAAK,CAACgJ,QAAQ,CAACwD,QAAQ,CAACP,WAAW,CAAC;IACtD,IAAI,CAAC9C,OAAO,CAAC6B,WAAW,CAAC,IAAI,CAACuB,UAAU,CAAC;EAC7C,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIzM,wBAAwB,CAACI,SAAS,CAAC8J,YAAY,GAAG,UAAU7G,IAAI,EAAE4I,KAAK,EAAEU,KAAK,EAAEC,KAAK,EAAEC,MAAM,EAAEvM,IAAI,EAAE;IACjG,IAAIJ,KAAK,GAAG,IAAI,CAACA,KAAK;IACtB,IAAIiM,WAAW,GAAG,CAAC,CAAC;IACpB,IAAI9C,OAAO,GAAGjK,UAAU,CAACc,KAAK,CAACmJ,OAAO,CAACD,EAAE,GAAG,WAAW,GAAG6C,KAAK,CAAC;IAChE,IAAIa,SAAS,GAAGzD,OAAO,GAAGA,OAAO,CAAC0D,YAAY,CAAC,GAAG,CAAC,GAAG,EAAE;IACxD1D,OAAO,GAAG,IAAI;IACd8C,WAAW,GAAG;MACV,IAAI,EAAEjM,KAAK,CAACmJ,OAAO,CAACD,EAAE,GAAG,WAAW,GAAG6C,KAAK;MAC5C,GAAG,EAAE,IAAI,IAAI3L,IAAI,CAACO,CAAC,GAAG8L,KAAK,CAAC,GAAG,GAAG,IAAIrM,IAAI,CAACQ,CAAC,GAAG8L,KAAK,CAAC,GACjD,KAAK,IAAItM,IAAI,CAACO,CAAC,GAAGP,IAAI,CAACG,KAAK,GAAGkM,KAAK,CAAC,GAAG,GAAG,IAAIrM,IAAI,CAACQ,CAAC,GAAGR,IAAI,CAACS,MAAM,GAAG6L,KAAK,CAAC;MAChF,kBAAkB,EAAEvJ,IAAI,CAAC4G,SAAS,CAAC+C,SAAS;MAC5C,cAAc,EAAE3J,IAAI,CAAC4G,SAAS,CAACxJ,KAAK;MACpC,QAAQ,EAAE4C,IAAI,CAAC4G,SAAS,CAACqB,KAAK,IAAIpL,KAAK,CAAC+M,UAAU,CAACC;IACvD,CAAC;IACD,IAAI,CAACT,UAAU,GAAGvM,KAAK,CAACgJ,QAAQ,CAACiE,QAAQ,CAAChB,WAAW,CAAC;IACtDpN,kBAAkB,CAACmB,KAAK,CAAC+K,YAAY,EAAE4B,MAAM,EAAE,IAAI,CAACJ,UAAU,EAAEvM,KAAK,CAACuL,MAAM,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAEqB,SAAS,CAAC;EAClH,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI9M,wBAAwB,CAACI,SAAS,CAACyK,iBAAiB,GAAG,UAAUxH,IAAI,EAAE4I,KAAK,EAAEY,MAAM,EAAEvM,IAAI,EAAE;IACxF,IAAI8M,SAAS,GAAG/J,IAAI,CAAC6D,SAAS,KAAK,aAAa;IAChD,IAAImG,cAAc,GAAGhK,IAAI,CAAC6D,SAAS,CAACe,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;IAC5D,IAAIqF,YAAY;IAChB,IAAIC,MAAM,GAAG,CAAC;IACd,IAAIC,SAAS,GAAG,EAAE;IAClB,IAAIC,SAAS,GAAG,EAAE;IAClB,IAAIC,kBAAkB;IACtB,IAAIC,SAAS,GAAGtK,IAAI,CAAC+B,qBAAqB;IAC1C,IAAIwI,QAAQ,GAAGD,SAAS,GAAGtK,IAAI,CAACgH,cAAc,CAACtJ,MAAM,GAAG,CAACsC,IAAI,CAACgH,cAAc,CAACtJ,MAAM;IACnF,IAAI8M,YAAY,GAAIF,SAAS,GAAItK,IAAI,CAAC4G,SAAS,CAACxJ,KAAK,GAAG,GAAG,GAAG,CAAC4C,IAAI,CAAC4G,SAAS,CAACxJ,KAAK,GAAG,GAAG;IACzF,IAAIqN,aAAa,GAAIzK,IAAI,CAAC6D,SAAS,KAAK,UAAU,IAAI7D,IAAI,CAAC0K,cAAc,KAAK,cAAc,GACxF,GAAG,GAAG,CAAC;IACX,IAAIzK,eAAe,GAAGjF,iBAAiB,CAACgF,IAAI,CAACqD,SAAS,CAAC,GAAGiH,SAAS,GAAGtK,IAAI,CAACC,eAAe,GACtF,CAACD,IAAI,CAACC,eAAe,GAAG,CAAC;IAC7B,IAAI0K,YAAY,GAAG3K,IAAI,CAACkH,YAAY,KAAK,QAAQ;IACjD,IAAI0D,KAAK,GAAGD,YAAY,GAAI1N,IAAI,CAACO,CAAC,GAAG+M,QAAQ,GAAGC,YAAY,GAAKvN,IAAI,CAACO,CAAC,GAAG+M,QAAQ,GAAGC,YAAY,GAAGvK,eAAgB;IACpH,IAAIlB,MAAM,GAAGiB,IAAI,CAAC6K,aAAa,CAAC9L,MAAM;IACtC,IAAI+L,eAAe,GAAG,IAAI,CAACjO,KAAK,CAAC+M,UAAU;IAC3C,IAAI5J,IAAI,CAAC6D,SAAS,CAACe,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,IAAI5E,IAAI,CAAC0K,cAAc,KAAK,cAAc,IAAI3L,MAAM,GAAG,CAAC,EAAE;MACjGA,MAAM,IAAI,CAAC;IACf;IACA,IAAIgM,cAAc,GAAG/K,IAAI,CAAC+K,cAAc;IACxC,IAAIC,cAAc,GAAGhL,IAAI,CAACgL,cAAc;IACxC;IACA,KAAK,IAAI7J,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGpC,MAAM,EAAEoC,CAAC,EAAE,EAAE;MAC7B8I,YAAY,GAAG,CAACjK,IAAI,CAAC6K,aAAa,CAAC1J,CAAC,CAAC,GAAInB,IAAI,CAAC6K,aAAa,CAAC1J,CAAC,GAAG,CAAC,CAAC,CAAC8J,KAAK,GAAGjL,IAAI,CAAC2I,YAAY,CAACuC,QAAQ,GAAIT,aAAa,GAChHzK,IAAI,CAAC6K,aAAa,CAAC1J,CAAC,CAAC,CAAC8J,KAAK,GAAGR,aAAa;MACjDP,MAAM,GAAG/O,kBAAkB,CAAC8O,YAAY,EAAEjK,IAAI,CAAC,GAAG/C,IAAI,CAACS,MAAM;MAC7DwM,MAAM,GAAIA,MAAM,GAAG,CAAC,CAAC,IAAKjN,IAAI,CAACQ,CAAC,GAAGR,IAAI,CAACS,MAAM,CAAC;MAC/C,IAAIwM,MAAM,IAAIjN,IAAI,CAACQ,CAAC,IAAKR,IAAI,CAACQ,CAAC,GAAGR,IAAI,CAACS,MAAM,IAAKwM,MAAM,EAAE;QACtD,IAAKzO,MAAM,CAACwO,YAAY,EAAEjK,IAAI,CAAC2I,YAAY,CAAC,IAAK,IAAI,CAACwC,QAAQ,CAACnL,IAAI,EAAEmB,CAAC,EAAE+I,MAAM,CAAC,EAAE;UAC7EC,SAAS,GAAG,IAAI,GAAG,IAAI,CAAC5M,cAAc,CAACC,CAAC,GAAG,GAAG,GAAI0M,MAAO,GACrD,KAAK,IAAI,IAAI,CAAC3M,cAAc,CAACC,CAAC,GAAG,IAAI,CAACD,cAAc,CAACH,KAAK,CAAC,GAAG,GAAG,GAAG8M,MAAM;UAC9E,IAAI,CAACkB,cAAc,CAACpL,IAAI,EAAE4I,KAAK,EAAEuB,SAAS,EAAEnK,IAAI,CAAC+G,cAAc,EAAE,iBAAiB,EAAE5F,CAAC,EAAE,IAAI,CAAC6E,OAAO,EAAE8E,eAAe,CAACO,aAAa,EAAErL,IAAI,CAAC+G,cAAc,CAAC4C,SAAS,CAAC;QACtK;QACAS,SAAS,GAAG,IAAI,IAAInN,IAAI,CAACO,CAAC,GAAGgN,YAAY,IAAIG,YAAY,GAAG1K,eAAe,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,GAAGiK,MAAM,GAC5F,KAAK,GAAIU,KAAM,GAAG,GAAG,GAAGV,MAAM;QAClC,IAAI,CAACkB,cAAc,CAACpL,IAAI,EAAE4I,KAAK,EAAEwB,SAAS,EAAEpK,IAAI,CAACgH,cAAc,EAAE,iBAAiB,EAAE7F,CAAC,EAAEqI,MAAM,EAAEsB,eAAe,CAACQ,aAAa,CAAC;QAC7H,IAAI,CAACP,cAAc,CAAC3N,KAAK,GAAG,CAAC,IAAI4N,cAAc,CAAC5N,KAAK,GAAG,CAAC,KAAK4C,IAAI,CAACuL,qBAAqB,GAAG,CAAC,EAAE;UAC1F,IAAIpK,CAAC,KAAK,CAAC,IAAI1E,SAAS,CAACuD,IAAI,CAAC,IAAI,CAAC+J,SAAS,IAAI,CAACC,cAAc,EAAE;YAC7D,IAAI,CAACwB,wBAAwB,CAACxL,IAAI,EAAEiK,YAAY,EAAEhN,IAAI,EAAEkE,CAAC,EAAEyH,KAAK,EAAEkC,eAAe,EAAEtB,MAAM,CAAC;UAC9F;UACAa,kBAAkB,GAAG,IAAI,CAACoB,iBAAiB,CAACzL,IAAI,EAAEiK,YAAY,EAAEhN,IAAI,EAAEkE,CAAC,CAAC;UACxE,IAAI,CAACiK,cAAc,CAACpL,IAAI,EAAE4I,KAAK,EAAEyB,kBAAkB,CAAC,CAAC,CAAC,EAAEU,cAAc,EAAE,iBAAiB,EAAE5J,CAAC,EAAE,IAAI,CAAC6E,OAAO,EAAE8E,eAAe,CAACY,aAAa,EAAEX,cAAc,CAACpB,SAAS,CAAC;UACpK,IAAI,CAACyB,cAAc,CAACpL,IAAI,EAAE4I,KAAK,EAAEyB,kBAAkB,CAAC,CAAC,CAAC,EAAEW,cAAc,EAAE,iBAAiB,EAAE7J,CAAC,EAAEqI,MAAM,EAAEsB,eAAe,CAACa,aAAa,CAAC;UACpI,IAAIxK,CAAC,KAAKpC,MAAM,GAAG,CAAC,IAAItC,SAAS,CAACuD,IAAI,CAAC,IAAI+J,SAAS,IAAI,CAACC,cAAc,EAAE;YACrE,IAAI,CAACwB,wBAAwB,CAACxL,IAAI,EAAGiK,YAAY,GAAGjK,IAAI,CAAC2I,YAAY,CAACuC,QAAQ,EAAGjO,IAAI,EAAEkE,CAAC,EAAEyH,KAAK,EAAEkC,eAAe,EAAEtB,MAAM,CAAC;UAC7H;QACJ;MACJ;IACJ;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI7M,wBAAwB,CAACI,SAAS,CAACoO,QAAQ,GAAG,UAAUnL,IAAI,EAAE4I,KAAK,EAAEqC,KAAK,EAAE;IACxE,IAAIjD,MAAM,GAAG,IAAI,CAACnL,KAAK,CAACM,SAAS,CAAC6K,MAAM;IACxC,IAAI/K,IAAI,GAAG,IAAI,CAACM,cAAc;IAC9B,IAAIiF,WAAW,GAAGxC,IAAI,CAACwC,WAAW;IAClC,IAAIoJ,KAAK,GAAIpJ,WAAW,KAAK,YAAY,GAAIvF,IAAI,CAACO,CAAC,GAAGP,IAAI,CAACQ,CAAC;IAC5D,IAAIoC,IAAI,GAAI2C,WAAW,KAAK,YAAY,GAAIvF,IAAI,CAACG,KAAK,GAAGH,IAAI,CAACS,MAAM;IACpE,IAAImO,UAAU,GAAIrJ,WAAW,KAAK,YAAY,GAAI,CAAC,GAAGxC,IAAI,CAAC6K,aAAa,CAAC9L,MAAM,GAAG,CAAC;IACnF,IAAI+M,QAAQ,GAAItJ,WAAW,KAAK,YAAY,GAAIxC,IAAI,CAAC6K,aAAa,CAAC9L,MAAM,GAAG,CAAC,GAAG,CAAC;IACjF,IAAIiB,IAAI,CAACuB,UAAU,GAAG,CAAC,EAAE;MACrB,OAAO,IAAI;IACf,CAAC,MACI,IAAI,CAAC0J,KAAK,KAAKW,KAAK,IAAIX,KAAK,KAAMW,KAAK,GAAG/L,IAAK,MAAMmI,MAAM,CAAC5K,KAAK,IAAI,CAAC,IAAI4K,MAAM,CAACC,KAAK,KAAK,aAAa,CAAC,EAAE;MAC7G,OAAO,IAAI;IACf,CAAC,MACI,IAAKgD,KAAK,KAAKW,KAAK,IAAIhD,KAAK,KAAKiD,UAAU,IAAMZ,KAAK,KAAMW,KAAK,GAAG/L,IAAK,IAAI+I,KAAK,KAAKkD,QAAS,EAAE;MACpG,OAAO,IAAI;IACf;IACA,OAAO,KAAK;EAChB,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACInP,wBAAwB,CAACI,SAAS,CAAC0K,eAAe,GAAG,UAAUzH,IAAI,EAAE4I,KAAK,EAAEY,MAAM,EAAEvM,IAAI,EAAE;IACtF,IAAIJ,KAAK,GAAG,IAAI,CAACA,KAAK;IACtB,IAAIkP,KAAK;IACT,IAAIC,MAAM,GAAG,CAAC;IACd,IAAI9B,MAAM,GAAG,CAAC;IACd,IAAI+B,WAAW;IACf,IAAIC,UAAU,GAAGlM,IAAI,CAACmM,YAAY;IAClC,IAAIC,OAAO;IACX,IAAIC,gBAAgB;IACpB,IAAIC,aAAa,GAAGtM,IAAI,CAACoH,aAAa,KAAK,QAAQ;IACnD,IAAIkD,SAAS,GAAGtK,IAAI,CAAC+B,qBAAqB;IAC1C,IAAIwK,SAAS,GAAGvM,IAAI,CAACoH,aAAa,KAAKpH,IAAI,CAACkH,YAAY,GAAGlH,IAAI,CAACgH,cAAc,CAACtJ,MAAM,GAAG,CAAC;IACzF,IAAIZ,OAAO,GAAGyP,SAAS,GAAGL,UAAU,GAAGlM,IAAI,CAAC4G,SAAS,CAACxJ,KAAK,GAAG,GAAG;IACjE,IAAIoP,KAAK,GAAGxM,IAAI,CAACwM,KAAK,GAAG,GAAG;IAC5B1P,OAAO,GAAIwN,SAAS,GAAIxN,OAAO,GAAG,CAACA,OAAO;IAC1C,IAAI2P,YAAY,GAAG5P,KAAK,CAACgJ,QAAQ,CAACC,WAAW,CAAC;MAAEC,EAAE,EAAElJ,KAAK,CAACmJ,OAAO,CAACD,EAAE,GAAG,YAAY,GAAG6C;IAAM,CAAC,CAAC;IAC9F,IAAI3I,eAAe,GAAGjF,iBAAiB,CAACgF,IAAI,CAACqD,SAAS,CAAC,GAAGrD,IAAI,CAACC,eAAe,IAAIqK,SAAS,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC;IACzG,IAAIoC,UAAU;IACd,IAAIC,WAAW;IACf,IAAIC,YAAY;IAChB,IAAIC,KAAK,GAAG,EAAE;IACd,IAAIC,SAAS,GAAG9M,IAAI,CAAC+M,aAAa;IAClC,IAAIC,WAAW,GAAGF,SAAS,GAAG7P,IAAI,CAACQ,CAAC,GAAIR,IAAI,CAACQ,CAAC,GAAGR,IAAI,CAACS,MAAO;IAC7D,IAAIyO,YAAY;IAChB,IAAIc,cAAc;IAClB,IAAIC,WAAW;IACf,IAAIC,WAAW;IACf,IAAIC,qBAAqB,GAAK,CAAC9C,SAAS,IAAI,CAACgC,aAAa,IAAMhC,SAAS,IAAIgC,aAAe;IAC5F,IAAIA,aAAa,EAAE;MACfH,YAAY,GAAG,CAACiB,qBAAqB,GAAG,CAACtQ,OAAO,GAAGA,OAAO;IAC9D,CAAC,MACI;MACDqP,YAAY,GAAG,CAACiB,qBAAqB,GAAG,CAACtQ,OAAO,GAAGmD,eAAe,GAAGnD,OAAO,GAAGmD,eAAe;IAClG;IACA,IAAIoN,SAAS,GAAG,EAAE;IAClB,IAAIC,mBAAmB,GAAG,EAAE;IAC5BtN,IAAI,CAAC6K,aAAa,CAAC0C,GAAG,CAAC,UAAUvO,IAAI,EAAE;MACnCqO,SAAS,CAAC3K,IAAI,CAAC1D,IAAI,CAACa,IAAI,CAAC,OAAO,CAAC,CAAC;MAClCyN,mBAAmB,CAAC5K,IAAI,CAAC1D,IAAI,CAACwO,cAAc,CAAC,OAAO,CAAC,CAAC;IAC1D,CAAC,CAAC;IACF,IAAIC,aAAa,GAAGpI,IAAI,CAACC,GAAG,CAACoI,KAAK,CAACrI,IAAI,EAAEgI,SAAS,CAAC;IACnD,IAAIM,kBAAkB,GAAGtI,IAAI,CAACC,GAAG,CAACoI,KAAK,CAACrI,IAAI,EAAEiI,mBAAmB,CAAC;IAClE,KAAK,IAAInM,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGpB,IAAI,CAAC6K,aAAa,CAAC9L,MAAM,EAAEoC,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MAC3D4K,KAAK,GAAG/L,IAAI,CAAC6K,aAAa,CAAC1J,CAAC,CAAC;MAC7BkL,gBAAgB,GAAG/Q,YAAY,CAAC0E,IAAI,CAAC6K,aAAa,CAAC1J,CAAC,CAAC,CAACyM,YAAY,CAAC;MACnE3B,WAAW,GAAGI,gBAAgB,GAAGrM,IAAI,CAAC6K,aAAa,CAAC1J,CAAC,CAAC,CAACqM,cAAc,GAAGxN,IAAI,CAAC6K,aAAa,CAAC1J,CAAC,CAAC,CAACtB,IAAI;MAClGqK,MAAM,GAAI/O,kBAAkB,CAAC6E,IAAI,CAAC6K,aAAa,CAAC1J,CAAC,CAAC,CAAC8J,KAAK,EAAEjL,IAAI,CAAC,GAAG/C,IAAI,CAACS,MAAM,IAAKb,KAAK,CAACgR,UAAU,GAAG,CAAC,GAAG,CAAC,CAAC;MAC3G3D,MAAM,GAAG7E,IAAI,CAACyI,KAAK,CAAE5D,MAAM,GAAG,CAAC,CAAC,IAAKjN,IAAI,CAACQ,CAAC,GAAGR,IAAI,CAACS,MAAM,CAAC,CAAC;MAC3DgP,UAAU,GAAKT,WAAW,CAACvO,MAAM,GAAG,CAAC,GAAIsC,IAAI,CAAC6K,aAAa,CAAC1J,CAAC,CAAC,CAAC4M,IAAI,CAAChP,MAAM,GAAG,CAAE;MAC/E4N,WAAW,GAAKV,WAAW,CAACvO,MAAM,GAAG,CAAC,GAAI,CAAC,GAAI,CAAC;MAChDuP,cAAc,GAAGhQ,IAAI,CAACS,MAAM,GAAGsC,IAAI,CAAC6K,aAAa,CAAC9L,MAAM;MACxDmO,WAAW,GAAI,CAAClN,IAAI,CAACgO,oBAAoB,KAAK,MAAM,IAAIhO,IAAI,CAACgO,oBAAoB,KAAK,MAAM,KAAKxB,KAAK,KAAK,CAAC,IACxGP,WAAW,CAAC7O,KAAK,GAAG6P,cAAc,GAAIA,cAAc,GAAGhB,WAAW,CAAC7O,KAAK;MAC5E8M,MAAM,GAAImC,gBAAgB,GAAIrM,IAAI,CAACoH,aAAa,KAAK,QAAQ,GAAI8C,MAAM,GAAI+B,WAAW,CAACvO,MAAM,GAAG,CAAE,GAAGgP,UAAU,GAAGC,WAAW,GACtHzC,MAAM,GAAGwC,UAAW,GAAK1M,IAAI,CAACoH,aAAa,KAAK,QAAQ,GAAG8C,MAAM,GAAGyC,WAAW,GAAGzC,MAAQ;MACjG,IAAIlK,IAAI,CAAC+G,cAAc,CAAC3J,KAAK,GAAG4C,IAAI,CAACgH,cAAc,CAAC5J,KAAK,EAAE;QACvDwP,YAAY,GAAG5M,IAAI,CAAC+G,cAAc,CAAC3J,KAAK;MAC5C,CAAC,MACI;QACDwP,YAAY,GAAG5M,IAAI,CAACgH,cAAc,CAAC5J,KAAK;MAC5C;MACA,IAAI4C,IAAI,CAACiO,UAAU,CAACC,aAAa,KAAK,KAAK,EAAE;QACzChE,MAAM,GAAGA,MAAM,GAAG0C,YAAY,GAAGC,KAAK;MAC1C,CAAC,MACI,IAAI7M,IAAI,CAACiO,UAAU,CAACC,aAAa,KAAK,MAAM,EAAE;QAC/ChE,MAAM,GAAGA,MAAM,GAAG0C,YAAY,GAAGC,KAAK;MAC1C,CAAC,MACI,IAAI7M,IAAI,CAACiO,UAAU,CAACC,aAAa,KAAK,QAAQ,EAAE;QACjD;QACAhE,MAAM,GAAGA,MAAM;MACnB;MACA;MACA,IAAIoC,aAAa,EAAE;QACfa,WAAW,GAAGhB,YAAY,GAAI,CAACK,KAAK,KAAK,CAAC,GAAGP,WAAW,CAAC7O,KAAK,GAAIiP,gBAAgB,GAAGsB,kBAAkB,GAAGF,aAAc,IAAI,CAAE;MAClI,CAAC,MACI;QACDN,WAAW,GAAGhB,YAAY,GAAI,CAACK,KAAK,KAAK,CAAC,GAAGP,WAAW,CAAC7O,KAAK,GAAIiP,gBAAgB,GAAGsB,kBAAkB,GAAGF,aAAc,IAAI,CAAE;MAClI;MACAzB,MAAM,GAAG1B,SAAS,GAAIrN,IAAI,CAACO,CAAC,GAAG2P,WAAW,GAAKlQ,IAAI,CAACO,CAAC,GAAG2P,WAAY;MACpEA,WAAW,GAAGhB,YAAY;MAC1BC,OAAO,GAAG,IAAIjQ,UAAU,CAACU,KAAK,CAACmJ,OAAO,CAACD,EAAE,GAAG6C,KAAK,GAAG,aAAa,GAAGzH,CAAC,EAAE6K,MAAM,EAAE9B,MAAM,EAAE,QAAQ,EAAE6B,KAAK,CAACgC,IAAI,EAAE,EAAE,EAAE,QAAQ,CAAC;MAC1H,QAAQ/N,IAAI,CAACmO,kBAAkB;QAC3B,KAAK,MAAM;UACP;QACJ,KAAK,MAAM;UACP,IAAK,CAAChN,CAAC,KAAK,CAAC,IAAK2L,SAAS,IAAI3L,CAAC,KAAKC,GAAG,GAAG,CAAE,KAAKgL,OAAO,CAAC3O,CAAC,GAAGR,IAAI,CAACQ,CAAC,IAC/D,CAAE0D,CAAC,KAAKC,GAAG,GAAG,CAAC,IAAM0L,SAAS,IAAI3L,CAAC,KAAK,CAAE,KAAKiL,OAAO,CAAC3O,CAAC,GAAGwO,WAAW,CAACvO,MAAM,GAAG,GAAG,GAAGT,IAAI,CAACQ,CAAE,EAAE;YAChG2O,OAAO,CAAC2B,IAAI,GAAG,EAAE;UACrB;UACA;QACJ,KAAK,OAAO;UACR,IAAI,CAAC5M,CAAC,KAAK,CAAC,IAAK2L,SAAS,IAAI3L,CAAC,KAAKC,GAAG,GAAG,CAAE,KAAKgL,OAAO,CAAC3O,CAAC,GAAGR,IAAI,CAACQ,CAAC,EAAE;YACjE2O,OAAO,CAAC3O,CAAC,GAAGyM,MAAM,GAAGjN,IAAI,CAACQ,CAAC,GAAGR,IAAI,CAACS,MAAM;UAC7C,CAAC,MACI,IAAI,CAAEyD,CAAC,KAAKC,GAAG,GAAG,CAAC,IAAM0L,SAAS,IAAI3L,CAAC,KAAK,CAAE,KAAMiL,OAAO,CAAC3O,CAAC,GAAGwO,WAAW,CAACvO,MAAM,GAAG,GAAG,GAAGT,IAAI,CAACQ,CAAE,EAAE;YACrG2O,OAAO,CAAC3O,CAAC,GAAGyM,MAAM,GAAGjN,IAAI,CAACQ,CAAC,GAAGwO,WAAW,CAACvO,MAAM,GAAG,GAAG;UAC1D;UACA;MAAM;MAEd;MACA,IAAI0Q,cAAc,GAAGhC,OAAO,CAAC3O,CAAC;MAC9B,IAAI4Q,aAAa,GAAGjC,OAAO,CAAC3O,CAAC,GAAGyP,WAAW;MAC3C,IAAIb,gBAAgB,EAAE;QAClB+B,cAAc,GAAIhC,OAAO,CAAC3O,CAAC,GAAIyP,WAAW,GAAG,CAAG;QAChDmB,aAAa,GAAGjC,OAAO,CAAC3O,CAAC,GAAIyP,WAAW,GAAG,CAAE;MACjD;MACA,IAAI,CAACV,KAAK,KAAK,EAAE,IAAIA,KAAK,KAAK,GAAG,KAAKxM,IAAI,CAACgO,oBAAoB,KAAK,MAAM,IAAI7M,CAAC,KAAK,CAAC,KACjF,CAAC2L,SAAS,GAAGsB,cAAc,IAAIpB,WAAW,GAAGqB,aAAa,IAAIrB,WAAW,CAAC,EAAE;QAC7E;MACJ;MACAA,WAAW,GAAGF,SAAS,GAAGsB,cAAc,GAAGC,aAAa;MACxD;MACAjC,OAAO,CAACkC,SAAS,GAAG,SAAS,GAAG9B,KAAK,GAAG,GAAG,GAAGR,MAAM,GAAG,GAAG,GAAG9B,MAAM,GAAG,GAAG;MACzE7N,WAAW,CAACQ,KAAK,CAACgJ,QAAQ,EAAEuG,OAAO,EAAEL,KAAK,CAACkC,UAAU,EAAElC,KAAK,CAACkC,UAAU,CAAChG,KAAK,IAAIpL,KAAK,CAAC+M,UAAU,CAAC2E,SAAS,EAAE9B,YAAY,EAAE,KAAK,EAAE5P,KAAK,CAACuL,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAEvL,KAAK,CAAC+K,YAAY,CAAC;IAC3M;IACA,IAAI,CAAC,IAAI,CAAC/K,KAAK,CAAC+K,YAAY,EAAE;MAC1B,IAAI,CAAC/K,KAAK,CAACqB,WAAW,EAAE;QACpBxC,kBAAkB,CAACmB,KAAK,CAAC+K,YAAY,EAAE4B,MAAM,EAAEiD,YAAY,EAAE5P,KAAK,CAACuL,MAAM,CAAC;MAC9E,CAAC,MACI,IAAIpI,IAAI,CAACwG,OAAO,IAAIxG,IAAI,CAAC2G,kBAAkB,EAAE;QAC9C,IAAI,CAAC6H,kBAAkB,CAAC,IAAI,CAAC3R,KAAK,EAAE4P,YAAY,EAAEzM,IAAI,EAAE4I,KAAK,EAAE3L,IAAI,CAAC;MACxE;IACJ;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIN,wBAAwB,CAACI,SAAS,CAAC0R,kBAAkB,GAAG,UAAUjR,CAAC,EAAEwC,IAAI,EAAE0O,SAAS,EAAE;IAClF,IAAIC,MAAM,GAAG3O,IAAI,CAAC4O,kBAAkB;IACpC,IAAItC,aAAa,GAAGtM,IAAI,CAACoH,aAAa,KAAK,QAAQ;IACnD,IAAIkD,SAAS,GAAGtK,IAAI,CAAC+B,qBAAqB;IAC1C,IAAKuI,SAAS,IAAIgC,aAAa,IAAM,CAAChC,SAAS,IAAI,CAACgC,aAAc,EAAE;MAChE,OAAQqC,MAAM,KAAK,OAAO,GAAGnR,CAAC,GAAImR,MAAM,KAAK,QAAQ,GAAInR,CAAC,GAAGkR,SAAS,GAAG,CAAC,GAAKlR,CAAC,GAAGkR,SAAW;IAClG,CAAC,MACI;MACD,OAAQC,MAAM,KAAK,MAAM,GAAGnR,CAAC,GAAImR,MAAM,KAAK,QAAQ,GAAInR,CAAC,GAAGkR,SAAS,GAAG,CAAC,GAAKlR,CAAC,GAAGkR,SAAW;IACjG;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI/R,wBAAwB,CAACI,SAAS,CAAC2K,eAAe,GAAG,UAAU1H,IAAI,EAAE4I,KAAK,EAAEY,MAAM,EAAEvM,IAAI,EAAE;IACtF,IAAI+C,IAAI,CAACgI,MAAM,CAAC5K,KAAK,GAAG,CAAC,EAAE;MACvB,IAAIyR,MAAM,GAAG,KAAK,CAAC;MACnB,IAAI3E,MAAM,GAAG,KAAK,CAAC;MACnB,IAAIjK,eAAe,GAAGD,IAAI,CAACoH,aAAa,KAAK,SAAS,GAAGpH,IAAI,CAACC,eAAe,GAAG,CAAC;MACjF,IAAIqK,SAAS,GAAGtK,IAAI,CAAC+B,qBAAqB;MAC1C9B,eAAe,GAAG,CAACqK,SAAS,GAAG,CAAC,GAAG,CAAC,CAAC,IAAIrK,eAAe;MACxD,IAAI6O,GAAG,GAAI7R,IAAI,CAACS,MAAM,GAAGsC,IAAI,CAAC2I,YAAY,CAACoG,KAAK,IAAK/O,IAAI,CAAC6D,SAAS,KAAK,UAAU,GAAG7D,IAAI,CAACgP,gBAAgB,GACpGhP,IAAI,CAAC2I,YAAY,CAACuC,QAAQ,CAAC;MACjC,IAAI+D,IAAI,GAAG,KAAK,CAAC;MACjB,IAAIC,QAAQ,GAAGlP,IAAI,CAACmP,YAAY,CAAC/R,KAAK,GAAG,EAAE,IAAK4C,IAAI,CAACkH,YAAY,KAAKlH,IAAI,CAACoH,aAAa,GACpFpH,IAAI,CAACgH,cAAc,CAACtJ,MAAM,GAAG,CAAC,CAAC;MACnC,IAAI0R,WAAW,GAAG,EAAE;MACpB,IAAI3E,aAAa,GAAIzK,IAAI,CAAC6D,SAAS,KAAK,UAAU,IAAI7D,IAAI,CAAC0K,cAAc,KAAK,cAAc,GAAI,CAAC,GAAG,GAAG,CAAC;MACxG,IAAI2E,IAAI,GAAK/E,SAAS,IAAItK,IAAI,CAACoH,aAAa,KAAK,QAAQ,IAAM,CAACkD,SAAS,IAClEtK,IAAI,CAACoH,aAAa,KAAK,SAAU,GAAInK,IAAI,CAACO,CAAC,GAAG0R,QAAQ,GAAGjP,eAAe,GAAGhD,IAAI,CAACO,CAAC,GAAG0R,QAAQ,GAAGjP,eAAe;MACrH,KAAK,IAAIkB,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGpB,IAAI,CAAC6K,aAAa,CAAC9L,MAAM,EAAEoC,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;QAC3D+I,MAAM,GAAG/O,kBAAkB,CAAC6E,IAAI,CAAC6K,aAAa,CAAC1J,CAAC,CAAC,CAAC8J,KAAK,GAAGR,aAAa,EAAEzK,IAAI,CAAC;QAC9EkK,MAAM,GAAG,CAAClK,IAAI,CAAC+M,aAAa,GAAI,CAAC,GAAG7C,MAAM,GAAIA,MAAM,IAAIjN,IAAI,CAACS,MAAM;QACnE,IAAIsC,IAAI,CAAC6D,SAAS,KAAK,UAAU,IAAI7D,IAAI,CAAC0K,cAAc,KAAK,cAAc,EAAE;UACzEmE,MAAM,GAAI3E,MAAM,GAAG,CAAC,CAAC,IAAKjN,IAAI,CAACQ,CAAC,GAAGR,IAAI,CAACS,MAAM,CAAC;UAC/CuR,IAAI,GAAI/E,MAAM,GAAG,CAAC,CAAC,GAAK4E,GAAI,IAAI7R,IAAI,CAACQ,CAAC,GAAGR,IAAI,CAACS,MAAM,CAAC;QACzD,CAAC,MACI;UACDmR,MAAM,GAAI3E,MAAM,GAAG,CAAC,CAAC,GAAI4E,GAAG,GAAG,CAAC,IAAI7R,IAAI,CAACQ,CAAC,GAAGR,IAAI,CAACS,MAAM,CAAC;UACzDuR,IAAI,GAAI/E,MAAM,GAAG,CAAC,CAAC,GAAI4E,GAAG,GAAG,CAAC,IAAI7R,IAAI,CAACQ,CAAC,GAAGR,IAAI,CAACS,MAAM,CAAC;QAC3D;QACA,QAAQsC,IAAI,CAACgI,MAAM,CAAChE,IAAI;UACpB,KAAK,WAAW;UAChB,KAAK,kBAAkB;YACnB,IAAI6K,MAAM,GAAI5R,IAAI,CAACQ,CAAC,GAAGR,IAAI,CAACS,MAAO,EAAE;cACjC0R,WAAW,IAAK,GAAG,GAAG,GAAG,GAAGC,IAAI,GAAG,GAAG,IAAIpS,IAAI,CAACQ,CAAC,GAAGR,IAAI,CAACS,MAAM,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG2R,IAAI,GAAG,GAAG,GAAGJ,IAAI,GAAG,GAAI;YAChH,CAAC,MACI,IAAI5J,IAAI,CAACyI,KAAK,CAAC7Q,IAAI,CAACQ,CAAC,CAAC,GAAIwR,IAAK,EAAE;cAClCG,WAAW,IAAK,GAAG,GAAG,GAAG,IAAInS,IAAI,CAACO,CAAC,GAAGyC,eAAe,CAAC,GAAG,GAAG,GAAG4O,MAAM,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAGQ,IAAI,GACxF,GAAG,GAAGR,MAAM,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAGQ,IAAI,GAAG,GAAG,GAAIpS,IAAI,CAACQ,CAAE,GAAG,GAAI;YACvE,CAAC,MACI;cACD2R,WAAW,IAAK,GAAG,GAAG,GAAG,IAAInS,IAAI,CAACO,CAAC,GAAGyC,eAAe,CAAC,GAAG,GAAG,GAAG4O,MAAM,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAGQ,IAAI,GAC1F,GAAG,GAAGR,MAAM,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAGQ,IAAI,GAAG,GAAG,GAAGJ,IAAI,GAAG,GAAI;cAC7D,IAAI9N,CAAC,KAAKnB,IAAI,CAAC6K,aAAa,CAAC9L,MAAM,GAAG,CAAC,EAAE;gBACrCqQ,WAAW,IAAK,GAAG,GAAG,GAAG,IAAInS,IAAI,CAACO,CAAC,GAAGyC,eAAe,CAAC,GAAG,GAAG,GAAGgP,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GACjFI,IAAI,GAAG,GAAG,GAAGJ,IAAI,GAAG,GAAI;cAChC;YACJ;YACA;UACJ,KAAK,2BAA2B;YAC5B,IAAI,EAAEJ,MAAM,GAAG5R,IAAI,CAACQ,CAAC,GAAGR,IAAI,CAACS,MAAM,CAAC,IAAI,EAAGuR,IAAI,GAAI5J,IAAI,CAACyI,KAAK,CAAC7Q,IAAI,CAACQ,CAAC,CAAC,CAAC,EAAE;cACpE2R,WAAW,IAAK,GAAG,GAAG,GAAG,IAAInS,IAAI,CAACO,CAAC,GAAGyC,eAAe,CAAC,GAAG,GAAG,GAAG4O,MAAM,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAGQ,IAAI,GAC1F,GAAG,GAAGR,MAAM,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAGQ,IAAI,GAAG,GAAG,GAAGJ,IAAI,GAAG,GAAG,GACxD,GAAG,GAAG,GAAG,IAAIhS,IAAI,CAACO,CAAC,GAAGyC,eAAe,CAAC,GAAG,GAAG,GAAGgP,IAAK;YAC5D;YACA;QAAM;MAElB;MACAG,WAAW,IAAKpP,IAAI,CAACgI,MAAM,CAAChE,IAAI,KAAK,WAAW,GAAK,GAAG,GAAG,GAAG,IAAI/G,IAAI,CAACO,CAAC,GAAGyC,eAAe,CAAC,GAAG,GAAG,GAAGhD,IAAI,CAACQ,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IACvHR,IAAI,CAACO,CAAC,GAAGyC,eAAe,CAAC,GAAG,GAAG,IAAIhD,IAAI,CAACQ,CAAC,GAAGR,IAAI,CAACS,MAAM,CAAC,GAAG,GAAG,GAAI,EAAE;MACzE,IAAI0R,WAAW,KAAK,EAAE,EAAE;QACpB,IAAI,CAACE,uBAAuB,CAACtP,IAAI,EAAE4I,KAAK,EAAEwG,WAAW,EAAE5F,MAAM,CAAC;MAClE;IACJ;IACA,IAAIxJ,IAAI,CAACuP,gBAAgB,CAACxQ,MAAM,GAAG,CAAC,IAAI,IAAI,CAAClC,KAAK,CAAC2S,qBAAqB,EAAE;MACtE,IAAI,CAAC3S,KAAK,CAAC2S,qBAAqB,CAACC,2BAA2B,CAACzP,IAAI,EAAE4I,KAAK,EAAEY,MAAM,EAAEvM,IAAI,CAAC;IAC3F;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIN,wBAAwB,CAACI,SAAS,CAAC4K,cAAc,GAAG,UAAU3H,IAAI,EAAE4I,KAAK,EAAEY,MAAM,EAAEvM,IAAI,EAAE;IACrF,IAAI+C,IAAI,CAAC0P,KAAK,EAAE;MACZ,IAAI7S,KAAK,GAAG,IAAI,CAACA,KAAK;MACtB,IAAIyN,SAAS,GAAGtK,IAAI,CAAC+B,qBAAqB;MAC1C,IAAI4N,aAAa,GAAGrF,SAAS,GAAG,EAAE,GAAG,CAAC,EAAE;MACxC,IAAIxN,OAAO,GAAG,CAACkD,IAAI,CAACkH,YAAY,KAAK,QAAQ,GAAG,CAAC,GAAGlH,IAAI,CAACgH,cAAc,CAACtJ,MAAM,GAAGsC,IAAI,CAAC4P,YAAY,KAC7F5P,IAAI,CAACoH,aAAa,KAAK,QAAQ,GAAG,CAAC,GAC/BpH,IAAI,CAACmP,YAAY,CAAC/R,KAAK,GAAG4C,IAAI,CAAC6P,qBAAqB,GAAG,IAAI,CAAC/S,OAAQ,CAAC;MAC9EA,OAAO,GAAGwN,SAAS,GAAGxN,OAAO,GAAGkD,IAAI,CAACC,eAAe,GAAG,CAACnD,OAAO,GAAGkD,IAAI,CAACC,eAAe;MACtF,IAAIzC,CAAC,GAAGP,IAAI,CAACO,CAAC,GAAGV,OAAO;MACxB,IAAIW,CAAC,GAAGR,IAAI,CAACQ,CAAC,GAAGR,IAAI,CAACS,MAAM,GAAG,GAAG;MAClC,IAAIoS,SAAS,GAAI9P,IAAI,CAAC8P,SAAS,CAACpS,MAAM,IAAIsC,IAAI,CAAC+P,eAAe,CAAChR,MAAM,GAAG,CAAC,CAAE;MAC3E,IAAIqN,OAAO,GAAG,IAAIjQ,UAAU,CAACU,KAAK,CAACmJ,OAAO,CAACD,EAAE,GAAG,aAAa,GAAG6C,KAAK,EAAEpL,CAAC,EAAEC,CAAC,GAAGuC,IAAI,CAACmM,YAAY,GAAG2D,SAAS,EAAE,QAAQ,EAAE9P,IAAI,CAAC+P,eAAe,EAAE,SAAS,GAAGJ,aAAa,GAAG,GAAG,GAAInS,CAAE,GAAG,GAAG,GAAIC,CAAE,GAAG,GAAG,EAAE,IAAI,EAAEkS,aAAa,CAAC;MAC1N,IAAI3J,OAAO,GAAG3J,WAAW,CAACQ,KAAK,CAACgJ,QAAQ,EAAEuG,OAAO,EAAEpM,IAAI,CAACgQ,UAAU,EAAEhQ,IAAI,CAACgQ,UAAU,CAAC/H,KAAK,IAAIpL,KAAK,CAAC+M,UAAU,CAACqG,SAAS,EAAEzG,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE3M,KAAK,CAAC+K,YAAY,CAAC;MACpM5B,OAAO,CAACkK,YAAY,CAAC,UAAU,EAAElQ,IAAI,CAACmQ,QAAQ,CAACC,QAAQ,EAAE,CAAC;MAC1DpK,OAAO,CAACkK,YAAY,CAAC,YAAY,EAAElQ,IAAI,CAACqQ,WAAW,IAAIrQ,IAAI,CAAC0P,KAAK,CAAC;IACtE;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI/S,wBAAwB,CAACI,SAAS,CAACkK,iBAAiB,GAAG,UAAUjH,IAAI,EAAE4I,KAAK,EAAEY,MAAM,EAAEvM,IAAI,EAAE;IACxF,IAAI8M,SAAS,GAAG/J,IAAI,CAAC6D,SAAS,KAAK,aAAa;IAChD,IAAImG,cAAc,GAAGhK,IAAI,CAAC6D,SAAS,CAACe,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;IAC5D,IAAIqF,YAAY;IAChB,IAAI+B,MAAM,GAAG,CAAC;IACd,IAAI7B,SAAS,GAAG,EAAE;IAClB,IAAIC,SAAS,GAAG,EAAE;IAClB,IAAIkG,cAAc;IAClB,IAAIhG,SAAS,GAAGtK,IAAI,CAAC+B,qBAAqB;IAC1C,IAAIwI,QAAQ,GAAID,SAAS,GAAI,CAACtK,IAAI,CAACgH,cAAc,CAACtJ,MAAM,GAAGsC,IAAI,CAACgH,cAAc,CAACtJ,MAAM;IACrF,IAAI8M,YAAY,GAAIF,SAAS,GAAI,CAACtK,IAAI,CAAC4G,SAAS,CAACxJ,KAAK,GAAG,GAAG,GAAG4C,IAAI,CAAC4G,SAAS,CAACxJ,KAAK,GAAG,GAAG;IACzF,IAAI6C,eAAe,GAAGjF,iBAAiB,CAACgF,IAAI,CAACqD,SAAS,CAAC,GAAGiH,SAAS,GAAG,CAACtK,IAAI,CAACC,eAAe,GACvFD,IAAI,CAACC,eAAe,GAAG,CAAC;IAC5B,IAAIwK,aAAa,GAAIzK,IAAI,CAAC6D,SAAS,CAACe,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,IAAI5E,IAAI,CAAC0K,cAAc,KAAK,cAAc,GAClG,GAAG,GAAG,CAAC;IACX,IAAI3L,MAAM,GAAGiB,IAAI,CAAC6K,aAAa,CAAC9L,MAAM;IACtC,IAAI4L,YAAY,GAAG3K,IAAI,CAACkH,YAAY,KAAK,QAAQ;IACjD,IAAI0D,KAAK,GAAGD,YAAY,GAAI1N,IAAI,CAACQ,CAAC,GAAG8M,QAAQ,GAAGC,YAAY,GAAKvN,IAAI,CAACQ,CAAC,GAAG8M,QAAQ,GAAGC,YAAY,GAAGvK,eAAgB;IACpH,IAAI6K,eAAe,GAAG,IAAI,CAACjO,KAAK,CAAC+M,UAAU;IAC3C,IAAI5J,IAAI,CAAC6D,SAAS,CAACe,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,IAAI7F,MAAM,GAAG,CAAC,IAAIiB,IAAI,CAAC0K,cAAc,KAAK,cAAc,EAAE;MACjG3L,MAAM,IAAI,CAAC;IACf;IACA;IACA,KAAK,IAAIoC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGpC,MAAM,EAAEoC,CAAC,EAAE,EAAE;MAC7B,IAAInB,IAAI,CAAC6D,SAAS,KAAK,kBAAkB,EAAE;QACvCoG,YAAY,GAAGjK,IAAI,CAAC6K,aAAa,CAAC1J,CAAC,CAAC,GAAGnB,IAAI,CAAC6K,aAAa,CAAC1J,CAAC,CAAC,CAAC8J,KAAK,GAAGR,aAAa,GAC3EzK,IAAI,CAAC6K,aAAa,CAAC1J,CAAC,GAAG,CAAC,CAAC,CAAC8J,KAAK,GAAGjL,IAAI,CAAC2I,YAAY,CAACuC,QAAQ,GAAIT,aAAa;MACxF,CAAC,MACI;QACDR,YAAY,GAAGjK,IAAI,CAAC6K,aAAa,CAAC1J,CAAC,CAAC,GAChCnB,IAAI,CAAC6K,aAAa,CAAC1J,CAAC,CAAC,CAAC8J,KAAK,GAAGR,aAAa,GAAGzK,IAAI,CAAC2I,YAAY,CAACrD,GAAG;MAC3E;MACA0G,MAAM,GAAI7Q,kBAAkB,CAAC8O,YAAY,EAAEjK,IAAI,CAAC,GAAG/C,IAAI,CAACG,KAAK,GAAIH,IAAI,CAACO,CAAC;MACvE,IAAIwO,MAAM,IAAI/O,IAAI,CAACO,CAAC,IAAKP,IAAI,CAACO,CAAC,GAAGP,IAAI,CAACG,KAAK,IAAK4O,MAAM,EAAE;QACrD,IAAIvQ,MAAM,CAACwO,YAAY,EAAEjK,IAAI,CAAC2I,YAAY,CAAC,IAAI,IAAI,CAACwC,QAAQ,CAACnL,IAAI,EAAEmB,CAAC,EAAE6K,MAAM,CAAC,EAAE;UAC3E7B,SAAS,GAAG,IAAI,GAAG6B,MAAM,GAAG,GAAG,IAAI,IAAI,CAACzO,cAAc,CAACE,CAAC,GAAG,IAAI,CAACF,cAAc,CAACG,MAAM,CAAC,GAClF,KAAK,GAAGsO,MAAM,GAAG,GAAG,GAAG,IAAI,CAACzO,cAAc,CAACE,CAAC;UAChD,IAAI,CAAC2N,cAAc,CAACpL,IAAI,EAAE4I,KAAK,EAAEuB,SAAS,EAAEnK,IAAI,CAAC+G,cAAc,EAAE,iBAAiB,EAAE5F,CAAC,EAAE,IAAI,CAAC6E,OAAO,EAAE8E,eAAe,CAACO,aAAa,EAAErL,IAAI,CAAC+G,cAAc,CAAC4C,SAAS,CAAC;QACtK;QACAS,SAAS,GAAG,IAAI,GAAI4B,MAAO,GAAG,GAAG,IAAI/O,IAAI,CAACQ,CAAC,GAAG+M,YAAY,IAAIG,YAAY,GAAG1K,eAAe,GAAG,CAAC,CAAC,CAAC,GAC5F,KAAK,GAAI+L,MAAO,GAAG,GAAG,GAAGpB,KAAK;QACpC,IAAI,CAACQ,cAAc,CAACpL,IAAI,EAAE4I,KAAK,EAAEwB,SAAS,EAAEpK,IAAI,CAACgH,cAAc,EAAE,iBAAiB,EAAE7F,CAAC,EAAEqI,MAAM,EAAEsB,eAAe,CAACQ,aAAa,CAAC;QAC7H,IAAItL,IAAI,CAACuL,qBAAqB,GAAG,CAAC,KAAKvL,IAAI,CAAC+K,cAAc,CAAC3N,KAAK,GAAG,CAAC,IAAI4C,IAAI,CAACgL,cAAc,CAAC5N,KAAK,GAAG,CAAC,CAAC,EAAE;UACpG,IAAI+D,CAAC,KAAK,CAAC,IAAI1E,SAAS,CAACuD,IAAI,CAAC,IAAI,CAAC+J,SAAS,IAAI,CAACC,cAAc,EAAE;YAC7D,IAAI,CAACwB,wBAAwB,CAACxL,IAAI,EAAEiK,YAAY,EAAEhN,IAAI,EAAEkE,CAAC,EAAEyH,KAAK,EAAEkC,eAAe,EAAEtB,MAAM,CAAC;UAC9F;UACA8G,cAAc,GAAG,IAAI,CAAC7E,iBAAiB,CAACzL,IAAI,EAAEiK,YAAY,EAAEhN,IAAI,EAAEkE,CAAC,CAAC;UACpE,IAAI,CAACiK,cAAc,CAACpL,IAAI,EAAE4I,KAAK,EAAE0H,cAAc,CAAC,CAAC,CAAC,EAAEtQ,IAAI,CAAC+K,cAAc,EAAE,iBAAiB,EAAE5J,CAAC,EAAE,IAAI,CAAC6E,OAAO,EAAE8E,eAAe,CAACY,aAAa,EAAE1L,IAAI,CAAC+K,cAAc,CAACpB,SAAS,CAAC;UAC1K,IAAI,CAACyB,cAAc,CAACpL,IAAI,EAAE4I,KAAK,EAAE0H,cAAc,CAAC,CAAC,CAAC,EAAEtQ,IAAI,CAACgL,cAAc,EAAE,iBAAiB,EAAE7J,CAAC,EAAEqI,MAAM,EAAEsB,eAAe,CAACa,aAAa,CAAC;UACrI,IAAIxK,CAAC,KAAKpC,MAAM,GAAG,CAAC,IAAItC,SAAS,CAACuD,IAAI,CAAC,IAAI+J,SAAS,IAAI,CAACC,cAAc,EAAE;YACrE,IAAI,CAACwB,wBAAwB,CAACxL,IAAI,EAAGiK,YAAY,GAAGjK,IAAI,CAAC2I,YAAY,CAACuC,QAAQ,EAAGjO,IAAI,EAAEkE,CAAC,EAAEyH,KAAK,EAAEkC,eAAe,EAAEtB,MAAM,CAAC;UAC7H;QACJ;MACJ;IACJ;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI7M,wBAAwB,CAACI,SAAS,CAACyO,wBAAwB,GAAG,UAAUxL,IAAI,EAAEiK,YAAY,EAAEhN,IAAI,EAAEkE,CAAC,EAAEyH,KAAK,EAAEkC,eAAe,EAAEtB,MAAM,EAAE;IACjI,IAAI8G,cAAc,GAAG,IAAI,CAAC7E,iBAAiB,CAACzL,IAAI,EAAEiK,YAAY,EAAEhN,IAAI,EAAEkE,CAAC,EAAE,IAAI,CAAC;IAC9E,IAAI,CAACiK,cAAc,CAACpL,IAAI,EAAE4I,KAAK,EAAE0H,cAAc,CAAC,CAAC,CAAC,EAAEtQ,IAAI,CAAC+K,cAAc,EAAE,iBAAiB,EAAE,CAAC,CAAC,EAAE,IAAI,CAAC/E,OAAO,EAAE8E,eAAe,CAACY,aAAa,EAAE1L,IAAI,CAAC+K,cAAc,CAACpB,SAAS,CAAC;IAC3K,IAAI,CAACyB,cAAc,CAACpL,IAAI,EAAE4I,KAAK,EAAE0H,cAAc,CAAC,CAAC,CAAC,EAAEtQ,IAAI,CAACgL,cAAc,EAAE,iBAAiB,EAAE,CAAC,CAAC,EAAExB,MAAM,EAAEsB,eAAe,CAACa,aAAa,CAAC;EAC1I,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIhP,wBAAwB,CAACI,SAAS,CAAC0O,iBAAiB,GAAG,UAAUzL,IAAI,EAAEiK,YAAY,EAAEhN,IAAI,EAAEsT,UAAU,EAAEC,YAAY,EAAE;IACjH,IAAIvF,KAAK,GAAGhB,YAAY;IACxB,IAAIwG,IAAI,GAAG,CAAC;IACZ,IAAIhS,QAAQ,GAAG,CAAC;IAChB,IAAIiS,KAAK,GAAG1Q,IAAI,CAAC2I,YAAY;IAC7B,IAAIgC,YAAY,GAAG3K,IAAI,CAACkH,YAAY,KAAK,QAAQ;IACjD,IAAIuC,SAAS,GAAG,EAAE;IAClB,IAAIc,QAAQ,GAAGvK,IAAI,CAAC+B,qBAAqB,GAAG,CAAC/B,IAAI,CAACgL,cAAc,CAACtN,MAAM,GAAGsC,IAAI,CAACgL,cAAc,CAACtN,MAAM;IACpG,IAAIiT,QAAQ;IACZ,IAAIC,MAAM;IACV,IAAIC,WAAW,GAAG,CAAC;IACnB,IAAIC,WAAW,GAAG,CAAC;IACnB,IAAIC,MAAM,GAAGpG,YAAY,GAAI1N,IAAI,CAACQ,CAAC,GAAG8M,QAAQ,GAAKtN,IAAI,CAACQ,CAAC,GAAG8M,QAAS;IACrE,IAAIyG,MAAM,GAAGrG,YAAY,GAAI1N,IAAI,CAACO,CAAC,GAAG+M,QAAQ,GAAKtN,IAAI,CAACO,CAAC,GAAG+M,QAAS;IACrE,IAAI0G,SAAS,GAAG,EAAE;IAClB,IAAIC,SAAS,GAAG,EAAE;IAClB,IAAIpE,SAAS,GAAG9M,IAAI,CAAC+M,aAAa;IAClC,IAAI/M,IAAI,CAAC6D,SAAS,KAAK,aAAa,EAAE;MAClC8M,QAAQ,GAAGtL,IAAI,CAAC8L,GAAG,CAACnR,IAAI,CAACnE,OAAO,EAAEoP,KAAK,GAAGyF,KAAK,CAACxF,QAAQ,CAAC;MACzD0F,MAAM,GAAGvL,IAAI,CAAC8L,GAAG,CAACnR,IAAI,CAACnE,OAAO,EAAEoP,KAAK,CAAC;MACtC4F,WAAW,GAAG,CAACD,MAAM,GAAGD,QAAQ,KAAK3Q,IAAI,CAACuL,qBAAqB,GAAG,CAAC,CAAC;MACpEuF,WAAW,GAAGH,QAAQ,GAAGE,WAAW;IACxC;IACA,IAAI7Q,IAAI,CAACwC,WAAW,KAAK,YAAY,EAAE;MACnC,KAAK,IAAInB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGrB,IAAI,CAACuL,qBAAqB,EAAElK,CAAC,EAAE,EAAE;QACjD4J,KAAK,GAAG,IAAI,CAACmG,cAAc,CAACpR,IAAI,EAAE8Q,WAAW,EAAE7F,KAAK,EAAEsF,UAAU,EAAEC,YAAY,CAAC;QAC/EM,WAAW,IAAID,WAAW;QAC1B,IAAIpV,MAAM,CAACwP,KAAK,EAAEyF,KAAK,CAAC,EAAE;UACtBjS,QAAQ,GAAI,CAACwM,KAAK,GAAGyF,KAAK,CAACnL,GAAG,KAAKmL,KAAK,CAACpL,GAAG,GAAGoL,KAAK,CAACnL,GAAG,CAAE;UAC1D9G,QAAQ,GAAG4G,IAAI,CAACgM,IAAI,CAAC,CAACvE,SAAS,GAAI,CAAC,GAAGrO,QAAQ,GAAIA,QAAQ,IAAIxB,IAAI,CAACG,KAAK,CAAC;UAC1EqT,IAAI,GAAIpL,IAAI,CAACyI,KAAK,CAACrP,QAAQ,GAAGxB,IAAI,CAACO,CAAC,CAAE;UACtCyT,SAAS,GAAGA,SAAS,CAACK,MAAM,CAAC,GAAG,GAAG,GAAG,GAAGb,IAAI,GAAG,GAAG,GAAI,IAAI,CAAClT,cAAc,CAACE,CAAE,GACvE,IAAI,GAAGgT,IAAI,GAAG,GAAG,IAAI,IAAI,CAAClT,cAAc,CAACE,CAAC,GAAG,IAAI,CAACF,cAAc,CAACG,MAAM,CAAC,CAAC;UAC/E+S,IAAI,GAAIpL,IAAI,CAACyI,KAAK,CAACrP,QAAQ,GAAGxB,IAAI,CAACO,CAAC,CAAE;UACtC0T,SAAS,GAAGA,SAAS,CAACI,MAAM,CAAC,GAAG,GAAG,GAAG,GAAGb,IAAI,GAAG,GAAG,GAAIxT,IAAI,CAACQ,CAAE,GACxD,IAAI,GAAGgT,IAAI,GAAG,GAAG,IAAIM,MAAM,GAAG/Q,IAAI,CAACC,eAAe,CAAC,CAAC;QAC9D;MACJ;IACJ,CAAC,MACI;MACD,KAAK,IAAIoB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGrB,IAAI,CAACuL,qBAAqB,EAAElK,CAAC,EAAE,EAAE;QACjD4J,KAAK,GAAG,IAAI,CAACmG,cAAc,CAACpR,IAAI,EAAE8Q,WAAW,EAAE7F,KAAK,EAAEsF,UAAU,EAAEC,YAAY,CAAC;QAC/E,IAAI/U,MAAM,CAACwP,KAAK,EAAEyF,KAAK,CAAC,EAAE;UACtBjS,QAAQ,GAAI,CAACwM,KAAK,GAAGyF,KAAK,CAACnL,GAAG,KAAKmL,KAAK,CAACpL,GAAG,GAAGoL,KAAK,CAACnL,GAAG,CAAE;UAC1D9G,QAAQ,GAAG4G,IAAI,CAACgM,IAAI,CAAC,CAAEvE,SAAS,GAAI,CAAC,GAAGrO,QAAQ,GAAIA,QAAQ,IAAKxB,IAAI,CAACS,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;UACpF+S,IAAI,GAAIpL,IAAI,CAACyI,KAAK,CAACrP,QAAQ,GAAGxB,IAAI,CAACQ,CAAC,GAAGR,IAAI,CAACS,MAAM,CAAE;UACpDuT,SAAS,GAAGA,SAAS,CAACK,MAAM,CAAC,GAAG,GAAG,GAAG,GAAI,IAAI,CAAC/T,cAAc,CAACC,CAAE,GAAG,GAAG,GAAGiT,IAAI,GACvE,IAAI,IAAI,IAAI,CAAClT,cAAc,CAACC,CAAC,GAAG,IAAI,CAACD,cAAc,CAACH,KAAK,CAAC,GAAG,GAAG,GAAGqT,IAAI,GAAG,GAAG,CAAC;UACpFA,IAAI,GAAIpL,IAAI,CAACyI,KAAK,CAACrP,QAAQ,GAAGxB,IAAI,CAACQ,CAAC,GAAGR,IAAI,CAACS,MAAM,CAAE;UACpDwT,SAAS,GAAGA,SAAS,CAACI,MAAM,CAAC,GAAG,GAAG,GAAG,GAAGrU,IAAI,CAACO,CAAC,GAAG,GAAG,GAAGiT,IAAI,GAAG,IAAI,IAAIO,MAAM,GAAGhR,IAAI,CAACC,eAAe,CAAC,GACjG,GAAG,GAAGwQ,IAAI,GAAG,GAAG,CAAC;QACzB;QACAK,WAAW,IAAID,WAAW;MAC9B;IACJ;IACApH,SAAS,CAAC/G,IAAI,CAACuO,SAAS,CAAC;IACzBxH,SAAS,CAAC/G,IAAI,CAACwO,SAAS,CAAC;IACzB,OAAOzH,SAAS;EACpB,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI9M,wBAAwB,CAACI,SAAS,CAACqU,cAAc,GAAG,UAAUpR,IAAI,EAAE8Q,WAAW,EAAE7F,KAAK,EAAEsF,UAAU,EAAEC,YAAY,EAAE;IAC9G,IAAIE,KAAK,GAAG1Q,IAAI,CAAC2I,YAAY;IAC7B,IAAI4I,SAAS;IACb,IAAIvR,IAAI,CAAC6D,SAAS,KAAK,aAAa,EAAE;MAClCoH,KAAK,GAAGpP,OAAO,CAACiV,WAAW,EAAE9Q,IAAI,CAACnE,OAAO,CAAC;IAC9C,CAAC,MACI,IAAImE,IAAI,CAAC6D,SAAS,KAAK,UAAU,EAAE;MACpC0N,SAAS,GAAGvR,IAAI,CAACgP,gBAAgB,IAAIhP,IAAI,CAACuL,qBAAqB,GAAG,CAAC,CAAC;MACpEN,KAAK,GAAGuF,YAAY,GAAIvF,KAAK,GAAGsG,SAAS,GAAKtG,KAAK,GAAGsG,SAAU;IACpE,CAAC,MACI,IAAIvR,IAAI,CAAC6D,SAAS,KAAK,kBAAkB,EAAE;MAC5C,IAAI/G,OAAO,GAAGkD,IAAI,CAAC0K,cAAc,KAAK,cAAc,GAAG,GAAG,GAAG,CAAC;MAC9DO,KAAK,IAAI,CAAC,CAACjL,IAAI,CAAC6K,aAAa,CAAC0F,UAAU,GAAG,CAAC,CAAC,GACzCvQ,IAAI,CAAC6K,aAAa,CAAC0F,UAAU,GAAG,CAAC,CAAC,CAACtF,KAAK,GAAGnO,OAAO,GAAGkD,IAAI,CAAC2I,YAAY,CAACrD,GAAG,KACzEtF,IAAI,CAAC6K,aAAa,CAAC0F,UAAU,CAAC,GAC3BvQ,IAAI,CAAC6K,aAAa,CAAC0F,UAAU,CAAC,CAACtF,KAAK,GAAGnO,OAAO,GAAGkD,IAAI,CAAC2I,YAAY,CAACpD,GAAG,CAAC,KAC1EvF,IAAI,CAACuL,qBAAqB,GAAG,CAAC,CAAC;IACxC,CAAC,MACI;MACDgG,SAAS,GAAGb,KAAK,CAACxF,QAAQ,IAAIlL,IAAI,CAACuL,qBAAqB,GAAG,CAAC,CAAC;MAC7DN,KAAK,GAAGuF,YAAY,GAAIvF,KAAK,GAAGsG,SAAS,GAAKtG,KAAK,GAAGsG,SAAU;IACpE;IACA,OAAOtG,KAAK;EAChB,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACItO,wBAAwB,CAACI,SAAS,CAACoK,eAAe,GAAG,UAAUnH,IAAI,EAAE4I,KAAK,EAAEY,MAAM,EAAEvM,IAAI,EAAE;IACtF,IAAIJ,KAAK,GAAG,IAAI,CAACA,KAAK;IACtB,IAAImP,MAAM,GAAG,CAAC;IACd,IAAI9B,MAAM,GAAG,CAAC;IACd,IAAIgC,UAAU,GAAGlM,IAAI,CAACmM,YAAY;IAClC,IAAIe,WAAW;IACf,IAAIjB,WAAW;IACf,IAAIE,YAAY;IAChB,IAAIwC,MAAM;IACV,IAAI9B,KAAK,GAAG,EAAE;IACd,IAAIJ,YAAY,GAAG5P,KAAK,CAACgJ,QAAQ,CAACC,WAAW,CAAC;MAAEC,EAAE,EAAElJ,KAAK,CAACmJ,OAAO,CAACD,EAAE,GAAG,YAAY,GAAG6C;IAAM,CAAC,CAAC;IAC9F,IAAI4I,aAAa,GAAGxR,IAAI,CAACoH,aAAa,KAAK,QAAQ;IACnD,IAAIkD,SAAS,GAAGtK,IAAI,CAAC+B,qBAAqB;IAC1C,IAAIwK,SAAS,GAAGvM,IAAI,CAACoH,aAAa,KAAKpH,IAAI,CAACkH,YAAY,GAAGlH,IAAI,CAACgH,cAAc,CAACtJ,MAAM,GAAG,CAAC;IACzF,IAAIZ,OAAO,GAAGyP,SAAS,GAAGL,UAAU,GAAGlM,IAAI,CAAC4G,SAAS,CAACxJ,KAAK,GAAG,GAAG;IACjE,IAAIoP,KAAK,GAAGxM,IAAI,CAACwM,KAAK,GAAG,GAAG;IAC5B,IAAIiF,iBAAiB,GAAIjF,KAAK,KAAK,CAAC,IAAIA,KAAK,KAAK,CAAC,GAAG,IAAIA,KAAK,KAAK,GAAI;IACxE,IAAIJ,OAAO;IACX,IAAIsF,UAAU;IACd,IAAI5E,SAAS,GAAG9M,IAAI,CAAC+M,aAAa;IAClC,IAAIC,WAAW,GAAGF,SAAS,GAAI7P,IAAI,CAACO,CAAC,GAAGP,IAAI,CAACG,KAAK,GAAIH,IAAI,CAACO,CAAC;IAC5D,IAAIJ,KAAK,GAAG,CAAC;IACb,IAAI2B,MAAM,GAAGiB,IAAI,CAAC6K,aAAa,CAAC9L,MAAM;IACtC,IAAIkO,cAAc;IAClB,IAAIlB,KAAK;IACT,IAAIM,gBAAgB;IACpB,IAAIpM,eAAe,GAAGD,IAAI,CAACU,iBAAiB,CAACC,MAAM,IAAK,CAAC6Q,aAAa,IAAIxW,iBAAiB,CAACgF,IAAI,CAACqD,SAAS,CAAC,KACnGrD,IAAI,CAACQ,UAAU,GAAG,CAAC,IAAIR,IAAI,CAACS,YAAY,GAAG,CAAC,CAAE,GAAGT,IAAI,CAACC,eAAe,GAAG,CAAC;IACjF,IAAI0R,SAAS,GAAG,EAAE;IAClB,IAAIC,uBAAuB,GAAG,KAAK;IACnC9U,OAAO,IAAK0P,KAAK,KAAK,EAAE,IAAIA,KAAK,KAAK,GAAG,IAAIA,KAAK,KAAK,CAAC,EAAE,IAAIA,KAAK,KAAK,CAAC,GAAG,GAAKgF,aAAa,GAAG,CAAC,GAAG,CAAC,CAAC,GAAI,CAAC;IAC5G,IAAIK,oBAAoB,GAAK,CAACvH,SAAS,IAAI,CAACkH,aAAa,IAAMlH,SAAS,IAAIkH,aAAe;IAC3F,IAAIM,WAAW,GAAGD,oBAAoB,GAChC,GAAG,IAAIrF,KAAK,IAAIA,KAAK,IAAI,GAAG,IAAM,CAAC,CAAC,IAAIA,KAAK,IAAIA,KAAK,IAAI,CAAC,GAAI,GAC/D,CAAC,IAAIA,KAAK,IAAIA,KAAK,IAAI,GAAG,IAAM,CAAC,GAAG,IAAIA,KAAK,IAAIA,KAAK,IAAI,CAAC,GAAK;IACtE,KAAK,IAAIrL,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGrC,MAAM,EAAEoC,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACxC4K,KAAK,GAAG/L,IAAI,CAAC6K,aAAa,CAAC1J,CAAC,CAAC;MAC7BkL,gBAAgB,GAAG/Q,YAAY,CAACyQ,KAAK,CAAC6B,YAAY,CAAC;MACnD5B,MAAM,GAAI7Q,kBAAkB,CAAC4Q,KAAK,CAACd,KAAK,EAAEjL,IAAI,CAAC,GAAG/C,IAAI,CAACG,KAAK,GAAIH,IAAI,CAACO,CAAC;MACtEyO,WAAW,GAAGF,KAAK,CAAClM,IAAI;MACxBoN,cAAc,GAAGhQ,IAAI,CAACG,KAAK,GAAG2B,MAAM;MACpC2S,UAAU,GAAGrF,gBAAgB,GAAGN,KAAK,CAACyB,cAAc,CAACpQ,KAAK,GAAG6O,WAAW,CAAC7O,KAAK;MAC9EA,KAAK,GAAI,CAAC4C,IAAI,CAACgO,oBAAoB,KAAK,MAAM,IAAIhO,IAAI,CAACgO,oBAAoB,KAAK,MAAM,KAAKxB,KAAK,KAAK,CAAC,IAClGkF,UAAU,GAAGzE,cAAc,GAAIA,cAAc,GAAGyE,UAAU;MAC9DxE,WAAW,GAAGjB,WAAW,CAACvO,MAAM,GAAG,CAAC;MACpCsO,MAAM,IAAKK,gBAAgB,IAAIG,KAAK,KAAK,CAAC,GAAI,CAAC,GAAIpP,KAAK,GAAG,CAAE;MAC7D;MACA,IAAIoP,KAAK,KAAK,CAAC,EAAE;QACb,IAAIH,gBAAgB,EAAE;UAClBL,MAAM,IAAIhM,IAAI,CAAC4O,kBAAkB,KAAK,MAAM,GAAI7C,KAAK,CAACyB,cAAc,CAACpQ,KAAK,GAAG,CAAC,GAAI4C,IAAI,CAAC4O,kBAAkB,KAAK,OAAO,GACjH,EAAE7C,KAAK,CAACyB,cAAc,CAACpQ,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC;QAC7C,CAAC,MACI;UACD4O,MAAM,IAAKQ,KAAK,KAAK,CAAC,EAAE,IAAIA,KAAK,KAAK,GAAG,GAAG,CAACU,WAAW,GAAIV,KAAK,KAAK,EAAE,IAAIA,KAAK,KAAK,CAAC,GAAG,GAAIU,WAAW,GAAG,CAAE;QAClH;MACJ;MACA;MACA,IAAIlN,IAAI,CAACiO,UAAU,CAACC,aAAa,KAAK,KAAK,EAAE;QACzClC,MAAM,GAAGA,MAAM,GAAG5O,KAAK,GAAGyP,KAAK;MACnC,CAAC,MACI,IAAI7M,IAAI,CAACiO,UAAU,CAACC,aAAa,KAAK,MAAM,EAAE;QAC/ClC,MAAM,GAAGA,MAAM,GAAG5O,KAAK,GAAGyP,KAAK;MACnC,CAAC,MACI,IAAI7M,IAAI,CAACiO,UAAU,CAACC,aAAa,KAAK,QAAQ,EAAE;QACjD;QACAlC,MAAM,GAAGA,MAAM;MACnB;MACA;MACA,IAAIK,gBAAgB,IAAIrM,IAAI,CAAC4O,kBAAkB,KAAK,QAAQ,IAAIpC,KAAK,KAAK,CAAC,EAAE;QACzER,MAAM,IAAIhM,IAAI,CAAC4O,kBAAkB,KAAK,MAAM,GAAG,EAAExR,KAAK,GAAG,CAAC,CAAC,GAAIA,KAAK,GAAG,CAAE;MAC7E;MACA,IAAI2U,oBAAoB,GAAG1F,gBAAgB,GACtCoF,iBAAiB,GAAIxF,WAAW,CAACvO,MAAM,GAAKqO,KAAK,CAACyB,cAAc,CAACpQ,KAAK,GAAG,CAAE,GAAI,CAAC;MACrFN,OAAO,GAAGuP,gBAAgB,GAAIE,SAAS,GAAGL,UAAU,GAAGlM,IAAI,CAAC4G,SAAS,CAACxJ,KAAK,GAAG,GAAG,GAAIN,OAAO;MAC5F;MACA,IAAI0U,aAAa,IAAIhF,KAAK,EAAE;QACxB,IAAIH,gBAAgB,EAAE;UAClBnC,MAAM,GAAGI,SAAS,GAAIrN,IAAI,CAACQ,CAAC,GAAGX,OAAO,GAAIiV,oBAAqB,GAAK9U,IAAI,CAACQ,CAAC,GAAGX,OAAO,GAAIiV,oBAAsB;QAClH,CAAC,MACI;UACD7H,MAAM,GAAGI,SAAS,GAAIrN,IAAI,CAACQ,CAAC,GAAGX,OAAO,GAAGoQ,WAAW,GAAKjQ,IAAI,CAACQ,CAAC,GAAGX,OAAO,GAAGoQ,WAAY;QAC5F;MACJ,CAAC,MACI;QACD,IAAIb,gBAAgB,EAAE;UAClBF,YAAY,GAAG,CAAC0F,oBAAoB,GAAG,EAAE/U,OAAO,GAAGmD,eAAe,GAAI8R,oBAAqB,CAAC,GACxFjV,OAAO,GAAGmD,eAAe,IAAIuM,KAAK,GAAGuF,oBAAoB,GAAI,CAAC,GAAG7E,WAAY,CAAC;QACtF,CAAC,MACI;UACDf,YAAY,GAAG,CAAC0F,oBAAoB,GAChC,EAAE/U,OAAO,GAAGmD,eAAe,IAAIuM,KAAK,GAAGU,WAAW,GAAInB,KAAK,CAACnD,KAAK,GAAG,CAAC,GAAI,CAAC,GAAGsE,WAAW,GAAI,CAAE,CAAC,CAAC,GAChGpQ,OAAO,GAAGmD,eAAe,GAAI,CAACuM,KAAK,GAAG,CAAC,GAAG,CAAC,IAAIU,WAAY;QACnE;QACAhD,MAAM,GAAIjN,IAAI,CAACQ,CAAC,GAAI0O,YAAY,GAAGJ,KAAK,CAACnD,KAAO;MACpD;MACA;MACA,IAAIyD,gBAAgB,EAAE;QAClBsC,MAAM,GAAG,IAAI,CAACqD,SAAS,CAAChS,IAAI,CAAC,CAAC,CAAC;MACnC,CAAC,MACI;QACD2O,MAAM,GAAI9R,KAAK,CAACmG,SAAS,GAAM8O,WAAW,GAAI,EAAE,GAAG,KAAK,GAAKjV,KAAK,CAACoV,YAAY,IAAIH,WAAW,GAAI,KAAK,GAAG,EAAE;MAChH;MACA1F,OAAO,GAAG,IAAIjQ,UAAU,CAACU,KAAK,CAACmJ,OAAO,CAACD,EAAE,GAAG6C,KAAK,GAAG,aAAa,GAAGzH,CAAC,EAAE6K,MAAM,EAAE9B,MAAM,EAAEyE,MAAM,CAAC;MAC9F,IAAI3O,IAAI,CAACmO,kBAAkB,IAAK3B,KAAK,KAAK,CAAE,EAAE;QAC1C,QAAQxM,IAAI,CAACmO,kBAAkB;UAC3B,KAAK,MAAM;YACP;UACJ,KAAK,MAAM;YACP,IAAK,CAAChN,CAAC,KAAK,CAAC,IAAK2L,SAAS,IAAI3L,CAAC,KAAKC,GAAG,GAAG,CAAE,KAAKgL,OAAO,CAAC5O,CAAC,GAAGP,IAAI,CAACO,CAAC,IAC/D,CAAC2D,CAAC,KAAKC,GAAG,GAAG,CAAC,IAAK0L,SAAS,IAAI3L,CAAC,KAAK,CAAE,KAAMiL,OAAO,CAAC5O,CAAC,GAAGJ,KAAK,GAAGH,IAAI,CAACO,CAAC,GAAGP,IAAI,CAACG,KAAO,EAAE;cAC1F;YACJ;YACA;UACJ,KAAK,OAAO;YACR,IAAI,CAAC+D,CAAC,KAAK,CAAC,IAAK2L,SAAS,IAAI3L,CAAC,KAAKC,GAAG,GAAG,CAAE,KAAKgL,OAAO,CAAC5O,CAAC,GAAGP,IAAI,CAACO,CAAC,EAAE;cACjEyP,cAAc,IAAKhQ,IAAI,CAACO,CAAC,GAAG4O,OAAO,CAAC5O,CAAE;cACtC4O,OAAO,CAAC5O,CAAC,GAAGwO,MAAM,GAAG/O,IAAI,CAACO,CAAC;YAC/B,CAAC,MACI,IAAI,CAAC2D,CAAC,KAAKC,GAAG,GAAG,CAAC,IAAK0L,SAAS,IAAI3L,CAAC,KAAK,CAAE,KAAOiL,OAAO,CAAC5O,CAAC,GAAGJ,KAAK,GAAIH,IAAI,CAACO,CAAC,GAAGP,IAAI,CAACG,KAAM,EAAE;cAC/F,IAAI6O,WAAW,CAAC7O,KAAK,GAAG6P,cAAc,IAAIjN,IAAI,CAACgO,oBAAoB,KAAK,MAAM,EAAE;gBAC5Ef,cAAc,IAAKb,OAAO,CAAC5O,CAAC,GAAGJ,KAAK,IAAIH,IAAI,CAACO,CAAC,GAAGP,IAAI,CAACG,KAAK,CAAE;cACjE,CAAC,MACI;gBACD6P,cAAc,GAAG7P,KAAK;cAC1B;cACAgP,OAAO,CAAC5O,CAAC,GAAGwO,MAAM,GAAG/O,IAAI,CAACO,CAAC,GAAGP,IAAI,CAACG,KAAK,GAAG6P,cAAc;YAC7D;YACA;QAAM;MAElB;MACAb,OAAO,CAAC2B,IAAI,GAAG,IAAI,CAACmE,YAAY,CAACnG,KAAK,EAAE/L,IAAI,EAAEiN,cAAc,CAAC;MAC7D;MACA;MACA,IAAIkF,MAAM,GAAG,KAAK,CAAC;MACnB,IAAIC,OAAO,GAAG,KAAK,CAAC;MACpB,IAAI/F,gBAAgB,IAAIG,KAAK,KAAK,CAAC,EAAE;QACjC,IAAIxM,IAAI,CAAC4O,kBAAkB,KAAK,OAAO,EAAE;UACrCuD,MAAM,GAAI/F,OAAO,CAAC5O,CAAC,GAAGJ,KAAM;UAC5BgV,OAAO,GAAGhG,OAAO,CAAC5O,CAAC;QACvB,CAAC,MACI,IAAIwC,IAAI,CAAC4O,kBAAkB,KAAK,QAAQ,EAAE;UAC3CuD,MAAM,GAAI/F,OAAO,CAAC5O,CAAC,GAAIJ,KAAK,GAAG,CAAG;UAClCgV,OAAO,GAAGhG,OAAO,CAAC5O,CAAC,GAAIJ,KAAK,GAAG,CAAE;QACrC,CAAC,MACI;UACD+U,MAAM,GAAG/F,OAAO,CAAC5O,CAAC;UAClB4U,OAAO,GAAGhG,OAAO,CAAC5O,CAAC,GAAGJ,KAAK;QAC/B;MACJ,CAAC,MACI;QACD+U,MAAM,GAAG/F,OAAO,CAAC5O,CAAC;QAClB4U,OAAO,GAAGhG,OAAO,CAAC5O,CAAC,GAAGJ,KAAK;MAC/B;MACA;MACA,IAAIoP,KAAK,KAAK,CAAC,IAAIxM,IAAI,CAACgO,oBAAoB,KAAK,MAAM,IAAI7M,CAAC,KAAK,CAAC,KAC7D,CAAC2L,SAAS,GAAGqF,MAAM,IAAInF,WAAW,GAAGoF,OAAO,IAAIpF,WAAW,CAAC,EAAE;QAC/D;MACJ;MACA;MACA,IAAIX,gBAAgB,EAAE;QAClB,IAAIrM,IAAI,CAAC4O,kBAAkB,KAAK,OAAO,EAAE;UACrC5B,WAAW,GAAGF,SAAS,GAAIV,OAAO,CAAC5O,CAAC,GAAGJ,KAAK,GAAIgP,OAAO,CAAC5O,CAAC;QAC7D,CAAC,MACI,IAAIwC,IAAI,CAAC4O,kBAAkB,KAAK,QAAQ,EAAE;UAC3C5B,WAAW,GAAGF,SAAS,GAAIV,OAAO,CAAC5O,CAAC,GAAIJ,KAAK,GAAG,CAAE,GAAIgP,OAAO,CAAC5O,CAAC,GAAIJ,KAAK,GAAG,CAAE;QACjF,CAAC,MACI;UACD4P,WAAW,GAAGF,SAAS,GAAGV,OAAO,CAAC5O,CAAC,GAAG4O,OAAO,CAAC5O,CAAC,GAAGJ,KAAK;QAC3D;MACJ,CAAC,MACI;QACD4P,WAAW,GAAGF,SAAS,GAAGV,OAAO,CAAC5O,CAAC,GAAG4O,OAAO,CAAC5O,CAAC,GAAGJ,KAAK;MAC3D;MACA;MACA;MACA;MACA,IAAIoP,KAAK,KAAK,CAAC,EAAE;QACb,IAAI9O,MAAM,GAAG,KAAK,CAAC;QACnB,IAAI2U,MAAM,GAAG,KAAK,CAAC;QACnB,IAAIhG,gBAAgB,EAAE;UAClB,IAAIiG,WAAW,GAAG,CAAC;UACnB,IAAIC,WAAW,GAAG,CAAC;UACnB7U,MAAM,GAAIqO,KAAK,CAACyB,cAAc,CAAC9P,MAAO;UACtC6U,WAAW,GAAIxG,KAAK,CAACyB,cAAc,CAAC9P,MAAM,GAAI,CAAC,CAAC,CAAC;UACjD;UACA,IAAIsC,IAAI,CAAC4O,kBAAkB,KAAK,QAAQ,EAAE;YACtC0D,WAAW,GAAG,EAAEvG,KAAK,CAACyB,cAAc,CAACpQ,KAAK,GAAG,CAAC,CAAC;UACnD,CAAC,MACI,IAAI4C,IAAI,CAAC4O,kBAAkB,KAAK,OAAO,EAAE;YAC1C0D,WAAW,GAAG,CAACvG,KAAK,CAACyB,cAAc,CAACpQ,KAAK;UAC7C;UACA;UACA,IAAIyU,oBAAoB,EAAE;YACtBU,WAAW,GAAIxG,KAAK,CAACyB,cAAc,CAAC9P,MAAM,IAAK0O,OAAO,CAAC2B,IAAI,CAAChP,MAAM,GAAG,CAAC,CAAC;UAC3E;UACAsT,MAAM,GAAG,IAAIpW,IAAI,CAACmQ,OAAO,CAAC5O,CAAC,GAAG8U,WAAW,EAAElG,OAAO,CAAC3O,CAAC,GAAI8U,WAAY,EAAExG,KAAK,CAACyB,cAAc,CAACpQ,KAAK,EAAEM,MAAM,CAAC;QAC7G,CAAC,MACI;UACDA,MAAM,GAAIwM,MAAM,IAAKkC,OAAO,CAAC3O,CAAC,IAAKsO,KAAK,CAAClM,IAAI,CAACnC,MAAM,GAAG,CAAC,GAAI,EAAE,CAAC,CAAC;UAChE2U,MAAM,GAAG,IAAIpW,IAAI,CAACmQ,OAAO,CAAC5O,CAAC,EAAE4O,OAAO,CAAC3O,CAAC,IAAKsO,KAAK,CAAClM,IAAI,CAACnC,MAAM,GAAG,CAAC,GAAI,CAAC,CAAC,EAAEqO,KAAK,CAAClM,IAAI,CAACzC,KAAK,EAAEM,MAAM,CAAC;QACrG;QACA,IAAI8U,eAAe,GAAG,IAAI,CAACC,kBAAkB,CAACJ,MAAM,CAAC;QACrD,IAAIK,WAAW,GAAGrG,gBAAgB,GAAGgG,MAAM,CAAC7U,CAAC,GAAI6U,MAAM,CAACjV,KAAK,GAAG,CAAE,GAAG4O,MAAM;QAC3E,IAAI2G,WAAW,GAAGtG,gBAAgB,GAAGgG,MAAM,CAAC5U,CAAC,GAAI4U,MAAM,CAAC3U,MAAM,GAAG,CAAE,GAAIwM,MAAM,GAAIxM,MAAM,GAAG,CAAG;QAC7F,IAAI2O,gBAAgB,EAAE;UAClBD,OAAO,CAACkC,SAAS,GAAG,SAAS,GAAG9B,KAAK,GAAG,GAAG,GAAGkG,WAAW,GAAG,GAAG,GAAGC,WAAW,GAAG,GAAG;QACvF,CAAC,MACI;UACDvG,OAAO,CAACkC,SAAS,GAAG,SAAS,GAAG9B,KAAK,GAAG,GAAG,GAAGR,MAAM,GAAG,GAAG,GAAG9B,MAAM,GAAG,GAAG;QAC7E;QACAyH,SAAS,CAACjP,IAAI,CAACnG,8BAA8B,CAACiW,eAAe,EAAEE,WAAW,EAAEC,WAAW,EAAEnG,KAAK,CAAC,CAAC;QAChGoF,uBAAuB,GAAG,KAAK;QAC/B,KAAK,IAAIgB,OAAO,GAAGzR,CAAC,EAAEyR,OAAO,GAAG,CAAC,EAAEA,OAAO,EAAE,EAAE;UAC1C,IAAIjB,SAAS,CAACxQ,CAAC,CAAC,IAAIwQ,SAAS,CAACiB,OAAO,GAAG,CAAC,CAAC,IAAIpW,sBAAsB,CAACmV,SAAS,CAACxQ,CAAC,CAAC,EAAEwQ,SAAS,CAACiB,OAAO,GAAG,CAAC,CAAC,CAAC,EAAE;YACxGhB,uBAAuB,GAAG,IAAI;YAC9BD,SAAS,CAACxQ,CAAC,CAAC,GAAG,IAAI;YACnB;UACJ;QACJ;MACJ;MACA;MACA9E,WAAW,CAACQ,KAAK,CAACgJ,QAAQ,EAAEuG,OAAO,EAAEL,KAAK,CAACkC,UAAU,EAAElC,KAAK,CAACkC,UAAU,CAAChG,KAAK,IAAIpL,KAAK,CAAC+M,UAAU,CAAC2E,SAAS,EAAE9B,YAAY,EAAGzM,IAAI,CAAC+B,qBAAqB,MAAM/B,IAAI,CAACoH,aAAa,KAAK,QAAQ,CAAC,EAAGvK,KAAK,CAACuL,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE2D,KAAK,CAAClM,IAAI,EAAE+R,uBAAuB,EAAE/U,KAAK,CAAC+K,YAAY,CAAC;IACjS;IACA,IAAI,CAAC,IAAI,CAAC/K,KAAK,CAAC+K,YAAY,EAAE;MAC1B,IAAI,CAAC/K,KAAK,CAACqB,WAAW,EAAE;QACpBsL,MAAM,CAAC3B,WAAW,CAAC4E,YAAY,CAAC;MACpC,CAAC,MACI,IAAIzM,IAAI,CAACwG,OAAO,IAAIxG,IAAI,CAAC2G,kBAAkB,EAAE;QAC9C,IAAI,CAAC6H,kBAAkB,CAAC,IAAI,CAAC3R,KAAK,EAAE4P,YAAY,EAAEzM,IAAI,EAAE4I,KAAK,EAAE3L,IAAI,CAAC;MACxE;IACJ;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACIN,wBAAwB,CAACI,SAAS,CAACiV,SAAS,GAAG,UAAUhS,IAAI,EAAE;IAC3D,OAAQA,IAAI,CAAC4O,kBAAkB,KAAK,QAAQ,GAAG,QAAQ,GAAI,IAAI,CAAC/R,KAAK,CAACmG,SAAS,GAAKhD,IAAI,CAAC4O,kBAAkB,KAAK,MAAM,GAAG,KAAK,GAAG,OAAO,GAAK5O,IAAI,CAAC4O,kBAAkB,KAAK,MAAM,GAAG,OAAO,GAAG,KAAM;EACtM,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACIjS,wBAAwB,CAACI,SAAS,CAAC0V,kBAAkB,GAAG,UAAUxV,IAAI,EAAE;IACpE,IAAI4V,MAAM,GAAG,IAAItX,aAAa,CAAC0B,IAAI,CAACO,CAAC,EAAEP,IAAI,CAACQ,CAAC,CAAC;IAC9C,IAAIqV,MAAM,GAAG,IAAIvX,aAAa,CAAC0B,IAAI,CAACO,CAAC,GAAGP,IAAI,CAACG,KAAK,EAAEH,IAAI,CAACQ,CAAC,CAAC;IAC3D,IAAIsV,MAAM,GAAG,IAAIxX,aAAa,CAAC0B,IAAI,CAACO,CAAC,GAAGP,IAAI,CAACG,KAAK,EAAEH,IAAI,CAACQ,CAAC,GAAGR,IAAI,CAACS,MAAM,CAAC;IACzE,IAAIsV,MAAM,GAAG,IAAIzX,aAAa,CAAC0B,IAAI,CAACO,CAAC,EAAEP,IAAI,CAACQ,CAAC,GAAGR,IAAI,CAACS,MAAM,CAAC;IAC5D,OAAO,CAACmV,MAAM,EAAEC,MAAM,EAAEC,MAAM,EAAEC,MAAM,CAAC;EAC3C,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIrW,wBAAwB,CAACI,SAAS,CAACmV,YAAY,GAAG,UAAUnG,KAAK,EAAE/L,IAAI,EAAEiN,cAAc,EAAE;IACrF,IAAI3R,YAAY,CAACyQ,KAAK,CAAC6B,YAAY,CAAC,EAAE;MAClC,IAAI3I,MAAM,GAAG,EAAE;MACf,IAAIgO,GAAG,GAAG,KAAK,CAAC;MAChB,KAAK,IAAIrK,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGmD,KAAK,CAACgC,IAAI,CAAChP,MAAM,EAAE6J,KAAK,EAAE,EAAE;QACpDqK,GAAG,GAAG,IAAI,CAACC,aAAa,CAAClT,IAAI,EAAE+L,KAAK,CAACgC,IAAI,CAACnF,KAAK,CAAC,EAAEqE,cAAc,CAAC;QACjEhI,MAAM,CAACvC,IAAI,CAACuQ,GAAG,CAAC;MACpB;MACA,OAAOhO,MAAM;IACjB,CAAC,MACI;MACD,OAAO,IAAI,CAACiO,aAAa,CAAClT,IAAI,EAAE+L,KAAK,CAACgC,IAAI,EAAEd,cAAc,CAAC;IAC/D;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACItQ,wBAAwB,CAACI,SAAS,CAACuK,eAAe,GAAG,UAAUtH,IAAI,EAAE4I,KAAK,EAAEY,MAAM,EAAE2J,QAAQ,EAAE;IAC1F,IAAInT,IAAI,CAACgI,MAAM,CAAC5K,KAAK,GAAG,CAAC,EAAE;MACvB,IAAI6C,eAAe,GAAGD,IAAI,CAACoH,aAAa,KAAK,SAAS,GAAGpH,IAAI,CAACC,eAAe,GAAG,CAAC;MACjF,IAAIqK,SAAS,GAAGtK,IAAI,CAAC+B,qBAAqB;MAC1C,IAAIqR,MAAM,GAAG,KAAK,CAAC;MACnB,IAAIvE,MAAM,GAAGsE,QAAQ,CAAC1V,CAAC,GAAI,CAAC6M,SAAS,GAAG,CAAC,CAAC,GAAG,CAAC,IAAIrK,eAAgB;MAClE,IAAInD,OAAO,GAAG,EAAE;MAChB,IAAIkP,MAAM,GAAG,KAAK,CAAC;MACnB,IAAI8C,GAAG,GAAIqE,QAAQ,CAAC/V,KAAK,GAAG4C,IAAI,CAAC2I,YAAY,CAACoG,KAAK,IAAK/O,IAAI,CAAC6D,SAAS,KAAK,UAAU,GAAG7D,IAAI,CAACgP,gBAAgB,GACvGhP,IAAI,CAAC2I,YAAY,CAACuC,QAAQ,CAAC;MACjC,IAAImE,IAAI,GAAG,KAAK,CAAC;MACjB,IAAIgE,QAAQ,GAAGrT,IAAI,CAACmP,YAAY,CAACzR,MAAM,IACjCsC,IAAI,CAACkH,YAAY,KAAKlH,IAAI,CAACoH,aAAa,GAAIpH,IAAI,CAACgH,cAAc,CAACtJ,MAAM,GAAG,CAAC,CAAC;MACjF,IAAI0R,WAAW,GAAG,EAAE;MACpB,IAAI3E,aAAa,GAAIzK,IAAI,CAAC6D,SAAS,KAAK,UAAU,IAAI7D,IAAI,CAAC0K,cAAc,KAAK,cAAc,GAAI,CAAC,GAAG,GAAG,CAAC;MACxG,IAAIuE,IAAI,GAAK3E,SAAS,IAAItK,IAAI,CAACoH,aAAa,KAAK,QAAQ,IACpD,CAACkD,SAAS,IAAItK,IAAI,CAACoH,aAAa,KAAK,SAAU,GAC/C+L,QAAQ,CAAC1V,CAAC,GAAG4V,QAAQ,GAAGvW,OAAO,GAAGmD,eAAe,GAAKkT,QAAQ,CAAC1V,CAAC,GAAG4V,QAAQ,GAAGvW,OAAO,GAAGmD,eAAgB;MAC7G,KAAK,IAAIkB,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGpB,IAAI,CAAC6K,aAAa,CAAC9L,MAAM,EAAEoC,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;QAC3D6K,MAAM,GAAG7Q,kBAAkB,CAAC6E,IAAI,CAAC6K,aAAa,CAAC1J,CAAC,CAAC,CAAC8J,KAAK,GAAGR,aAAa,EAAEzK,IAAI,CAAC;QAC9EgM,MAAM,GAAG,CAAChM,IAAI,CAAC+M,aAAa,GAAI,CAAC,GAAGf,MAAM,GAAIA,MAAM,IAAImH,QAAQ,CAAC/V,KAAK;QACtE,IAAI4C,IAAI,CAAC6D,SAAS,KAAK,UAAU,IAAI7D,IAAI,CAAC0K,cAAc,KAAK,cAAc,EAAE;UACzE0I,MAAM,GAAGpH,MAAM,GAAGmH,QAAQ,CAAC3V,CAAC;UAC5B6R,IAAI,GAAGrD,MAAM,GAAI8C,GAAI,GAAGqE,QAAQ,CAAC3V,CAAC;QACtC,CAAC,MACI;UACD4V,MAAM,GAAGpH,MAAM,GAAG8C,GAAG,GAAG,GAAG,GAAGqE,QAAQ,CAAC3V,CAAC;UACxC6R,IAAI,GAAGrD,MAAM,GAAG8C,GAAG,GAAG,GAAG,GAAGqE,QAAQ,CAAC3V,CAAC;QAC1C;QACA,QAAQwC,IAAI,CAACgI,MAAM,CAAChE,IAAI;UACpB,KAAK,WAAW;UAChB,KAAK,kBAAkB;YACnB,IAAIoP,MAAM,GAAGD,QAAQ,CAAC3V,CAAC,EAAE;cACrB4R,WAAW,IAAK,GAAG,GAAG,GAAG,GAAG+D,QAAQ,CAAC3V,CAAC,GAAG,GAAG,GAAGyR,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAGI,IAAI,GAAG,GAAG,GAAGJ,IAAI,GAAG,GAAI;YACpG,CAAC,MACI,IAAI5J,IAAI,CAACyI,KAAK,CAACuB,IAAI,CAAC,GAAG8D,QAAQ,CAAC/V,KAAK,GAAG+V,QAAQ,CAAC3V,CAAC,IAAI,EAAEwC,IAAI,CAAC6K,aAAa,CAAC9L,MAAM,KAAK,CAAC,CAAC,EAAE;cAC3FqQ,WAAW,IAAK,GAAG,GAAG,GAAG,GAAGgE,MAAM,GAAG,GAAG,GAAGvE,MAAM,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAGuE,MAAM,GAAG,GAAG,GAAGnE,IAAI,GAAG,GAAG,GAC3F,GAAG,GAAG,GAAG,IAAIkE,QAAQ,CAAC/V,KAAK,GAAG+V,QAAQ,CAAC3V,CAAC,CAAC,GAAG,GAAG,GAAGyR,IAAI,GAAG,GAAI;YACrE,CAAC,MACI;cACDG,WAAW,IAAK,GAAG,GAAG,GAAG,GAAGgE,MAAM,GAAG,GAAG,GAAGvE,MAAM,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAGuE,MAAM,GAAG,GAAG,GAC9EnE,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAGI,IAAI,GAAG,GAAG,GAAGJ,IAAI,GAAG,GAAI;cACrD,IAAI9N,CAAC,KAAK,CAAC,EAAE;gBACTiO,WAAW,IAAK,GAAG,GAAG,GAAG,GAAGgE,MAAM,GAAG,GAAG,GAAGvE,MAAM,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAGuE,MAAM,GAAG,GAAG,GAAGnE,IAAI,GAAG,GAAG,GAC3F,IAAI,GAAGmE,MAAM,GAAG,GAAG,GAAGnE,IAAI,GAAG,KAAK,GAAIkE,QAAQ,CAAC3V,CAAE,GAAG,GAAG,GAAGyR,IAAK;cACvE;cACA,IAAI9N,CAAC,KAAKnB,IAAI,CAAC6K,aAAa,CAAC9L,MAAM,GAAG,CAAC,EAAE;gBACrCqQ,WAAW,IAAK,GAAG,GAAG,GAAG,GAAGC,IAAI,GAAG,GAAG,GAAGR,MAAM,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAGQ,IAAI,GAAG,GAAG,GAAGJ,IAAI,GAAG,GAAG,GACvF,IAAI,GAAGI,IAAI,GAAG,GAAG,GAAGJ,IAAI,GAAG,KAAK,IAAIkE,QAAQ,CAAC/V,KAAK,GAAG+V,QAAQ,CAAC3V,CAAC,CAAC,GAAG,GAAG,GAAGyR,IAAK;cACtF;YACJ;YACA;UACJ,KAAK,2BAA2B;YAC5B,IAAI,EAAEmE,MAAM,GAAGD,QAAQ,CAAC3V,CAAC,CAAC,IAAI,EAAE6H,IAAI,CAACyI,KAAK,CAACuB,IAAI,CAAC,GAAG8D,QAAQ,CAAC/V,KAAK,GAAG+V,QAAQ,CAAC3V,CAAC,CAAC,EAAE;cAC7E4R,WAAW,IAAK,GAAG,GAAG,GAAG,GAAGgE,MAAM,GAAG,GAAG,GAAGvE,MAAM,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAGuE,MAAM,GAAG,GAAG,GAAGnE,IAAI,GAAG,GAAG,GAC3F,IAAI,GAAGI,IAAI,GAAG,GAAG,GAAGR,MAAM,GAAG,KAAK,GAAGQ,IAAI,GAAG,GAAG,GAAGJ,IAAK;YAC/D;YACA;QAAM;MAElB;MACAG,WAAW,IAAKpP,IAAI,CAACgI,MAAM,CAAChE,IAAI,KAAK,WAAW,GAAI,IAAI,GAAG,GAAG,GAAGmP,QAAQ,CAAC3V,CAAC,GAAG,GAAG,GAAGqR,MAAM,GAAG,GAAG,GAAG,GAAG,IACjGsE,QAAQ,CAAC3V,CAAC,GAAG2V,QAAQ,CAAC/V,KAAK,CAAC,GAAG,GAAG,GAAGyR,MAAM,GAAI,EAAG;MACvD,IAAIO,WAAW,KAAK,EAAE,EAAE;QACpB,IAAI,CAACE,uBAAuB,CAACtP,IAAI,EAAE4I,KAAK,EAAEwG,WAAW,EAAE5F,MAAM,CAAC;MAClE;IACJ;IACA,IAAI,IAAI,CAAC3M,KAAK,CAAC2S,qBAAqB,IAAIxP,IAAI,CAACuP,gBAAgB,CAACxQ,MAAM,GAAG,CAAC,EAAE;MACtE,IAAI,CAAClC,KAAK,CAAC2S,qBAAqB,CAAC8D,2BAA2B,CAACtT,IAAI,EAAE4I,KAAK,EAAEY,MAAM,EAAE2J,QAAQ,CAAC;IAC/F;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIxW,wBAAwB,CAACI,SAAS,CAACuS,uBAAuB,GAAG,UAAUtP,IAAI,EAAE4I,KAAK,EAAEwG,WAAW,EAAE5F,MAAM,EAAE;IACrG,IAAIxD,OAAO,GAAGjK,UAAU,CAAC,IAAI,CAACc,KAAK,CAACmJ,OAAO,CAACD,EAAE,GAAG,cAAc,GAAG6C,KAAK,CAAC;IACxE,IAAIa,SAAS,GAAGzD,OAAO,GAAGA,OAAO,CAAC0D,YAAY,CAAC,GAAG,CAAC,GAAG,EAAE;IACxD,IAAI6J,aAAa,GAAG,IAAI,CAAC1W,KAAK,CAACgJ,QAAQ,CAACiE,QAAQ,CAAC,IAAI1N,UAAU,CAAC,IAAI,CAACS,KAAK,CAACmJ,OAAO,CAACD,EAAE,GAAG,cAAc,GAAG6C,KAAK,EAAE,aAAa,EAAE5I,IAAI,CAACgI,MAAM,CAAC5K,KAAK,EAAE4C,IAAI,CAACgI,MAAM,CAACC,KAAK,IAAI,IAAI,CAACpL,KAAK,CAAC+M,UAAU,CAACC,QAAQ,EAAE,CAAC,EAAE,EAAE,EAAEuF,WAAW,CAAC,CAAC;IAC3NmE,aAAa,CAACC,KAAK,CAACC,aAAa,GAAG,MAAM;IAC1C/X,kBAAkB,CAAC,IAAI,CAACmB,KAAK,CAAC+K,YAAY,EAAE4B,MAAM,EAAE+J,aAAa,EAAE,IAAI,CAAC1W,KAAK,CAACuL,MAAM,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAEqB,SAAS,EAAE,IAAI,CAAC;EAChI,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI9M,wBAAwB,CAACI,SAAS,CAACmW,aAAa,GAAG,UAAUlT,IAAI,EAAE+L,KAAK,EAAE3O,KAAK,EAAE;IAC7E,OAAQ4C,IAAI,CAACgO,oBAAoB,KAAK,MAAM,GACtChO,IAAI,CAACwM,KAAK,GAAG,GAAG,KAAK,CAAC,IAAI,CAACxM,IAAI,CAAC0T,UAAU,GAAIpX,QAAQ,CAACc,KAAK,EAAE2O,KAAK,EAAE/L,IAAI,CAACiO,UAAU,CAAC,GAAGlC,KAAK,GAAIA,KAAK;EAChH,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIpP,wBAAwB,CAACI,SAAS,CAACwK,cAAc,GAAG,UAAUvH,IAAI,EAAE4I,KAAK,EAAEY,MAAM,EAAEvM,IAAI,EAAE;IACrF,IAAI+C,IAAI,CAAC0P,KAAK,EAAE;MACZ,IAAI7S,KAAK,GAAG,IAAI,CAACA,KAAK;MACtB,IAAIoP,WAAW,GAAG/P,WAAW,CAAC8D,IAAI,CAAC0P,KAAK,EAAE1P,IAAI,CAACgQ,UAAU,CAAC;MAC1D,IAAI/P,eAAe,GAAGjF,iBAAiB,CAACgF,IAAI,CAACqD,SAAS,CAAC,GAAGrD,IAAI,CAACC,eAAe,GAAG,CAAC;MAClF,IAAInD,OAAO,GAAG,CAACkD,IAAI,CAACkH,YAAY,KAAK,QAAQ,GAAG,CAAC,GAAGlH,IAAI,CAACgH,cAAc,CAACtJ,MAAM,GAAGsC,IAAI,CAAC4P,YAAY,KAC7F5P,IAAI,CAACoH,aAAa,KAAK,QAAQ,GAAG,CAAC,GAChCpH,IAAI,CAACmP,YAAY,CAACzR,MAAM,GAAGsC,IAAI,CAAC6P,qBAAqB,GAAG7P,IAAI,CAACmM,YAAY,CAAC;MAClF,IAAI2D,SAAS,GAAI9P,IAAI,CAAC8P,SAAS,CAACpS,MAAM,IAAIsC,IAAI,CAAC+P,eAAe,CAAChR,MAAM,GAAG,CAAC,CAAE;MAC3EjC,OAAO,GAAGkD,IAAI,CAAC+B,qBAAqB,GAAG,EAAEjF,OAAO,GAAGmP,WAAW,CAACvO,MAAM,GAAG,CAAC,GAAGuC,eAAe,GAAG6P,SAAS,CAAC,GAAIhT,OAAO,GAAI,CAAC,GACpHmP,WAAW,CAACvO,MAAM,GAAG,CAAE,GAAGuC,eAAgB;MAC9C,IAAImM,OAAO,GAAG,IAAIjQ,UAAU,CAACU,KAAK,CAACmJ,OAAO,CAACD,EAAE,GAAG,aAAa,GAAG6C,KAAK,EAAE3L,IAAI,CAACO,CAAC,GAAGP,IAAI,CAACG,KAAK,GAAG,GAAG,EAAEH,IAAI,CAACQ,CAAC,GAAGX,OAAO,EAAE,QAAQ,EAAEkD,IAAI,CAAC+P,eAAe,CAAC;MACnJ,IAAI/J,OAAO,GAAG3J,WAAW,CAACQ,KAAK,CAACgJ,QAAQ,EAAEuG,OAAO,EAAEpM,IAAI,CAACgQ,UAAU,EAAEhQ,IAAI,CAACgQ,UAAU,CAAC/H,KAAK,IAAIpL,KAAK,CAAC+M,UAAU,CAACqG,SAAS,EAAEzG,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE3M,KAAK,CAAC+K,YAAY,CAAC;MACpM5B,OAAO,CAACkK,YAAY,CAAC,YAAY,EAAElQ,IAAI,CAACqQ,WAAW,IAAIrQ,IAAI,CAAC0P,KAAK,CAAC;MAClE1J,OAAO,CAACkK,YAAY,CAAC,UAAU,EAAElQ,IAAI,CAACmQ,QAAQ,CAACC,QAAQ,EAAE,CAAC;IAC9D;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIzT,wBAAwB,CAACI,SAAS,CAACqO,cAAc,GAAG,UAAUpL,IAAI,EAAE4I,KAAK,EAAE+K,aAAa,EAAEC,SAAS,EAAEC,MAAM,EAAEC,SAAS,EAAEtK,MAAM,EAAEuK,UAAU,EAAEpK,SAAS,EAAE;IACnJ,IAAIA,SAAS,KAAK,KAAK,CAAC,EAAE;MAAEA,SAAS,GAAG,IAAI;IAAE;IAC9C,IAAI9M,KAAK,GAAG,IAAI,CAACA,KAAK;IACtB,IAAI4M,SAAS;IACb,IAAIzD,OAAO;IACX,IAAI4N,SAAS,CAACxW,KAAK,GAAG,CAAC,IAAI4C,IAAI,CAACwG,OAAO,IAAIxG,IAAI,CAAC2G,kBAAkB,IAAIgN,aAAa,EAAE;MACjF3N,OAAO,GAAGjK,UAAU,CAACc,KAAK,CAACmJ,OAAO,CAACD,EAAE,GAAG8N,MAAM,GAAGjL,KAAK,GAAG,GAAG,GAAGkL,SAAS,CAAC;MACzErK,SAAS,GAAGzD,OAAO,GAAGA,OAAO,CAAC0D,YAAY,CAAC,GAAG,CAAC,GAAG,IAAI;MACtD1D,OAAO,GAAG,IAAI;MACd,IAAI,CAACoD,UAAU,GAAGvM,KAAK,CAACgJ,QAAQ,CAACiE,QAAQ,CAAC,IAAI1N,UAAU,CAACS,KAAK,CAACmJ,OAAO,CAACD,EAAE,GAAG8N,MAAM,GAAGjL,KAAK,GAAG,GAAG,GAAGkL,SAAS,EAAE,aAAa,EAAEF,SAAS,CAACxW,KAAK,EAAEwW,SAAS,CAAC3L,KAAK,IAAI8L,UAAU,EAAE,IAAI,EAAEpK,SAAS,EAAEgK,aAAa,CAAC,CAAC;MAC7MjY,kBAAkB,CAACmB,KAAK,CAAC+K,YAAY,EAAE4B,MAAM,EAAE,IAAI,CAACJ,UAAU,EAAEvM,KAAK,CAACuL,MAAM,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAEqB,SAAS,EAAE,IAAI,CAAC;IACxH;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI9M,wBAAwB,CAACI,SAAS,CAACiX,cAAc,GAAG,UAAUC,SAAS,EAAElI,KAAK,EAAEnD,KAAK,EAAE;IACnF,IAAIsL,QAAQ,CAACC,cAAc,CAACF,SAAS,GAAG,WAAW,GAAGrL,KAAK,GAAG,QAAQ,CAAC,CAACwL,QAAQ,CAACF,QAAQ,CAACC,cAAc,CAACpI,KAAK,CAAChG,EAAE,CAAC,CAAC,EAAE;MACjH,OAAOmO,QAAQ,CAACC,cAAc,CAACF,SAAS,GAAG,WAAW,GAAGrL,KAAK,GAAG,QAAQ,CAAC;IAC9E,CAAC,MACI;MACD,OAAOsL,QAAQ,CAACC,cAAc,CAACF,SAAS,GAAG,WAAW,GAAGrL,KAAK,GAAG,SAAS,CAAC;IAC/E;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIjM,wBAAwB,CAACI,SAAS,CAACyR,kBAAkB,GAAG,UAAU3R,KAAK,EAAE4P,YAAY,EAAEzM,IAAI,EAAE4I,KAAK,EAAE3L,IAAI,EAAE;IACtG,IAAIoX,UAAU,GAAG,IAAI,CAACL,cAAc,CAACnX,KAAK,CAACmJ,OAAO,CAACD,EAAE,EAAE0G,YAAY,EAAE7D,KAAK,CAAC;IAC3E6D,YAAY,CAACyD,YAAY,CAAC,SAAS,EAAE,KAAK,CAAC;IAC3C,IAAIoE,WAAW,GAAGzX,KAAK,CAACgJ,QAAQ,CAACC,WAAW,CAAC;MACzCC,EAAE,EAAElJ,KAAK,CAACmJ,OAAO,CAACD,EAAE,GAAG,iBAAiB,GAAG6C;IAC/C,CAAC,CAAC;IACF0L,WAAW,GAAGxY,mBAAmB,CAACe,KAAK,EAAEmD,IAAI,EAAEsU,WAAW,EAAE1L,KAAK,EAAE5I,IAAI,CAACwC,WAAW,KAAK,UAAU,EAAEvF,IAAI,CAAC;IACzGoX,UAAU,CAACE,YAAY,CAAC9H,YAAY,EAAEyH,QAAQ,CAACC,cAAc,CAAC1H,YAAY,CAAC1G,EAAE,CAAC,CAAC;IAC/E,IAAIhK,UAAU,CAACc,KAAK,CAACmJ,OAAO,CAACD,EAAE,GAAG,iBAAiB,GAAG6C,KAAK,CAAC,EAAE;MAC1DyL,UAAU,CAACE,YAAY,CAACD,WAAW,EAAEJ,QAAQ,CAACC,cAAc,CAACG,WAAW,CAACvO,EAAE,CAAC,CAAC;IACjF,CAAC,MACI;MACDsO,UAAU,CAACxM,WAAW,CAACyM,WAAW,CAAC;IACvC;EACJ,CAAC;EACD,OAAO3X,wBAAwB;AACnC,CAAC,EAAG;AACJ,SAASA,wBAAwB"},"metadata":{},"sourceType":"module","externalDependencies":[]}